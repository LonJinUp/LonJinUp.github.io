{"posts":[{"title":"小程序自动上传脚本","content":"小程序自动上传脚本 平时多人开发小程序经常会遇到一个问题：A开发完成后，上传了体验版，然后B也进行开发，开发完成后上传体验版，还需要去后台设置体验版为B的代码，这样就很麻烦了。所以我们可以使用微信小程序提供的miniprogram-ci包来实现自动上传。由于我经常使用uni-app来开发小程序，所以我把脚本放在了uni-app的/upload目录下，配合打包命令即可实现打包后自动上传代码。 代码实现 const { execSync } = require('child_process'); const ci = require('miniprogram-ci'); const packageJson = require('../package.json'); const fs = require('fs'); const path = require('path'); /** * 获取当前 Git用户名 * @returns {string} 返回 Git 用户名 */ function getGitInfo() { try { const branch = execSync('git rev-parse --abbrev-ref HEAD').toString().trim(); const user = execSync('git config user.name').toString().trim(); return { branch, user }; } catch (error) { console.error('获取 Git 信息失败:', error); return null; } } /** * 修改版本号 */ function changeVersion() { const packageJsonPath = path.join(__dirname, '../package.json'); const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')); const version = packageJson.version; const versionParts = version.split('.').map(Number); const env = process.env.NODE_ENV || 'test'; if (env === 'master') { versionParts[2] += 1; if (versionParts[2] &gt; 9) { versionParts[2] = 0; versionParts[1] += 1; } if (versionParts[1] &gt; 9) { versionParts[1] = 0; versionParts[0] += 1; } } packageJson.version = versionParts.join('.'); fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 4), 'utf8'); console.log('最新版本号为：', packageJson.version); return version; } /** * 初始化项目信息 * @returns {ci.Project} 返回 ci.Project 对象 */ function initProjectInfo() { return new ci.Project({ appid: packageJson.appid, type: 'miniProgram', projectPath: './dist/build/mp-weixin', privateKeyPath: './upload/private.xxxxxxxxxx.key', }); } async function upload() { try { const project = initProjectInfo(); const { user, branch } = getGitInfo(); const version = changeVersion(); console.log('⏳开始上传'); const uploadResult = await ci.upload({ project, version, desc: `${user}在${branch}分支上传了体验版本: ${version}`, robot: 10, setting: { es6: true, }, onProgressUpdate: console.log, }); console.log('✅上传成功'); process.exit(0); } catch (e) { console.error('❌上传失败:', e); } } upload(); package.json中添加以下命令： { &quot;name&quot;: &quot;uni-preset-vue&quot;, &quot;version&quot;: &quot;0.0.3&quot;, &quot;appid&quot;: &quot;xxxxxxxxxx&quot;, &quot;scripts&quot;: { &quot;buildTest:mp-weixin&quot;: &quot;uni build -p mp-weixin --mode test &amp;&amp; node upload/index.js&quot;, &quot;buildPre:mp-weixin&quot;: &quot;uni build -p mp-weixin --mode pre &amp;&amp; node upload/index.js&quot;, &quot;buildMaster:mp-weixin&quot;: &quot;uni build -p mp-weixin --mode master &amp;&amp; node upload/index.js&quot; }, } 运行 npm run buildTest:mp-weixin ","link":"https://lonjinup.github.io/mpweixin-upload/"},{"title":"跨标签页通信神器：深入了解BroadcastChannel的妙用","content":"跨标签页通信神器：深入了解 BroadcastChannel 的妙用 最近在做项目遇到一个场景：在项目打开时候连接一个 websocket，在初始化、收到推送消息等场景下，其他页面需要同步进行一些操作，所以需要建立消息广播通知给需要的页面。下面是我想到的一些实现方案。 方案对比 方案 实现思路 推荐指数 优点 缺点 Pinia (Vue 项目) 使用 Vue 的状态管理工具 Pinia，在一个标签页中更新状态，其他标签页订阅状态变化并作出响应。 ⭐⭐⭐⭐ 集成 Vue 项目方便，状态管理强大 仅适用于 Vue 项目，需要额外配置 localStorage 或 sessionStorage 使用 localStorage 或 sessionStorage 存储事件数据，并通过监听 storage 事件在其他标签页中接收消息。 ⭐⭐⭐ 简单易用，无需额外库 事件处理较为复杂，传递复杂数据有局限性 BroadcastChannel 使用 BroadcastChannel 创建频道，在不同标签页中发送和接收消息。 ⭐⭐⭐⭐⭐ 原生支持，多浏览上下文通信简单直观 仅支持同源页面，需要较新浏览器支持 考虑到项目中功能模块复用性，多个项目可能都会用到，所以方案1直接pass；去监听localStorage或sessionStorage也过于繁琐，所以也直接pass；由于是b端项目，无需考虑浏览器兼容的问题，而且BroadcastChannel 在绝大部分浏览器上是支持的，所以我们直接采用方案3即可。 BroadcastChannel介绍 BroadcastChannel 是一种 Web API，允许同一来源的不同浏览上下文（如标签页、iframe 或 Web worker）之间进行消息传递。这种机制使得在同一站点的不同页面之间同步数据变得非常简单和高效。 特性 同源策略：BroadcastChannel 只允许同一来源的页面之间进行通信。 实时通信：消息传递是即时的，没有显著延迟。 简洁易用：API 简单直观，易于上手。 使用场景 多标签页同步：用户在一个标签页中进行的操作可以实时同步到其他标签页。 跨 iframe 通信：在不同的 iframe 之间传递消息，无需通过父页面中转。 Web worker 通信：在主线程和多个 Web worker 之间实现高效通信。 示例 以下是一个使用 BroadcastChannel 进行消息传递的基本示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;BroadcastChannel - Sender&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;inputBox&quot;&gt; &lt;button id=&quot;sendMessageButton&quot;&gt;发送&lt;/button&gt; &lt;script&gt; const channel = new BroadcastChannel('example_channel'); document.getElementById('sendMessageButton').addEventListener('click', () =&gt; { const message = { type: 'update', content: document.getElementById('inputBox').value }; channel.postMessage(message); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 页面B接收消息： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;BroadcastChannel - Receiver&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;接收消息&lt;/h1&gt; &lt;div id=&quot;messages&quot;&gt;&lt;/div&gt; &lt;button id=&quot;closeMessage&quot;&gt;断开&lt;/button&gt; &lt;script&gt; const channel = new BroadcastChannel('example_channel'); channel.onmessage = function(event) { const message = event.data; const messagesDiv = document.getElementById('messages'); const messageElement = document.createElement('div'); messageElement.textContent = `Type: ${message.type}, Content: ${message.content}`; messagesDiv.appendChild(messageElement); }; document.getElementById('closeMessage').addEventListener('click', () =&gt; { channel.close(); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过以上代码，不同的浏览上下文（如不同标签页）可以在同一站点内通过 example_channel 频道进行消息传递，从而实现数据同步和通信；如果不再使用可以调用close()方法进行关闭，这样就可以让其被垃圾回收。 总结 通过对比不同的实现方案，最终选择使用 BroadcastChannel 作为跨标签页通信的解决方案。BroadcastChannel 的优势在于其原生支持，能够实现多浏览上下文之间的简单直观的通信，特别适用于需要高效实时通信的场景。尽管只支持同源页面且需要较新的浏览器支持，但在大多数现代浏览器上都能正常运行。 当然，我们还是根据项目需求去寻找最适合的技术方案，从项目角度出发。 ","link":"https://lonjinup.github.io/BroadcastChannel-study/"},{"title":"\"WebSocket消息推送：前端实现实时通知功能全过程解析\"","content":"WebSocket消息推送 在做一些后台项目的时候，有时候需要前端去实时接收消息；一种比较原始的做法就是前端每隔一段时间主动去轮询服务器，如果用户较多的情况下，会给服务器造成一定的压力，而且访问的频率也无法准确把握，所以这种需求还是使用websocket来解决。 下面我们就从0到1封装一套websocket消息推送功能模块。文章涉及到的知识均为前端部分，后端部分我们就不展开来说了。如果文章对你有帮助，记得👍点赞🌟收藏！ 需求梳理 我们还是使用class来封装，该模块需要提供以下功能： WebSocket对象的创建 WebSocket对象的关闭 启用心跳机制，避免断连 消息推送，接收到消息后进行业务逻辑处理 重连机制，如果断连后尝试一定次数的重连，超过最大次数后仍然失败则关闭连接 下面我们就逐一实现这些功能。 功能实现 创建WebSocket类 新建WebSocketManager.js文件，创建一个WebSocketManager类，同时初始化一些参数，具体代码如下： export default class WebSocketManager { constructor(url = null, userId = null, receiveMessageCallback = null) { this.socket = null // WebSocket 对象 this.pingTimeout = null // 心跳计时器 this.reconnectTimeout = 5000 // 重连间隔，单位：毫秒 this.maxReconnectAttempts = 10 // 最大重连尝试次数 this.reconnectAttempts = 0; // 当前重连尝试次数 this.id = userId //用户ID（业务逻辑，根据自己业务需求调整） this.url = url // WebSocket 连接地址 this.receiveMessageCallback = receiveMessageCallback // 接收消息回调函数 } } 初始化WebSocket对象 初始化完成后，我们先实现一个initialize方法，在这里我们要监测一下使用时候是否传入了webSocket连接的服务器地址、用户id等；如果没有问题，则连接WebSocket。 export default class WebSocketManager { constructor() { // ...省略 } /** * 初始化 */ async start() { if( this.url &amp;&amp; this.id){ // 连接WebSocket this.connectWebSocket() }else{ console.error('WebSocketManager erros: 请传入连接地址和用户id') } } } 创建WebSocket连接 初始化完成后，我们就开始来实现一下WebSocket连接，标准的WebSocket构造函数以url作为其第一个参数，第二个参数是可选的，这里根据服务端那边的约定去进行处理即可，这里要求传入用户id+一个随机值去生成唯一标识符。 export default class WebSocketManager { constructor() { // ...省略 } /** * 创建WebSocket连接 */ connectWebSocket() { // 通过id生成唯一值（服务端要求，具体根据自己业务去调整） let id = `${this.id}-${Math.random()}` // 创建 WebSocket 对象 this.socket = new WebSocket(this.url, id) // 处理连接打开事件 this.socket.addEventListener('open', event =&gt; { // 心跳机制 this.startHeartbeat() }) // 处理接收到消息事件 this.socket.addEventListener('message', event =&gt; { this.receiveMessage(event) }) // 处理连接关闭事件 this.socket.addEventListener('close', event =&gt; { // 清除定时器 clearTimeout(this.pingTimeout) clearTimeout(this.reconnectTimeout) // 尝试重连 if (this.reconnectAttempts &lt; this.maxReconnectAttempts) { this.reconnectAttempts++ this.reconnectTimeout = setTimeout(() =&gt; { this.connectWebSocket() }, this.reconnectTimeout) } else { // 重置重连次数 this.reconnectAttempts = 0 console.error('WebSocketManager erros: Max reconnect attempts reached. Unable to reconnect.') } }) // 处理 WebSocket 错误事件 this.socket.addEventListener('error', event =&gt; { console.error('WebSocketManager error:', event) }) } } 心跳机制 心跳机制主要用于检测客户端是否在线，如果客户端超过一定时间没有发送消息，服务端就会断开连接。所以我们需要每隔一段时间发送一个心跳消息，这样就可以避免长时间的连接断开。具体实现代码如下： export default class WebSocketManager { constructor() { // ...省略 } /** * 启动心跳机制 */ startHeartbeat() { this.pingTimeout = setInterval(() =&gt; { // 发送心跳消息 this.sendMessage('ping') }, 10000) // 每隔 10 秒发送一次心跳 } /** * 发送消息 * @param {String} message 消息内容 */ sendMessage(message) { if (this.socket.readyState === WebSocket.OPEN) { this.socket.send(message); } else { console.error('WebSocketManager error: WebSocket connection is not open. Unable to send message.') } } } 接收消息 这里我们只简单处理一下，接收到消息后，我们根据消息内容做不同的处理。 export default class WebSocketManager { constructor() { // ...省略 } /** * 接收到消息 */ receiveMessage(event) { // 根据业务自行处理 console.log('receiveMessage:', event.data) this.receiveMessageCallback &amp;&amp; receiveMessageCallback(event.data) } } 关闭连接 如果用户要退出登录，我们可以写一个方法来实现关闭连接，同时清除定时器以及当前重连尝试次数，具体代码如下： export default class WebSocketManager { constructor() { // ...省略 } /** * 关闭连接 */ closeWebSocket() { this.socket.close() // 清除定时器 重置重连次数 clearTimeout(this.pingTimeout) clearTimeout(this.reconnectTimeout) this.reconnectAttempts = 0 } } 使用方法 导入WebSocketManager后，我们就可以使用它了，如下所示： /** * 接收消息回调 */ const receiveMessage = (res)=&gt;{ console.log('接收消息回调：'res) } const socketManager = new WebSocketManager('ws://example.com/socket', 'userid292992', receiveMessage) socketManager.start() 总结 以上就是使用WebSocket的一个简单例子，具体实现根据业务需求进行调整即可。全部代码比较多，就不在这里展示了，需要的可以到GitHub下载。 往期推荐文章📚 🏷️小程序网络监控大揭秘：如何实时监听网络变化 🏷️&quot;5.25秒变0.023秒：小程序图片优化全攻略&quot; 🏷️如何封装优雅、高效的uni-app请求：让开发更轻松 🏷️uni-app开发小程序：项目架构以及经验分享 🏷️小程序TabBar创意动画(文末附完整源代码) 本文首发于陇锦的个人博客，转载请注明出处！ ","link":"https://lonjinup.github.io/WebSocketManager/"},{"title":"小程序网络监控大揭秘：如何实时监听网络变化","content":"小程序网络监控大揭秘：如何实现实时监听网络变化 前几天写了一篇&quot;5.25秒变0.023秒：小程序图片优化全攻略&quot; ；介绍了一些小程序图片优化技巧，在文章中提到我们可以借助当前用户的网络状态去加载对应分辨率的图片。下面我们就实现一下这个功能。 需求分析 首先我们需要去写一个下载方法，通过下载来计算请求耗时，然后通过所需耗时来判断网络状态，如果网络状态不好，则进行几次重试，看看是否有更好的网络状态。同时我们还需要使用wx.onNetworkStatusChange这个api来监听网络状态的变化；该api会在用户网络切换时候触发，一旦触发，我们需要重新执行下载方法来判断当前的网络状态。 功能实现 我这里demo使用uni-app开发，所以有些api可能是uni.开头，如果你使用小程序原生开发，换成wx.即可。 新建/utils/networkManager.js，我们先定义一些基本的参数： class NetworkManager { constructor() { // 最大重试次数 this.MAX_RETRY_COUNT = 3 // 当前重试次数 this.retryCount = 0 // 当前网络状态 this.currentNetworkStatus = '' // 网络状态改变回调 this.statusChangeCallback = null // 图片地址 this.url = '' } } 然后我们去添加两个函数，用来设置图片地址和网络状态改变的回调函数： class NetworkManager { constructor() { // ...省略 } /** * 设置网络状态变化的回调函数 * @param {*} callback */ setChangeCallback(callback) { this.statusChangeCallback = callback } // 设置请求的url setRequestUrl(url) { this.url = url } } 如何判断当前网络到底好不好呢？我们可以通过uni.downloadFile来下载一张1M-2M大小的图片，通过下载时间来判断网络情况。当请求耗时在1000ms以内，则认为网络极好，如果介于1000-1500ms之间，则认为网络好，如果大于1500ms，则认为网络差。如果网络非常差的时候，我们需要多请求几次，来持续判断网络是否有好转，如果超过我们定义的最大重试次数就停止请求。 class NetworkManager { constructor() { // ...省略 } // 请求方法 request() { return new Promise((resolve, reject) =&gt; { // 记录当前时间 const startTime = Date.now() uni.downloadFile({ url: `${this.url}?timer=${startTime}`, success: (res) =&gt; { // 记录结束时间 const endTime = Date.now() // 时间差 const duration = endTime - startTime // 判断网络情况 this.checkNetworkStatus(duration) resolve(res) }, fail: (res) =&gt; { // 进行重试 this.retryCount++ if (this.retryCount &lt; this.MAX_RETRY_COUNT) { this.request() } else { console.log('网络状态不佳，已停止') // 重试次数归零 this.retryCount = 0 reject(res) } }, }) }) } /** * 判断网络状态 * @param {*} duration 请求耗时ms */ checkNetworkStatus(duration) { const previousStatus = this.currentNetworkStatus if (duration &lt; 1000) { this.currentNetworkStatus = 'veryGood' } else if (duration &gt;= 1000 &amp;&amp; duration &lt;= 1500) { this.currentNetworkStatus = 'good' } else { this.currentNetworkStatus = 'poor' // 请求失败，开始判断 if (this.retryCount &lt; this.MAX_RETRY_COUNT) { this.retryCount++ this.request() } else { // 达到最大重试次数，停止递归 this.retryCount = 0 console.log('网络状态不佳，已停止') } } // 判断网络状态是否发生变化,如果有变化，就通知回调函数 if (previousStatus !== this.currentNetworkStatus &amp;&amp; this.statusChangeCallback) { this.statusChangeCallback(this.currentNetworkStatus) } } } 最后我们还需要写一个开启函数，用来启动网络监听，同时使用uni.onNetworkStatusChange来监听用户网络环境变化，如果有变化则进行一次请求。 class NetworkManager { constructor() { // ...省略 } /** * 开启监听 * @returns */ start() { if (!this.url) { console.error('请设置请求的url') return } // 执行请求 this.request() // 网络环境变换后，重新请求 uni.onNetworkStatusChange(() =&gt; { this.request() }) } } 使用方式 我们来看一下最终的使用方式： // 使用示例 const networkManager = new NetworkManager() // 设置请求的url networkManager.setRequestUrl('https://lonjin.oss-cn-beijing.aliyuncs.com/weixin-test/wallhaven-o5g125.jpeg') // 设置网络状态变化的回调函数 networkManager.setChangeCallback((newStatus) =&gt; { // 这里可以把结果存到全局变量中，在其他页面方便使用 console.log('网络状态变化:', newStatus) }) // 启动 networkManager.start() 总结 我们通过uni.downloadFile来下载一张图片，通过下载时间来判断网络情况，然后通过uni.onNetworkStatusChange监听网络环境变化，当网络环境变化时，重新请求；从而去根据网络状态去请求不同大小的资源文件，减少白屏时间，提升用户体验。 往期推荐文章📚： 🏷️&quot;5.25秒变0.023秒：小程序图片优化全攻略&quot; 🏷️如何封装优雅、高效的uni-app请求：让开发更轻松 🏷️uni-app开发小程序：项目架构以及经验分享 🏷️小程序TabBar创意动画(文末附完整源代码) ","link":"https://lonjinup.github.io/weixin-onNetworkStatusChange/"},{"title":"\"5.25秒变0.023秒：小程序图片优化全攻略\"","content":"&quot;5.25秒变0.023秒：小程序图片优化全攻略&quot; 最近在公司在写微信小程序，该小程序主要展示一些高清图片，所以图片数量非常多，而且图片尺寸也比较大，导致小程序的加载时间非常长。所以这里记录一下如何减少小程序图片的加载时间。 优化前 这里我挑选了一些项目里面比较大的图片，还有我之前保存的一些背景图，共计12张，上传到阿里云oss，然后写了一个demo去渲染图片，这里我们先看看加载时间。 可以看到，一旦文件大小到了1M以上，加载基本都在1秒以上了，而且加载最慢的一张图片大小为2.4M；加载耗时5.27秒。然而在这个小程序中，有非常多的瀑布流图片展示，需要加载的图片也非常多，这对于这种图片展示类的小程序来说，简直是非常糟糕的体验。下面我们就分析一下，如何提升用户体验，缩短加载时间。 分析优化 这里我总结了一些常见图片优化策略，方法如下： 下面我们就根据总结的优化策略进行优化，具体如下： 优化1：使用webp格式的图片 首先我们知道，在小程序中是支持webp格式的图片的，所以我们可以将图片转换为webp格式，这样可以减少图片体积，提升加载速度。 公司使用的阿里云oss进行图片存储，阿里云oss是支持格式转换的，只需要在图片url后面加一定的参数即可，我们可以给图片后面加上?x-oss-process=image/format,webp即可。 // 原本图片路径： let url =' https://lonjin.oss-cn-beijing.aliyuncs.com/weixin-test/3%20%282%2917047050403470042.png' // 转化为webp格式的图片路径： let url =' https://lonjin.oss-cn-beijing.aliyuncs.com/weixin-test/3%20%282%2917047050403470042.png?x-oss-process=image/format,webp' 清除缓存，刷新页面，再来看加载时间： 可以看到，加载时间大幅缩短，图片格式转化后，图片大小已经非常小了，最大的一张图片仅仅有730kb；随之加载时间也大幅缩短，最慢的一张图片从之前的5.27秒缩短为1.71秒，加载速度提升了3倍！其他的图片加载基本都在500ms左右，加载速度提升也是比较明显。 这里我们还需要注意一下webp图片格式的支持范围，我这里使用的uni-app做为demo，查了一下文档，支持范围如下： Android4以上（含）、iOS14以上（含）系统内置支持webp，此时，不管web、小程序、app，也不管vue/nvue/uvue都可以直接使用webp； iOS14以下，app-vue下，iOS不支持；app-nvue/uvue下，iOS支持；微信小程序2.9.0起，配置属性webp为true时iOS支持； 所以如果考虑一些特殊情况，我们可以进行一些特殊情况下的处理。 如果文件是直接放在服务器上的，我们可以借助一些第三方工具来把图片批量转化为webp格式；比如convertio.co 优化2：根据需求设置适当的分辨率 阿里云oss支持在图片后面加上参数来设置图片的分辨率，我这里写的demo中，image标签图片宽度均为小程序图片默认宽度；即为width: 320px;，所以我们可以给图片url后面加上/resize,w_320即可，其中w_320表示图片宽度为320px。 // 原本图片路径： let url =' https://lonjin.oss-cn-beijing.aliyuncs.com/weixin-test/3%20%282%2917047050403470042.png?x-oss-process=image/format,webp' // 设置宽度后的图片路径： let url =' https://lonjin.oss-cn-beijing.aliyuncs.com/weixin-test/3%20%282%2917047050403470042.png?x-oss-process=image/format,webp/resize,w_320' 清除缓存，刷新页面，再来看加载时间： 图片大小大幅度减少，最大的一张图片仅仅有15.4 kB；随之加载时间也大幅缩短，最慢的一张图片从之前的1.71秒缩短为316毫秒，加载速度提升了5倍！这时候所有图片的加载速度全部没有超过1秒，最大不超过350ms；基本上算是质的飞跃了。不过需要注意的是，图片分辨率还是需要结合业务需求进行调整的，如果要求必须高清，不建议设置太小的分辨率。不过我们可以写一个检测用户网络状态的方法，在不同的网络环境下加载不同分辨率的图片；后面我会专门来写一篇文章来实现这个功能。 优化3：使用雪碧图 雪碧图，也叫Sprite，是将多个小图片合并成一张大图，然后在页面中使用background-image和background-position属性来显示其中的某一张图片。这样可以减少图片的加载次数，减少图片的大小，同时减少图片的加载时间。在项目中难免会有很多小图标，我们就可以使用雪碧图的方式来使用，减少请求次数。这里我就不做展示了。 优化4：合理使用占位图片 通常情况下，为了内容的动态展示，需要通过网络请求从接口中获取图片的url。如果在网络慢的情况下，image加载图片的过程可能会非常慢，在请求完成之前页面都会因为没有数据而呈现一片空白，这是非常差的用户体验，这里我们可以借助小程序image标签上的@error 和@load事件来实现占位图片的展示。我们可以根据需求去封装一个LoadImage组件统一处理，上面提到的优化1、优化2也可以通过定义参数实现批量添加，同时我们也可以给组件加上lazyLoad，减轻小程序加载压力。 组件具体代码如下： &lt;template&gt; &lt;view class=&quot;loadImage-wrapper&quot;&gt; &lt;image v-if=&quot;isLoading&quot; :src=&quot;defaultImage&quot; :mode=&quot;mode&quot; :lazy-load=&quot;lazyLoad&quot; /&gt; &lt;image :class=&quot;[isLoading ? 'before-load' : '']&quot; :src=&quot;imageUrl&quot; :mode=&quot;mode&quot; :lazy-load=&quot;lazyLoad&quot; @load=&quot;imageLoad&quot; /&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props: { /** * 占位图 * @default /static/images/load-image.png */ defaultImage: { type: String, default: '/static/load-image.png', }, /** * 是否使用webp * @default false */ useWebp: { type: Boolean, default: false, }, /** * 图片的显示模式 * @default scaleToFill */ mode: { type: String, default: 'scaleToFill', }, /** * 图片加载分辨率-宽度 * @default */ width: { type: String, default: '', }, /** * 是否懒加载 * @default true */ lazyLoad: { type: Boolean, default: true, }, /** * 图片地址 * @default */ src: { type: String, default: '', }, }, data() { return { isLoading: true, } }, methods: { imageLoad() { this.isLoading = false }, }, computed: { imageUrl() { let url = this.src + '?' this.useWebp &amp;&amp; (url += 'x-oss-process=image/format,webp') this.width &amp;&amp; (url += '/resize,w_' + this.width) return url } }, } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt; .loadImage-wrapper { .before-load { width: 0; height: 0; opacity: 0; } } &lt;/style&gt; 使用方式如下： &lt;template&gt; &lt;view class=&quot;list&quot;&gt; &lt;load-image v-for=&quot;(item, index) in list&quot; :src=&quot;item&quot; :lazyLoad=&quot;false&quot; useWebp :width=&quot;320&quot; :key=&quot;index&quot; /&gt; &lt;/view&gt; &lt;/template&gt; 优化后效果对比 我们再来看一下优化前后的加载时间对比： 优化前： 优化后： 我们用一张图片来做对比： 图片名称 大小 加载时间 优化前 wallhaven-we3z86.jpeg 2.4MB 5.27s 优化后 wallhaven-we3z86.jpeg 15.3KB 23ms 可以看到相对体积而言，缩小了99.4%；相对加载时间，缩短了5.25秒，在几乎不影响图片质量的情况下，极大的提升了用户体验。 总结 关于小程序的图片优化，我们可以根据业务需求以及技术支持来选择不同的方案，这里我只列出了几个最常用的方案，如果业务需求比较复杂，可以多尝试一些方案。 往期文章 5分钟get：Uni-App网络请求完美封装指南！ uni-app开发小程序：项目架构以及经验分享 小程序TabBar创意动画(文末附完整源代码) 本文首发于lonjin个人博客，转载请注明出处！ ","link":"https://lonjinup.github.io/weixn-image-time/"},{"title":"node项目实战-01实现注册登录","content":"node项目实战-01实现注册登录 1.项目准备 前面我们已经搭建了一个基础的项目模版，现在我们就用这个项目模版来做一个简单的项目。首先我们安装mongoose模块： npm install mongoose --save mongoose是MongoDB的Node.js驱动程序，它为我们提供了一种在Node.js中使用MongoDB的简单方法。后面我们会详细介绍他的使用方法。 注册接口 我们先来实现一个注册接口，这个接口接收一个参数username、email、password、phone，然后将这个参数保存到数据库中。 首先我们分别创建关于用户功能的router和controller；新建/router/user.js和/controller/userController.js： /router/user.js内容如下： const express = require('express') const router = express.Router() const userController = require('../controller/userController') router .post('/register', userController.register) module.exports = router /controller/userController.js内容如下，顺便打印一下我们接受到参数： exports.register = async (req, res) =&gt; { console.log(req.body) } 然后我们在/router/index.js中引入这个路由： const express = require('express') const router = express.Router() const user = require('./user') router.use('/user', user) module.exports = router 运行项目： npm run dev 当我们使用Postman或者apifox访问http://localhost:3000/user/register并传入参数，控制台就会打印我们传入的参数： { &quot;username&quot;: &quot;test&quot;, &quot;email&quot;: &quot;test@test.com&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;phone&quot;: &quot;12345678901&quot; } 拿到参数以后我们需要把这些数据存入到数据库中，这时候就需要用到开头提到的mongoose进行处理。 使用mongoose存储数据 首先新建/model/index.js，引入mongoose，同时进行连接数据库的操作： const mongoose = require('mongoose') async function main() { await mongoose.connect('mongodb://localhost:27017/nodeDemo') } main().then(res =&gt; { console.log('mongo连接成功') }).catch(error =&gt; { console.log('mongo连接失败', error) }) 然后我们在当前文件夹中再建立一个userModel.js文件，在这个文件中定义一个userSchema，最后导出 const mongoose = require('mongoose') const userSchema = new mongoose.Schema({ username: { type: String, //数据类型 required: true, //数据是否必须 trim: true, //去除两边空格 minlength: 4, //最小长度 maxlength: 18, //最大长度 validate: { validator: function (v) { return /^[a-zA-Z0-9_-]{4,18}$/.test(v) }, message: '{VALUE}不是一个合法的用户名' } }, email: { type: String, required: true, trim: true, validate: { validator: function (v) { return /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/.test(v) }, message: '{VALUE}不是一个合法的邮箱' } }, password: { type: String, required: true, }, phone: { type: String, required: true, unique: true, trim: true, validate: { validator: function (v) { return /^1[34578]\\d{9}$/.test(v) }, message: '{VALUE}不是一个合法的手机号' } }, avatar: { type: String, default: null }, createTime: { type: Date, default: Date.now }, updateTime: { type: Date, default: Date.now } }) module.exports = userSchema 关于mongoose.Schema的详细使用方法可以参考mongoose文档。 导出之后，我们还是要在/model/index.js中进行集中的导出，到时候我们就可以在其他地方进行导入使用了，最终的/model/index.js内容如下： const mongoose = require('mongoose') async function main() { await mongoose.connect('mongodb://localhost:27017/nodeDemo') } main().then(res =&gt; { console.log('mongo连接成功') }).catch(error =&gt; { console.log('mongo连接失败', error) }) //导出模块 module.exports = { User: mongoose.model('User', require('./userModel')) } 再回到刚才的/controller/userController.js中，我们需要进行修改，将register方法中的console.log(req.body)改为： const { User } = require('../model/index') exports.register = async (req, res) =&gt; { console.log(req.body) const userModel = new User(req.body) const dbBack = await userModel.save() res.status(201).json(dbBack) } 这样一来，当我们使用Postman或者apifox访问http://localhost:3000/user/register并传入参数，控制台就会打印我们传入的参数，并且将这些参数保存到数据库中。 密码加密 在上面的代码中，我们将密码明文存入了数据库中，这样显然是不安全的，我们需要对密码进行加密处理。这里我们使用crypto中的createHash函数对密码进行加密，然后将加密后的密码存入数据库中。 新建util/md5.js；并引入crypto： const crypto = require('crypto') /** * md5加密 * @param str * @returns {string} */ module.exports = str =&gt; crypto.createHash('md5').update('lonjin' + str).digest('hex') crypto.createHash('md5'): 创建一个用于 MD5 散列的 Hash 对象。md5 表示采用 MD5 算法。 .update('lonjin' + str): 使用给定的数据进行更新，这里的数据是 'lonjin' + str，即将字符串 'lonjin' 与参数 str 连接后的结果，这样可避免被撞库的风险。 .digest('hex'): 返回 Hash 对象的二进制数据的十六进制表示。这就是最终的 MD5 散列值。 然而，请注意，MD5 不再被推荐用于安全目的，因为它已经被发现存在一些弱点。在密码存储或其他需要高度安全性的场景中，更推荐使用更强大的散列算法，比如 SHA-256，并且结合一些附加的安全措施，例如加盐（salting）和适当的迭代次数（iteration）。具体方式如下： const crypto = require('crypto'); function sha256Hash(str) { const hash = crypto.createHash('sha256') const hashedStr = hash.update('lonjin' + str).digest('hex') return hashedStr } module.exports = sha256Hash 处理公共字段 在上面的userSchema.js中，我们定义了一些公共字段，比如createTime和updateTime，在很多场景下我们可能都需要这两个字段，所以我们将这两个字段也抽离出来。 新建：/model/baseModel.js: module.exports = { createTime: { type: Date, default: Date.now }, updateTime: { type: Date, default: Date.now } } 然后在/model/userModel.js中引入并使用： const baseModel = require('./baseModel') const userSchema = new mongoose.Schema({ //...原有逻辑 avatar: { type: String, default: null }, ...baseModel }) 数据验证 express-validator是一个非常好用的表单验证中间件，它可以帮助我们在表单提交的时候进行数据验证，从而避免了前端的一些常见的错误。 首先我们需要安装express-validator： npm install express-validator --save 还是已我们上面提到的注册接口为例子；首先我们封装一下验证规则： 新建middleware/validator/userValidator.js，用来处理用户相关的验证规则，同时我们再建立一个文件夹，去统一处理错误逻辑；新建middleware/validator/errorBack.js。 middleware/validator/userValidator.js内容如下： const { body } = require('express-validator') const validator = require('./errorBack') module.exports.register = validator( [ body('username') .notEmpty().withMessage('用户名不能为空').bail() .isLength({ min: 3, max: 10 }).withMessage('用户名长度必须在3-10之间'), body('email') .notEmpty().withMessage('邮箱不能为空').bail() .isEmail().withMessage('邮箱格式不正确'), body('password') .notEmpty().withMessage('密码不能为空').bail() .isLength({ min: 6, max: 16 }).withMessage('密码长度必须在6-16之间') ] ) middleware/validator/errorBack.js文件内容如下： const { validationResult } = require('express-validator') module.exports = validator =&gt; { return async (req, res, next) =&gt; { await Promise.all(validator.map(i =&gt; i.run(req))) //获取错误信息 const errors = validationResult(req) if (!errors.isEmpty()) { // 处理错误信息 return res.status(401).json({ error: errors.array() }) } next() } } 下面是一些在 express-validator 中常用的验证规则，以及它们的简要说明： 验证器 描述 .notEmpty() 检查字段是否为空。 .isLength({ min, max }) 检查字段的字符长度是否在指定的范围内。 .isEmail() 检查字段是否是有效的电子邮件地址。 .isURL() 检查字段是否是有效的URL。 .isInt() 检查字段是否为整数。 .isNumeric() 检查字段是否为数字。 .isFloat() 检查字段是否为浮点数。 .isDate() 检查字段是否为有效的日期。 .isBoolean() 检查字段是否为布尔值。 .isIn(values) 检查字段值是否在指定的数组中。 .isNotIn(values) 检查字段值是否不在指定的数组中。 .equals(value) 检查字段值是否与指定的值相等。 .not() 反转前面的验证条件。如果之前的验证条件为真，将变为假，反之亦然。 .custom(validatorFunction) 使用自定义验证函数进行验证。 .withMessage(message) 在验证失败时设置错误消息。 .bail() 在验证失败时停止执行后续验证链。 这些是一些常见的验证规则，我们可以根据具体的需求组合它们，构建强大而灵活的验证规则链。 接下来我们在/controller/userController.js中引入验证器并使用： const express = require('express') const router = express.Router() const userController = require('../controller/userController') //引入验证器 const validator = require('../middleware/validator/userValidator') // 使用validator中间件 router .post('/register', validator.register, userController.register) module.exports = router 这样在用户注册的时候，就能对用户提交的数据进行验证，从而避免了前端的一些常见的错误。 这时候我们使用apifox发起注册请求，不传任何参数，就会返回错误信息： { &quot;error&quot;: [ { &quot;type&quot;: &quot;field&quot;, &quot;value&quot;: &quot;&quot;, &quot;msg&quot;: &quot;用户名不能为空&quot;, &quot;path&quot;: &quot;username&quot;, &quot;location&quot;: &quot;body&quot; }, { &quot;type&quot;: &quot;field&quot;, &quot;msg&quot;: &quot;邮箱不能为空&quot;, &quot;path&quot;: &quot;email&quot;, &quot;location&quot;: &quot;body&quot; }, { &quot;type&quot;: &quot;field&quot;, &quot;msg&quot;: &quot;密码不能为空&quot;, &quot;path&quot;: &quot;password&quot;, &quot;location&quot;: &quot;body&quot; } ] } 数据唯一性验证 在上面的例子中，我们做了对参数的一些验证，但是还是缺少一个对数据唯一性的验证。比如注册时候我们可能要求手机号和邮箱必须是唯一的。我们这里还是借助express-validator的自定义验证函数custom来实现；当然我们需要连接到数据库进行数据查找。 首先我们在middleware/validator/userValidator.js中添加一个自定义验证函数： const { body } = require('express-validator') const validator = require('./errorBack') // 1.引入User model const { User } = require('../../model/index') module.exports.register = validator( [ body('username') .notEmpty().withMessage('用户名不能为空').bail() .isLength({ min: 3, max: 10 }).withMessage('用户名长度必须在3-10之间'), body('email') .notEmpty().withMessage('邮箱不能为空').bail() .isEmail().withMessage('邮箱格式不正确') .custom(async val =&gt; { // 2.查询数据库 const emailValidator = await User.findOne({ email: val }) // 3.判断是否存在 if (emailValidator) { return Promise.reject('邮箱已被注册') } }).bail(), body('password') .notEmpty().withMessage('密码不能为空').bail() .isLength({ min: 6, max: 16 }).withMessage('密码长度必须在6-16之间'), body('phone') .notEmpty().withMessage('手机号不能为空').bail() .isLength({ min: 11 }).withMessage('手机号格式不正确') .custom(async val =&gt; { // 同理 const phonelValidator = await User.findOne({ phone: val }) if (phonelValidator) { return Promise.reject('手机号已被注册') } }).bail(), ] ) Restful接口规范 在项目中，我们需要对接口进行规范，比如接口的路径，请求方式，参数，返回值等。这里我们可以参考restfulapi接口规范；当然我们可以根据一些业务需求做对应的调整。 ","link":"https://lonjinup.github.io/node-demo-01/"},{"title":"【node学习-07】搭建express项目模版","content":"搭建express项目模版 下面我们将一步步搭建一个基本的Express项目模板。这个模板包括项目结构、初始化、安装必要的依赖、创建主文件app.js、设置路由和控制器。最后，你可以根据项目需求进行修改和优化。 1. 项目结构 ├── app.js ├── config │ ├── config.default.js ├── controllers │ ├── testController.js ├── package.json ├── router │ ├── index.js │ ├── test.js 2. 项目初始化 npm init -y 3. 安装 npm install express // express框架 npm install cors // 跨域 npm install morgan // 日志 npm install nodemon // 重启服务 4. 创建app.js文件 const express = require('express') const app = express() const cors = require('cors') const morgan = require('morgan') // 数据格式解析 app.use(express.json()) app.use(express.urlencoded()) // 跨域 app.use(cors()) //日志记录 app.use(morgan('dev')) const PORT = process.env.PORT || 3000 app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 5.路由&amp;&amp;控制器 新建/controllers/testController.js文件，并编写一个测试方法： exports.testGet = async (req, res) =&gt; { console.log(req.method) res.send('testGet success') } exports.testPost = async (req, res) =&gt; { console.log(req.method) res.send('testPost success') } 新建一个测试路由：/router/test.js，并导入控制器： const express = require('express') const router = express.Router() const testController = require('../controller/testController') router .get('/testGet', testController.testGet) .post('/testPost', testController.testPost) module.exports = router 新建一个主路由：/router/index.js，并导入测试路由： const express = require('express') const router = express.Router() const test = require('./test') router.use(test) module.exports = router 在app.js中导入主路由： const express = require('express') const app = express() const cors = require('cors') const morgan = require('morgan') // 导入主路由 const router = require('./router') app.use(express.json()) app.use(express.urlencoded()) app.use(cors()) app.use(morgan('dev')) // 路由 app.use('/api/v1', router) const PORT = process.env.PORT || 3000 app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 最基本的一个项目模版就搭建完毕了，后续可以根据项目需求进行修改和优化。 ","link":"https://lonjinup.github.io/express-07-template/"},{"title":"【node学习-06】express进阶","content":"express中间件 在Express中，中间件是一个功能强大的概念，它允许你在请求被处理之前或之后执行代码。中间件函数可以访问请求对象 (req)、响应对象 (res)，以及应用中的下一个中间件函数 (next)。 假如我想在Express项目的每一次请求中，添加一个打印日志的功能，如果在所有的请求中console打印肯定不现实，不如抽出一个logs方法，然后在每次请求时候去调用： const express = require('express') const app = express() const PORT = process.env.PORT || 3000 function logs(req, res) { console.log(`${req.method},${req.url}, ${new Date().toLocaleString()}`) } app.get('/', (req, res) =&gt; { logs(req, res) res.send('Hello World') }) app.get('/login', (req, res) =&gt; { logs(req, res) res.send('login') }) app.get('/register', (req, res) =&gt; { logs(req, res) res.send('register') }) app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 但是这样的方式还是有些不方便；需要在每次请求中都去调用logs方法，不仅不方便，而且还会有很多重复的代码。 所以，我们可以把logs方法作为一个中间件，然后在app.use()中使用它： const express = require('express') const app = express() const PORT = process.env.PORT || 3000 function logs(req, res, next) { console.log(`${req.method},${req.url}, ${new Date().toLocaleString()}`) // 下一步操作 next() } app.use(logs) app.get('/', (req, res) =&gt; { res.send('Hello World') }) app.get('/login', (req, res) =&gt; { res.send('login') }) app.get('/register', (req, res) =&gt; { res.send('register') }) app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 在 Express 中，中间件可以写在 app.get 方法之前、之后或之间，具体取决于中间件的作用和你希望它在请求处理过程中的执行顺序。 中间件分类 在 Express 框架中，中间件（Middleware）是一个函数，在请求被发送到路由处理程序之前，可以对请求进行预处理、处理请求、或者对响应进行后处理。Express 中间件可以分为以下几种类型： 应用级中间件：应用级中间件绑定到 Express 的应用实例（app 对象）上，它们通过 app.use() 方法使用。这种中间件能够处理应用中的所有请求，对请求和响应进行修改，执行一些公共任务，比如日志记录、身份验证等。 路由级中间件：路由级中间件与应用级中间件类似，但它绑定到特定的路由上，只能处理特定路由的请求。通过 app.use() 或者 router.use() 方法使用，它能够为特定路由的请求执行特定的任务，比如验证用户权限、数据验证等。 错误处理中间件：错误处理中间件专门用于处理请求过程中发生的错误。当一个中间件通过 next(err) 方法传递错误时，错误处理中间件将被调用。它接收四个参数（err, req, res, next），并负责处理错误、生成错误响应以及记录错误日志等操作。 内置中间件：Express 框架内置了一些常用的中间件，比如 express.static（用于提供静态文件服务）、express.json（用于解析 JSON 请求体）、express.urlencoded（用于解析 URL 编码的请求体）等。这些内置中间件可以通过简单的配置来使用，提供了一些基本的功能，可以快速开发 Web 应用。 第三方中间件：除了内置中间件之外，Express 还支持第三方中间件，开发者可以通过 npm 安装并使用第三方中间件来扩展 Express 的功能。第三方中间件可以实现各种功能，比如身份验证、日志记录、性能监控等，丰富了 Express 生态系统，为开发者提供了更多选择。 应用级中间件 在 Express 中，应用级中间件直接与 Express 应用的实例相关，对整个应用生效。它们通常通过 app.use 或者对特定的路由使用 app.METHOD（例如 app.get）来注册。以下是一个简单的例子： const express = require('express'); const app = express(); const PORT = process.env.PORT || 3000; // 应用级中间件 app.use((req, res, next) =&gt; { console.log('This middleware is executed for every request to the app.'); next(); // 调用 next() 将控制权传递给下一个中间件或路由处理程序 }); app.get('/user', (req, res, next) =&gt; { console.log('Handling user request...'); next(); }, (req, res) =&gt; { res.send('User route response'); }); app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`); }); 在这个例子中，app.use 注册了一个应用级中间件，它在每个请求到达应用时都会执行。对于 /user 路由，我们通过 app.get 注册了两个中间件，其中第一个中间件在 /user 请求前执行，记录了请求的处理过程。 应用级中间件可以用于执行一些全局的任务，比如记录日志、身份验证、处理请求等。由于它们在整个应用范围内生效，因此适用于需要在每个请求中执行的任务。 路由级中间件 在 Express 中，路由级中间件是与特定路由或路由组相关的中间件。它们通过 express.Router 创建，并通过 app.use 或者 app.METHOD（例如 app.get）来注册。以下是一个简单的应用： 新建/router/index.js和/router/video.js文件，内容如下： /router/index.js: const express = require('express') const router = express.Router() router.get('/user', (req, res) =&gt; { console.log(req.method) res.send('success') }) router.get('/login', (req, res) =&gt; { console.log(req.method) res.send('login success') }) module.exports = router /router/video.js: const express = require('express') const router = express.Router() router.get('/list', (req, res) =&gt; { console.log(req.method) res.send('list success') }) router.get('/detail', (req, res) =&gt; { console.log(req.method) res.send('detail success') }) module.exports = router 然后在app.js中引入并注册，同时注册时候给他们前面分别添加两个前缀/api和/video: const express = require('express') const router = require('./router/index') const videoRouter = require('./router/video') const app = express() app.use('/api', router) app.use('/video', videoRouter) const PORT = process.env.PORT || 3000 app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 错误处理中间件 在 Express 中，错误处理中间件是指处理错误的中间件，它可以处理请求和响应，并对它们进行修改。 错误处理中间件可以捕获应用中的错误，并将其发送给客户端。以下是一个简单的例子： const express = require('express') const router = require('./router/index') const videoRouter = require('./router/video') const app = express() app.use('/api', router) app.use('/video', videoRouter) //捕获路由错误 app.use((req, res, next) =&gt; { res.status(404).send({ message: 'Not Found' }) }) //捕获错误 app.use((err, req, res, next) =&gt; { res.status(500).send({ message: 'server error' }) }) const PORT = process.env.PORT || 3000 app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 内置中间件 Express 内置的中间 件主要用于处理常见的任务，如解析请求体、处理静态文件等。以下是一些常见的 Express 内置中间件： 1. express.json() 用于解析传入请求的 JSON 数据，并将其放置在 req.body 中。 const express = require('express'); const app = express(); app.use(express.json()); app.post('/api/data', (req, res) =&gt; { console.log(req.body); // 访问 JSON 数据 res.send('Data received successfully.'); }); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); 2. express.urlencoded() 用于解析传入请求的 URL 编码数据（通常来自表单），并将其放置在 req.body 中。 const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.post('/api/form', (req, res) =&gt; { console.log(req.body); // 访问表单数据 res.send('Form data received successfully.'); }); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); 3. express.static() 用于提供静态文件，例如 HTML、CSS、JavaScript 等。 const express = require('express'); const app = express(); app.use(express.static('public')); app.get('/', (req, res) =&gt; { res.sendFile(__dirname + '/public/index.html'); }); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); 4. express.Router() 虽然不是直接中间件，但用于创建模块化、可挂载的路由处理程序。 // 在 router.js 文件中 const express = require('express'); const router = express.Router(); router.get('/', (req, res) =&gt; { res.send('Router response'); }); module.exports = router; // 在主应用中 const express = require('express'); const app = express(); const router = require('./router'); app.use('/api', router); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); 这些内置中间件使得 Express 应用更易于开发，并提供了一些基本的功能，可以通过简单的配置即可使用。 第三方中间件 Express 社区提供了许多第三方中间件，这些中间件可以用于增强 Express 应用的功能。以下是一些常用的第三方中间件： body-parser 用于解析请求体，支持 JSON、URL 编码和多部分数据。 npm install body-parser 使用方法： const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: true })); app.post('/api/data', (req, res) =&gt; { console.log(req.body); // 访问 JSON 或 URL 编码数据 res.send('Data received successfully.'); }); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); helmet 提供了一系列 HTTP 头的设置，帮助提高 Express 应用的安全性。 npm install helmet 使用方法： const express = require('express'); const helmet = require('helmet'); const app = express(); app.use(helmet()); app.get('/', (req, res) =&gt; { res.send('Hello, World!'); }); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); compression 用于压缩响应体，减小传输数据的大小。 npm install compression 使用方法： const express = require('express'); const compression = require('compression'); const app = express(); app.use(compression()); app.get('/', (req, res) =&gt; { res.send('Compressed response.'); }); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); morgan 用于记录 HTTP 请求的日志。 npm install morgan 使用方法： const express = require('express'); const morgan = require('morgan'); const app = express(); app.use(morgan('combined')); app.get('/', (req, res) =&gt; { res.send('Hello, World!'); }); app.listen(3000, () =&gt; { console.log('Server is running on port 3000'); }); 这只是一小部分可用的第三方中间件。根据应用需求，你可以选择并安装适合的中间件来增强 Express 应用的功能。 Express路由 all方法用于匹配所有 HTTP 动词（GET、POST、PUT、DELETE 和 OPTIONS）。 const express = require('express') const app = express() const PORT = process.env.PORT || 3000 app.all('/*', (req, res) =&gt; { res.send('all') }) app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 路由路径 路由路径也可以是字符串模式。可用部分正则表达式语法来定义端点的模式。以下是所涉及的正则表达式（注意，连字符（ -）和点（.）在字符串路径中解释为字面量，不能做为正则表达式） 路径中?用于匹配路径中包含一个或多个字符的路径。 const express = require('express') const app = express() app.get('/us?er', (req, res) =&gt; { res.send(`${req.url}`) }) const PORT = process.env.PORT || 3000 app.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`) }) 请求下面接口都可以请求通： http://localhost:3000/uer http://localhost:3000/user 路径中+用于匹配路径中包含多个字符的路径。 const express = require('express') const app = express() app.get('/us+er', (req, res) =&gt; { res.send(`${req.url}`) }) const PORT = process.env.PORT || 3000 app.listen() 只要请求下面的路径都可以请求通 http://localhost:3000/user http://localhost:3000/ussser http://localhost:3000/usssser 路径中*可以替换为任意字符串 const express = require('express') const app = express() app.get('/us+er', (req, res) =&gt; { res.send(`${req.url}`) }) const PORT = process.env.PORT || 3000 app.listen() 只要请求下面的路径都可以请求通 http://localhost:3000/ussssser http://localhost:3000/usABCer 路由参数 路由参数是指在路径中使用冒号（:）来定义的部分。 const express = require('express') const app = express() app.get('/user/:id', (req, res) =&gt; { console.log(req.params) res.send(`${req.url}`) }) const PORT = process.env.PORT || 3000 app.listen() 请求下面接口都可以请求通： http://localhost:3000/user/123 // 输出 { id: '123' } http://localhost:3000/user/abc // 输出 { id: 'abc' } 也可以设置多个路由参数 const express = require('express') const app = express() app.get('/user/:id/:name', (req, res) =&gt; { console.log(req.params) res.send(`${req.url}`) }) const PORT = process.env.PORT || 3000 app.listen() 请求下面接口都可以请求通： http://localhost:3000/user/123/abc // 输出 { id: '123', name: 'abc' } http://localhost:3000/user/abc/123 // 输出 { id: 'abc', name: '123' } 链式路由 链式路由是指在一个路由中定义另一个路由，并在该路由中定义其它的路由。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.send(`${req.url}`) }).post('/login', (req, res) =&gt; { res.send(`${req.url}`) }) const PORT = process.env.PORT || 3000 app.listen() 响应方法 响应方法用于向客户端发送响应，同时也支持链式调用。 res.send()方法用于发送字符串。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.send('Hello, World!') }) const PORT = process.env.PORT || 3000 app.listen() res.download()方法用于下载文件。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.download('path/to/file') }) const PORT = process.env.PORT || 3000 app.listen() res.json()方法用于发送 JSON 数据。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.json({ name: 'John Doe', age: 30 }) }) const PORT = process.env.PORT || 3000 app.listen() res.end()方法用于结束响应。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.end('Hello, World!') }) const PORT = process.env.PORT || 3000 app.listen() res.redirect()方法用于重定向到另一个 URL。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.redirect('/login') }) const PORT = process.env.PORT || 3000 app.listen() res.render()方法用于渲染模板。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.render('index', { title: 'Hello, World!' }) }) const PORT = process.env.PORT || 3000 app.listen() res.sendStatus()方法用于设置响应状态码。 const express = require('express') const app = express() app.get('/user', (req, res) =&gt; { res.sendStatus(200) }) const PORT = process.env.PORT || 3000 app.listen() ","link":"https://lonjinup.github.io/node-06-express/"},{"title":"【node学习-05】mongoDB基础","content":"mongoDB基础 简介 mongoDB是一种基于分布式文件存储的数据库，由 C++ 语言编写。由 MongoDB 自身提供的高性能数据存储，以及第三方提供的各种数据库管理工具，包括用于查询和分析的 MongoDB 自带的 shell 工具。 特点 高性能：MongoDB 是一个高性能的 NoSQL 数据库，是当前最流行的非关系型数据库之一。 易用性：MongoDB 是一个基于文档的数据库，不需要关系型数据库的 SQL 语言，即使对数据库的操作也不需要关系型数据库的 DDL 语言。 灵活性：MongoDB 是一个基于文档的数据库，可以存储各种类型的数据，包括文档、数组、对象、二进制数据等。 高可用性：MongoDB 是一个高可用性的数据库，可以保证数据的安全性和可用性。 低成本：MongoDB 是一个开源的数据库，使用 C++ 编写，因此具有较高的开发效率，部署方便，成本低廉。 高扩展性：MongoDB 是一个分布式数据库，可以水平扩展，即可以将数据复制到多台服务器上，实现数据的高可用性。 非关系型数据库和关系型数据库的区别 非关系型数据库：非关系型数据库不仅仅是指数据库的存储结构，而是指数据库的存储结构和数据库的操作方式。 关系型数据库：关系型数据库是指数据库的存储结构和数据库的操作方式。 关系型数据库和非关系型数据库的优缺点 关系型数据库的优点：关系型数据库的优点是可以实现关系型数据库的查询，数据更新，数据删除等操作，并且这些操作都是事务性的，即要么全部成功，要么全部失败。 关系型数据库的缺点：关系型数据库的缺点是关系型数据库的查询性能不高，因为关系型数据库的查询是基于表的连接查询，而非关系型数据库的查询是基于文档的嵌套查询 mongoDB使用场景 存储海量数据 存储动态数据 存储大量的结构化和非结构化数据 存储高并发数据 存储大量的静态数据 存储大量的半结构化数据 存储大量的非结构化数据 存储大量的关系数据 存储大量的文档数据 安装 mongoDB版本号奇数为测试版本，偶数为稳定版本，而且在3.2版本之后不再支持32位系统，所以建议安装64位的系统。由于不同操作系统安装方式略有不同，建议google一下或者进入mongoDB官网进行安装。同时推荐下载Navicat Premium来进行数据库的管理。 MongoDB的基础概念 数据存储结构及存储库 在 MongoDB 中，数据存储结构主要由集合（Collection）和文档（Document）组成。这种非关系型数据库的设计灵感来源于 JSON 文件格式，因此非常灵活，适用于处理各种不同形式的数据。 集合 集合是 MongoDB 中的一种数据组织方式，类似于关系数据库中的表。不同的是，集合并不要求其中的文档具有相同的结构，可以容纳各种形式和类型的数据。集合的命名通常采用小写字母，避免使用特殊字符和空格。 示例 假设我们有一个博客应用，其中包含一个集合名为 &quot;articles&quot;，用于存储所有文章的数据。每篇文章可以具有不同的字段，例如标题、作者、内容等。示例创建集合的命令如下： db.createCollection(&quot;articles&quot;) 文档 文档是 MongoDB 存储数据的基本单元，类似于关系数据库中的行。每个文档都是一个 JSON 风格的对象，可以包含各种字段和值。在一个集合中，文档的结构可以是不同的，这使得 MongoDB 能够轻松地适应变化多端的数据需求。 当我们使用 MongoDB 存储数据时，文档的表示方式与 JSON 非常相似。以下是文档的 JSON 格式示例： // 在 &quot;articles&quot; 集合中插入一篇文章的文档 db.articles.insert({ &quot;title&quot;: &quot;MongoDB Basics&quot;, &quot;author&quot;: &quot;John Doe&quot;, &quot;content&quot;: &quot;An introduction to MongoDB and its key concepts.&quot;, &quot;tags&quot;: [&quot;NoSQL&quot;, &quot;Database&quot;] }) 在这个示例中，我们创建了一个名为 &quot;articles&quot; 的集合，并向该集合插入了一篇文章的文档。文档的结构以 JSON 格式表示，包含了标题、作者、内容和标签等字段。 MongoDB 的灵活性使得文档可以根据实际需求自由定义字段，而集合则提供了一个容纳不同文档的容器。这种方式使得 MongoDB 适用于处理各种数据结构和数据变化的场景。 通过集合和文档，MongoDB 提供了一种直观且强大的方式来存储和组织数据，适应不同数据结构和变化。这种灵活性是 MongoDB 的一项关键特性，使其成为处理各种数据场景的理想选择。 常用 MongoDB 指令 这是一些常用的 MongoDB 命令，方便大家熟悉 MongoDB 的使用。 指令 描述 mongo 连接到 MongoDB 数据库 show dbs 显示所有数据库 use db_name 切换到指定的数据库 db 显示当前数据库 db.dropDatabase() 删除当前数据库 show collections 显示当前数据库中的所有集合 db.createCollection(name) 创建一个新的集合 db.collectionName.insert(document) 在指定集合中插入文档 db.collectionName.find() 查询指定集合中的文档 db.collectionName.update(query, update) 更新指定集合中符合条件的文档 db.collectionName.remove(query) 删除指定集合中符合条件的文档 db.collectionName.drop() 删除指定集合 db.collectionName.find().sort({field: 1}) 按指定字段升序排序文档 db.collectionName.find().sort({field: -1}) 按指定字段降序排序文档 db.collectionName.find().limit(n) 限制查询结果返回的文档数量 db.collectionName.find().skip(n) 跳过指定数量的文档，返回剩余的文档 db.collectionName.find({field: value}) 查询指定字段等于给定值的文档 db.collectionName.find({field: { $gt: value }}) 查询指定字段大于给定值的文档 db.collectionName.find({field: { $lt: value }}) 查询指定字段小于给定值的文档 db.collectionName.find({field: /pattern/}) 使用正则表达式查询指定字段的文档 db.collectionName.aggregate(pipeline) 执行聚合操作（例如，分组、筛选、排序） db.collectionName.ensureIndex({field: 1}) 创建索引以加速查询 db.collectionName.getIndexes() 查看集合的索引 基本的增删改查 MongoDB 是一个基于文档的数据库，这意味着，与关系型数据库相比，MongoDB 中的数据存储更加灵活。 首先我们创建一个名字为mytest的数据库： use mytest 并且创造一个名字为user的集合： db.createCollection(&quot;user&quot;) 增 在user集合中增加单条数据： db.user.insertOne({name: 'lonjin', age: 18}) 在user集合中增加多条数据： db.user.insertMany([ {name: 'lonjin2', age: 22}, {name: 'lonjin3', age: 33} ]) 查 在user集合中查询所有数据： db.user.find() 在user集合中查询指定条件的数据： db.user.find({age: 18}) 在user集合中查询指定条件的数据（查询age等于18的数据）： db.user.find({age: 18}) 在user集合中查询age大于18的数据： db.user.find({age: {$gt: 18}}) 在user集合中查询age大于18的数据： db.user.find({age: {$gt: 18}}) 在user集合中查询age大于18的数据，并且只输出符合条件的一条数据： db.user.findOne({age: {$gt: 18}}) 改 在user集合中修改name为lonjin，设置他的age为16的数据： db.user.updateOne({name: 'lonjin'}, {$set:{age: 16}}) 在user集合中修改age大于14的数据，将name改为tom： db.user.updateMany({age: {$gt: 14}}, {$set:{name: 'tom'}}) 删除 在user集合中删除age为16的数据： db.user.deleteOne({age: 16}) 在user集合中删除age大于32的数据： db.user.deleteMany({age: {$gt: 32}}) ","link":"https://lonjinup.github.io/mongodb-study/"},{"title":"【node学习-04】创建Express项目","content":"创建Express项目 Express 是一个轻量级、高度可定制的 Web 应用程序框架，它简化了在 Node.js 环境中构建强大的 Web 应用程序的过程。它提供了一系列的功能和工具，可以帮助开发者快速地构建高性能的 Web 应用。Express 的灵活性使得它成为了许多开发者首选的框架之一，同时也被广泛用于构建各类规模的项目。无论是快速搭建一个简单的 API 服务器，还是开发一个复杂的网站，Express 都能提供所需的基础设施和功能支持。 Express特性 Express 是一个简洁、灵活的 Node.js Web 应用程序框架，具有以下特性： 上手简单，学习门槛低：Express 提供了直观且简洁的 API，使得初学者可以快速上手，并且可以随着经验的积累进行深入学习和定制。 丰富的API基础支持：Express 提供了许多构建 Web 应用所需的基础功能，包括路由、请求和响应处理、中间件等，使得开发者可以方便地构建出各种类型的应用。 强大的路由功能：Express 提供了灵活的路由功能，可以根据不同的 URL 路径分发到不同的处理程序，使得开发者可以轻松地管理各类请求和响应。 灵活的中间件支持：Express 中间件提供了一种有效的方式来处理 HTTP 请求。开发者可以通过中间件来扩展 Express 的功能，例如身份验证、日志记录等，使得应用具有更强的可定制性。 性能接近原生Node：由于 Express 是基于 Node.js 构建的，它在处理请求和响应时非常高效，性能接近原生的 Node.js。 Express可以做什么 Express 是一个强大的框架，可以用于构建多种类型的应用： 网站：Express 可以用于构建各种类型的网站，从简单的个人博客到复杂的企业网站，都可以通过 Express 轻松实现。 API接口服务器：许多现代应用程序依赖于后端提供 API 接口，Express 可以作为一个高效的 API 服务器，提供数据的获取、处理和响应功能。 服务端渲染中间层：Express 可以作为服务端渲染应用的中间层，处理前端页面请求并在服务器端进行渲染，提高页面加载速度和 SEO 优化。 开发一些辅助工具：Express 可以用于开发一些辅助工具，例如快速搭建静态文件服务器、代理服务器等，提升开发效率。 自定义集成框架：Express 提供了足够的灵活性，可以根据项目需求进行定制，甚至结合其他模块，构建出符合特定要求的定制框架。 Express项目构建 安装Express 首先，我们需要创建一个名为 express 的文件夹，并在终端中进入该文件夹。接着，可以通过以下命令来初始化一个新的 Node.js 项目： npm init -y 然后，我们安装 Express： npm i express 这样，我们就成功地安装了 Express。我们还可以通过应用生成器工具 express-generator 快速创建一个应用的骨架，这里先不展开叙述了。 创建请求 接下来，我们将创建一个名为 app.js 的文件，并在其中引入 Express。随后，我们可以编写一个简单的 GET 请求处理： 根目录下新建一个/db.json文件： { &quot;user&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18, &quot;sex&quot;: &quot;男&quot; } ] } 然后在/app.js中添加一个/user的get请求接口，该接口返回刚才db.json中的内容： const express = require('express') const app = express() const fs = require('fs') app.get('/user', (req, res) =&gt; { fs.readFile('./db.json', 'utf8', (err, data) =&gt; { if (err) { res.status(500).json(err) } else { res.send(JSON.parse(data)) } }) }) app.listen(3001, () =&gt; { console.log('http://127.0.0.1:3001') }) 最后，通过以下命令运行项目(之前全局安装过nodemon)： nodemon app.js 访问http://127.0.0.1:3001/user即可获得到我们的响应数据。 但是上面的写法一直是不够优雅，写了很多回调函数，这里我们可以promise化一下： const express = require('express') const app = express() const fs = require('fs') //引入promisify const { promisify } = require('util') const readFile = promisify(fs.readFile) app.get('/user', async (req, res) =&gt; { try { let back = await readFile('./db.json', 'utf8') res.send(JSON.parse(back)) } catch (error) { res.status(500).json({ error }) } }) app.listen(3001, () =&gt; { console.log('http://127.0.0.1:3001') }) 上面我们已经建立了一个get请求，下面我们试着创建一个post请求，并接受一些参数： const express = require('express') const app = express() const fs = require('fs') const { promisify } = require('util') const readFile = promisify(fs.readFile) // 解析post请求 app.use(express.urlencoded({ extended: true })) app.use(express.json()) //处理请求 app.post('/add', async (req, res) =&gt; { console.log(req.headers) //当前请求头信息 console.log(req.body) //当前请求体信息 res.send('post success') }) app.listen(3001, () =&gt; { console.log('http://127.0.0.1:3001') }) 创建成功后，我们可以使用postman来测试我们的接口： 参数格式为'content-type': 'application/x-www-form-urlencoded' 参数格式为'content-type': 'application/json' 介绍一下常见传参格式 刚才我们只是写了一个简单的post请求并读取了请求中携带的参数，下面我们把拿到的参数写入到db.json中： const express = require('express') const app = express() const fs = require('fs') const { promisify } = require('util') const readFile = promisify(fs.readFile) // 1.promisify 写入文件 const writeFile = promisify(fs.writeFile) app.use(express.urlencoded({ extended: true })) app.use(express.json()) app.post('/add', async (req, res) =&gt; { // 判读body是否为空 let body = req.body if (Object.keys(body).length !== 0) { try { // 读取文件 let db = await readFile('./db.json', 'utf8') let data = JSON.parse(db) // 添加id body.id = data.user[data.user.length - 1].id + 1 data.user.push(body) // 写入文件 let result = await writeFile('./db.json', JSON.stringify(data), 'utf8') if (!result) { res.status(200).json({ message: '写入成功' }) } else { res.status(500).json({ error: '写入失败' }) } } catch (error) { res.status(500).json({ error }) } } else { res.status(400).json({ error: '缺少信息' }) } }) app.listen(3001, () =&gt; { console.log('http://127.0.0.1:3001') }) 这样我们就完成了添加用户的接口逻辑。 ","link":"https://lonjinup.github.io/node-04/"},{"title":"简化本地Vue项目登录流程：用Node脚本一键获取Token","content":" 最近公司有个项目是基于vue开发的，但部分老页面是前后端不分离的；比如登录页面。由于后端也没有相关登录接口，所以每次在本地启动服务后，需要到测试环境登陆；然后手动复制几个cookie粘贴到本地启动的页面中，整个过程比较繁；所以用node写个脚本去简化一下流程。 优化前 本地npm run serve启动服务 登录测试环境https://test.xxxx.com/login 打开调试，找到相关cookie，复制 打开本地启动的页面并打开调试；粘贴复制的cookie，刷新页面 当然，以下是你整个脚本的逐步解释： 优化过程 安装Puppeteer和readline Puppeteer: Puppeteer 是一个由 Google 开发的 Node.js 库，用于控制 headless 浏览器（无图形用户界面的浏览器）。它提供了一套高级的 API，允许开发者通过程序方式操控浏览器的行为，包括导航、表单提交、截图、生成 PDF 等功能。Puppeteer通常用于执行自动化测试、屏幕截图、搜索引擎爬虫等任务。在本例中，我们使用 Puppeteer 模拟用户登录过程，获取登录后的 Cookies。 readline: readline 是 Node.js 内置的模块之一，提供了一个接口来从可读流（如 process.stdin）读取数据。它通常用于从终端接收用户输入，使得我们可以以交互的方式与用户进行通信。在本例中，我们使用 readline 创建了一个接口，以便用户能够在终端中输入账号和密码。 这两个模块的结合使用使得我们可以通过 Puppeteer 控制浏览器完成登录，而 readline 则使得用户能够在终端中直接输入账号和密码。 安装并引入模块 npm i puppeteer@20.0.0 npm i readline 引入 puppeteer、readline 和 fs： const puppeteer = require('puppeteer') const readline = require('readline') const fs = require('fs') 定义登录函数 我们定义一个名为 login 的异步函数，用于模拟用户登录和获取 cookies。 /** * 登录 * @param {string} url 登录页面url * @param {string} usernameSelector 登录页面用户名输入框的ID * @param {string} passwordSelector 登录页面密码输入框的ID * @param {string} username 账号 * @param {string} password 密码 */ async function login(url, usernameSelector, passwordSelector, username, password) { // ... } 启动浏览器 在 login 函数中，使用 puppeteer.launch() 启动一个 headless 浏览器实例，然后通过page.goto打开我们传入的url。 const browser = await puppeteer.launch({ headless: true }) const page = await browser.newPage() await page.goto(url, { waitUntil: 'load' }) 输入用户名和密码 使用 page.type() 模拟输入用户名和密码，其中第一个参数为输入框的选择器。登录完成后，我们再通过page.click去点击登录按钮。 await page.type(usernameSelector, username) await page.type(passwordSelector, password) await page.click('#_btnLogin') await page.waitForNavigation({ waitUntil: 'load' }) 获取 Cookies 使用 page.cookies() 获取页面的 cookies，并将我们需要的token提取出来。我们这里就随便以APITOKEN 和 bpmftoken 为例子； 提取后我们就可以使用browser.close()关闭浏览器。 const cookies = await page.cookies() const tokens = {} for (const cookie of cookies) { cookie.name === 'APITOKEN' &amp;&amp; (tokens.APITOKEN = cookie.value) cookie.name === 'bpmftoken' &amp;&amp; (tokens.bpmftoken = cookie.value) } browser.close() 写入Tokens到文件 将获取到的tokens写入JSON文件并关闭终端。 const tokenJSON = JSON.stringify(tokens, null, 2) const filePath = './src/config/tokens.json' fs.writeFile(filePath, tokenJSON, (err) =&gt; { if (err) throw err console.log('token已写入，请执行 npm run serve') process.exit(1) }); 访问终端输入数据 使用 readline 模块创建一个接口，获取用户输入的账号和密码。 const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); let username = null; let password = null; const url = 'https://xxxx..com/login'; //登录页面 const usernameSelector = '#_txtUid'; //用户名输入框ID const passwordSelector = '#_txtPwd'; //密码输入框ID rl.question('请输入账号:', (answer) =&gt; { username = answer rl.question('请输入密码:', (answer) =&gt; { password = answer rl.close() login(url, usernameSelector, passwordSelector, username, password) }); }); 终端执行下面命令即可实现获取token。 node login.js 然后在项目中通过读取/src/config/tokens.json中的内容去手动写入token即可。 完整代码如下： const puppeteer = require('puppeteer') const readline = require('readline') const fs = require('fs') async function login(url, usernameSelector, passwordSelector, username, password) { const browser = await puppeteer.launch({ headless: true }) const page = await browser.newPage() try { await page.goto(url, { waitUntil: 'load' }) try { await page.type(usernameSelector, username) await page.type(passwordSelector, password) } catch (error) { console.log(error) } await page.click('#_btnLogin') await page.waitForNavigation({ waitUntil: 'load' }) console.log('登录成功') await page.waitForTimeout(500) const cookies = await page.cookies() const tokens = {} for (const cookie of cookies) { cookie.name === 'APITOKEN' &amp;&amp; (tokens.APITOKEN = cookie.value) cookie.name === 'bpmftoken' &amp;&amp; (tokens.bpmftoken = cookie.value) } await browser.close() const tokenJSON = JSON.stringify(tokens, null, 2) const filePath = './src/config/tokens.json' fs.writeFile(filePath, tokenJSON, (err) =&gt; { if (err) throw err; console.log('token已写入, 请执行npm run serve') process.exit(1) }); } catch (error) { console.error('Error:', error) await browser.close() process.exit(1) } } let username = null; let password = null; const url = 'https://xxxx..com/login'; //登录页面 const usernameSelector = '#_txtUid'; //用户名输入框ID const passwordSelector = '#_txtPwd'; //密码输入框ID const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('请输入账号(默认GP00164，直接回车): ', (answer) =&gt; { username = answer || 'GP00164'; rl.question('请输入密码: (默认GP00164，直接回车)', (answer) =&gt; { password = answer || 'Xxzx2023@123' rl.close() login(url, usernameSelector, passwordSelector, username, password) }) }) 总结 这样我们在本地开发过程中就不需要手动复制token，直接运行node login.js即可。 当然Puppeteer可以做很多事情，比如自动化测试、屏幕截图和生成 PDF、爬虫、性能测试、表单自动填写等等，更多API可以查看官网学习。 ","link":"https://lonjinup.github.io/node-login/"},{"title":"【node学习-03】核心模块http","content":"Node.js 核心模块http 下面我们将学习 Node.js 的 http 模块，通过它来实现以下功能： 创建一个 HTTP 服务器 服务器接收请求并进行处理 响应并返回处理结果 get请求 新建 server.js 文件： // 1.导入模块 const http = require('http') // 2.创建服务器 获取服务器的实例对象 let server = http.createServer() server.listen(3000, () =&gt; { console.log('http://127.0.0.1:3000') }) // 3.接收响应 server.on('request', (req, res) =&gt; { // 4.处理响应 res.write('888') //5.断开连接 res.end() }) 然后在终端运行： node server.js 控制台将输出 http://127.0.0.1:3000。 在浏览器中访问，会得到我们写入的 888。 在 Node.js 开发中，每次修改代码后都需要重启服务才能看到新的输出。为了解决这个问题，我们可以使用 nodemon 工具，它可以自动检测文件的变化并更新服务。安装步骤如下： sudo npm i -g nodemon 安装完成后，通过下面命令启动项目： nodemon server.js 当我们尝试输出中文时，可能会发现浏览器内显示的是乱码。这是因为我们没有告诉浏览器如何解析这段文本，因此我们需要设置一下响应头： server.on('request', (req, res) =&gt; { res.setHeader('Content-Type', 'text/plain;charset=UTF-8'); // 设置响应头 res.write('你好') res.end() }) 通过修改响应头，我们就可以输出对应的内容。 常见请求方式 以下是 Node.js 中常见的请求方法及其说明： 方法 说明 GET 用于向指定的资源请求数据。 POST 用于向指定的资源提交要被处理的数据。 PUT 用于向指定的资源位置上传其最新内容。 DELETE 删除指定的资源。 HEAD 类似于 GET 请求，但只返回 HTTP 报头，不返回实体主体。 OPTIONS 用于获取目标资源所支持的通信选项。 PATCH 对资源进行部分修改。 这些方法在 HTTP 协议中定义，Node.js 提供了对这些方法的支持，可以通过构建 HTTP 请求来使用它们。例如，可以使用 http 或 https 模块创建一个服务器，然后根据接收到的请求的方法来执行相应的处理。 接下来，我们将发起一个带有参数的 GET 请求： 在 server.js 中： const http = require('http') const url = require('url') // 解析携带的参数 let server = http.createServer() server.listen(3000, () =&gt; { console.log('http://127.0.0.1:3000') }) // 接收响应 server.on('request', (req, res) =&gt; { if (req.method === 'GET') { let { query } = url.parse(req.url, true) res.write('GET 请求，参数为：' + query.id) res.end() } }) 在浏览器中访问： http://127.0.0.1:3000/user?id=123 将会返回： GET 请求，参数为：123 这个例子演示了如何使用 Node.js 发起带参数的 GET 请求。 处理 POST 请求 在 server.js 中： const http = require('http') const url = require('url') let server = http.createServer() server.listen(3000, () =&gt; { console.log('http:127.0.0.1:3000') }) server.on('request', (req, res) =&gt; { res.setHeader('Content-Type', 'text/plain;charset=UTF-8'); // 设置响应头 if (req.method === 'GET') { let { query } = url.parse(req.url, true) res.write('get请求,参数为:' + query.id) res.end() } else if (req.method === 'POST') { let postData = '' req.on('data', chunk =&gt; { postData += chunk }) req.on('end', () =&gt; { res.write('POST 请求, 参数为: ' + postData) res.end(); }) } }) 在处理 POST 请求时，我们通过监听 data 事件和 end 事件来获取请求的数据。在 data 事件中，我们将每个数据块（chunk）累加到 postData 中，最终在 end 事件中处理完整的请求数据。 代码拆分 以上示例演示了如何处理不同请求方法的逻辑，但在实际开发中，我们会进一步将代码拆分以保持结构清晰。 我们可以创建一个 router.js 文件来处理路由，以及一个 controller.js 文件来处理具体的业务逻辑。 router.js： const fs = require('fs') const controller = require('./controller') module.exports = (req, res) =&gt; { res.setHeader('Content-Type', 'text/plain;charset=UTF-8'); // 设置响应头 if (req.method === 'GET') { if (req.url == '/') { controller.index(res) } } else if (req.method === 'POST') { let postData = '' req.on('data', chunk =&gt; { postData += chunk }) req.on('end', () =&gt; { controller.user(require('querystring').parse(postData), res) }) } } controller.js： const url = require('url') module.exports = { index(req, res) { let { query } = url.parse(req.url, true) res.write('get请求') res.end() }, user(data, res) { console.log(data) res.end() } } 通过将不同的逻辑模块拆分到 controller.js 中，我们可以更清晰地组织代码。这样在实际的开发中，也能更方便地维护和扩展应用程序。 ","link":"https://lonjinup.github.io/node-http/"},{"title":"vue3项目如何配置ESLint和prettier","content":"vue3项目如何配置ESLint和prettier 配置eslint 安装eslint npm add eslint -D 安装完成后进行项目初始化 npm init @eslint/config 然后根据提示选择对应的选项，作者个人选择如下： ? How would you like to use ESLint? ... To check syntax only To check syntax and find problems &gt; To check syntax, find problems, and enforce code style To check syntax only: 仅检查语法 这个选项只会让 ESLint 检查您的代码是否符合语法规则，不会执行其他的代码质量检查或风格强制。 To check syntax and find problems: 检查语法并发现问题 选择这个选项后，ESLint 将检查您的代码语法，并查找可能存在的问题，如未定义的变量、未使用的变量等。 To check syntax, find problems, and enforce code style: 检查语法、发现问题并强制代码风格。这是最全面的选项，选择后，ESLint 将不仅检查语法和问题，还会根据您的配置强制执行代码风格规则，确保代码在整体风格上保持一致。 通常，如果希望在项目中使用 ESLint 来保证代码的风格一致性和质量，那么直接选择第三个就好。 接下来会询问您的项目使用什么类型的模块（Module）系统： ? What type of modules does your project use? ... &gt; JavaScript modules (import/export) CommonJS (require/exports) None of these JavaScript modules (import/export): JavaScript 模块（使用 import 和 export 语法） 如果项目使用了 JavaScript 的模块系统，即使用了 ES6 的 import 和 export 语法来组织和导入导出代码文件，那么选择这个选项。 CommonJS (require/exports): CommonJS 模块（使用 require 和 module.exports 语法） 如果项目使用了 CommonJS 的模块系统，即使用了 require 和 module.exports 语法来组织和导入导出代码文件，那么选择这个选项。 None of these: 无 如果项目既不使用 JavaScript 的模块系统，也不使用 CommonJS 的模块系统，可以选择这个选项。 由于我是写Vue项目，这里我就选择第一个。 接下来询问在哪个框架中使用： ? Which framework does your project use? ... React &gt; Vue.js None of these 这里我选择了 Vue.js，大家按需选择就好。 接下来会询问你是否使用ts和代码在哪里运行： √ Does your project use TypeScript? · No / **Yes** √ Where does your code run? · browser, node Does your project use TypeScript? 这个选项用来询问您的项目是否使用 TypeScript。TypeScript 是一个 JavaScript 的超集，它添加了静态类型检查和其他特性。您可以选择以下选项之一： No: 如果项目不使用 TypeScript，选择这个选项。 Yes: 如果项目使用 TypeScript，选择这个选项。 如果项目使用 TypeScript，ESLint 会结合 @typescript-eslint 插件来提供 TypeScript 相关的检查和规则。 Where does your code run? 这个选项用来询问您的代码将在什么环境中运行。您可以选择多个环境，如浏览器、Node.js 等。选择适合您项目的环境类型。例如： browser: 如果您的代码将在浏览器环境中运行。 node: 如果您的代码将在 Node.js 环境中运行。 根据您的选择，ESLint 将会根据不同的环境提供相应的规则和检查。 这里还是看项目类型按需选择。 接下来问你希望如何定义项目的样式： √ How would you like to define a style for your project? … Use a popular style guide ❯ Answer questions about your style ## next √ How would you like to define a style for your project? · prompt Use a popular style guide: 使用一个流行的代码风格指南 如果选择了这个选项，就可以从一些已知的流行代码风格指南中进行选择，例如 Airbnb、Google、Standard 等。这将会自动为应用选定的代码风格指南，以及相关的 ESLint 规则和配置。 Answer questions about your style: 如果选择了这个选项，将会被引导回答一系列问题，用于自定义代码风格配置。这将根据自己的偏好和项目需求，创建一个项目的 ESLint 配置。 next: 继续 如果选择了这个选项，您将会跳过当前步骤，继续下一步的配置。 How would you like to define a style for your project? · prompt 如果选择了这个选项，您将会使用交互式提示来自定义代码风格。这将会引导你回答一些问题，以便为你的项目生成适合的 ESLint 配置。 这里我们可以选择第二个。 然后询问你想用什么格式的配置文件： ? What format do you want your config file to be in? ... &gt; JavaScript YAML JSON 这里我就选JavaScript。 询问缩进风格： ? What style of indentation do you use? ... &gt; Tabs Spaces Tabs: 使用制表符进行缩进 如果你选择了这个选项，你的代码中的缩进将使用制表符进行，每一个级别的缩进都是一个制表符。 Spaces: 使用空格进行缩进 如果你选择了这个选项，你的代码中的缩进将使用空格进行，每一个级别的缩进通常是 2 个或 4个空格，这取决于你的偏好和项目规范。 由于我喜欢tab缩进，所以我就选择第一个。 字符串使用双引号还是单引号： ? What quotes do you use for strings? ... Double &gt; Single Double: 使用双引号表示字符串 如果你选择了这个选项，你的代码中的字符串将使用双引号包裹，例如 &quot;Hello, World!&quot;。 Single: 使用单引号表示字符串 如果你选择了这个选项，你的代码中的字符串将使用单引号包裹，例如 'Hello, World!'。 这里看个人or团队习惯，这里我就选择了单引号。 用哪种结束符： ? What line endings do you use? ... &gt; Unix Windows Unix: 使用 Unix 风格的换行符 如果你选择了这个选项，你的代码中的换行符将采用 Unix 风格，即 LF（换行 Line Feed）。 Windows: 使用 Windows 风格的换行符 如果你选择了这个选项，你的代码中的换行符将采用 Windows 风格，即 CRLF（回车换行 Carriage Return Line Feed）。 这里我选择Unix。 是否使用分号： ? Do you require semicolons? » No / Yes 我个人不喜欢使用分号，所以选择No 然后会问你是否安装依赖： @typescript-eslint/eslint-plugin@latest eslint-plugin-vue@latest @typescript-eslint/parser@latest ? Would you like to install them now? » No / Yes 这里我们选择Yes，然后会询问你用什么包管理器去安装依赖： ? Which package manager do you want to use? ... npm yarn &gt; pnpm 这里我选择npm。 安装完成后我们项目的根目录会生成.eslintrc.js文件： module.exports = { env: { browser: true, es2021: true }, extends: ['eslint:recommended', 'plugin:vue/vue3-essential'], overrides: [ { env: { node: true }, files: ['.eslintrc.{js,cjs}'], parserOptions: { sourceType: 'script' } } ], parserOptions: { ecmaVersion: 'latest', sourceType: 'module' }, plugins: ['vue'], rules: { indent: ['error', 'tab'], 'linebreak-style': ['error', 'unix'], quotes: ['error', 'single'], semi: ['error', 'never'] } } 有时候我们希望它可以忽略一些检查，所以我们可以在根目录建立一个.eslintignore文件用来忽略一些检查，这里根据个人需求进行配置即可，我的配置如下： *.sh node_modules *.md *.woff *.ttf .vscode .idea dist /public /docs .husky .local /bin Dockerfile 配置Prettier 尽管 ESLint 和 Prettier 都具备代码质量和维护性方面的功能，但它们的焦点不同。通过同时使用 ESLint 和 Prettier，可以获得代码质量的全面检查，同时确保代码风格的一致性。通常的做法是将 ESLint 用于检测代码问题和逻辑错误，而 Prettier 则用于自动格式化代码，以便代码在不同人之间保持一致的外观。这样可以最大限度地提高代码质量和可维护性。 安装： npm add prettier -D 安装完成后，在项目根目录新建.prettierrc.js文件，这里简单列一下常用的，剩下的可以到官网查看 module.exports = { printWidth: 100, //一行的字符数 tabWidth: 4, // 一个tab代表几个空格数 useTabs: true, //是否使用tab进行缩进 singleQuote: true, //字符串是否使用单引号 semi: false, // 行尾是否使用分号，默认为true trailingComma: &quot;none&quot;, // 是否使用尾逗号 htmlWhitespaceSensitivity: &quot;strict&quot;, // HTML空白敏感度 bracketSpacing: true, // 对象大括号直接是否有空格，默认为 true，效果：{ a: 1 } proseWrap: &quot;never&quot;, // 换行设置 } 同时也可以在根目录下建立忽略文件.prettierignore： /dist/* .local .output.js /node_modules/** **/*.svg **/*.sh /public/* eslint与Prettier相结合 我们可以使用eslint-config-prettier和eslint-plugin-prettier来结合eslint与Prettier。 eslint-config-prettier用来覆盖 ESLint 本身的规则配置， eslint-plugin-prettier则是用于让 Prettier 来接管eslint --fix即修复代码的能力。 安装： npm i eslint-config-prettier eslint-plugin-prettier -D 最终代码如下： module.exports = { env: { browser: true, es2021: true }, extends: ['eslint:recommended', 'plugin:vue/vue3-essential', 'plugin:prettier/recommended'], overrides: [ { env: { node: true }, files: ['.eslintrc.{js,cjs}'], parserOptions: { sourceType: 'script' } } ], // 参考vue官方推荐,替换默认parser parser: 'vue-eslint-parser', parserOptions: { ecmaVersion: 'latest', sourceType: 'module' }, plugins: ['vue'], rules: { indent: ['error', 'tab'], 'linebreak-style': ['error', 'unix'], quotes: ['error', 'single'], semi: ['error', 'never'] } } 然后在项目的package.json中配置一条命令： { &quot;scripts&quot;: { &quot;lint:script&quot;: &quot;eslint --ext .js,.jsx --fix --quiet ./&quot;, } } 该命令于检查和修复代码该命令的作用是在指定的文件扩展名（.js、.jsx）下，运行 ESLint 来检查并尝试修复当前目录及其子目录中的代码问题。命令的目标是自动化代码质量检查和格式修复的过程，以确保代码符合规范和最佳实践。 但还有一个问题就是，目前只会检测.js、.jsx文件，并不会检测.vue文件，这里我们还需要借助一些插件来实现。 支持.vue文件 安装下面插件: npm install eslint-plugin-vue vue-eslint-parser --save-dev 配置.eslintrc.js，在extends中添加这两个插件，最终配置如下： module.exports = { env: { browser: true, es2021: true, node: true }, extends: [ 'eslint:recommended', 'plugin:vue/vue3-essential', //新增插件 'plugin:prettier/recommended', 'plugin:vue/recommended' ], overrides: [ { env: { node: true }, files: ['.eslintrc.{js,cjs}'], parserOptions: { sourceType: 'script' } }, { files: ['*.vue'], rules: { 'no-undef': 'off', 'vue/no-setup-props-destructure': 'off', 'vue/multi-word-component-names': 'off', 'vue/no-mutating-props': 'off', 'no-unused-vars': 0, 'vue/valid-attribute-name': 'off' } } ], // 参考vue官方推荐,替换默认parser parser: 'vue-eslint-parser', parserOptions: { ecmaVersion: 'latest', sourceType: 'module' }, plugins: ['vue'], rules: { 'prettier/prettier': 'error', indent: ['error', 'tab'], 'linebreak-style': ['error', 'unix'], quotes: ['error', 'single'], semi: ['error', 'never'], 'no-console': 'off', 'no-debugger': 'off' } } 然后修改命令为： &quot;scripts&quot;: { &quot;lint:script&quot;: &quot;eslint --ext .js,.jsx,.vue --fix --quiet ./&quot; }, 运行时实时验证 如果使用vscode编辑器，可以下载ESLint和Prettier-Code formatter进行验证，该插件会检测项目根目录是否存在相关配置文件，如果有相关配置文件则会根据配置文件在保存的时候进行检测，如果不用vscode开发也没关系，可以借助一些插件实现运行时代码保存时候根据规则进行验证。 npm i vite-plugin-prettier 在vite.config.js文件中引入插件文件中引入插件： import VitePrettier from 'vite-plugin-prettier' export default defineConfig({ plugins: [ VitePrettier({ singleQuote: true,// 字符串是否使用单引号 //...更多规则 }) ], }) 配置后重启项目，只要项目在运行中，保存代码就会通过prettier进行代码格式化处理。 ","link":"https://lonjinup.github.io/vue3-esilntAndPrettier/"},{"title":"【node学习-02】如何搭建自己的脚手架","content":"如何搭建自己的脚手架 概要 什么是脚手架？ 脚手架是一种工具，通常是一个全局命令行工具，用于帮助开发人员快速创建和初始化项目文件和目录结构。 脚手架的基本能力 命令行执行能力： 脚手架具备能够在命令行中执行的能力，允许用户通过命令行命令来触发脚手架的各种功能。 命令行交互能力： 脚手架可以与用户进行命令行交互，提示用户提供必要的信息或选项，以便根据用户的输入进行项目初始化。 项目初始化代码下载能力： 脚手架能够从远程代码仓库下载项目的初始化代码，以便在本地创建项目。 如何实现一个自己的脚手架工具 要实现一个自己的脚手架工具，可以按照以下步骤进行实现 创建自定义全局命令： 使用Node.js或其他适合的编程语言创建一个全局命令行工具，这个命令可以在任何地方通过命令行调用。通常需要使用包管理器（如npm）来安装全局命令。 命令参数接受处理： 在您的脚手架工具中，编写代码以接受命令行参数，这些参数将指导脚手架执行不同的操作。您可以使用命令行解析库来帮助处理和解释这些参数。 下载远程项目代码： 实现代码下载功能，您可以使用Git或其他版本控制工具来从远程仓库中获取项目的初始化代码。确保您的脚手架可以处理不同的代码源（例如GitHub、GitLab等）。 项目初始化完成提示： 在项目初始化完成后，向用户提供适当的提示信息，指导他们下一步的操作。这可以包括运行项目、安装依赖项或其他相关任务。 测试和文档： 编写测试用例来确保脚手架的稳定性和可靠性。另外，提供清晰的文档，解释如何安装、使用和定制您的脚手架工具。 发布和分享： 将您的脚手架工具发布到适当的包管理器（如npm），以便其他开发人员可以轻松安装和使用它。分享您的脚手架的代码和文档，以促进社区的贡献和改进。 通过遵循这些步骤，您可以创建一个功能强大的脚手架工具，使项目初始化和开发过程更加高效和方便。 创建自定义全局命令 创建文件结构： 我们首先需要设置一个适当的文件结构来开始创建自定义全局命令。在这个过程中，我们会新建一个名为code的文件夹，然后在其中创建一个名为bin的子文件夹。在bin文件夹中，我们将建立一个名为cli.js的文件。这个cli.js文件将包含我们自定义命令的执行逻辑。 项目初始化： 接下来，我们要初始化一个npm项目，以便管理我们的全局命令。在命令行中，我们进入项目的根目录（在code文件夹下），并执行以下命令： npm init -y 在这一步中，我们可以将项目命名为my-cli，并且对其他项目选项采用默认值，因为这些选项可以稍后在package.json中修改。 配置全局命令： 在我们的项目的package.json文件中，有一个特殊的字段叫做bin，它用于配置全局命令。我们将在这里定义我们的全局命令与cli.js文件之间的关联，这样npm就知道如何将我们的命令映射到全局环境中。 { &quot;name&quot;: &quot;my-cli&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;bin&quot;: { &quot;my-cli&quot;: &quot;bin/cli.js&quot; }, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; } 挂载全局命令： 最后，为了使我们的自定义全局命令在系统中可用，我们需要在命令行中执行以下命令，这将使我们的全局命令链接到全局npm包： npm link 这一步骤完成后，我们就可以在任何地方使用my-cli命令来执行我们在cli.js文件中定义的逻辑了。 比如我们可以在cli.js中写点代码： #! /usr/bin/env node console.log('我的cli') 然后运行命令： my-cli 此时我们就会在控制它上看到我们的打印内容：我的cli。 #! /usr/bin/env node 是一个在Unix-like操作系统中用于指定脚本的解释器的特殊注释。这个注释的作用是告诉操作系统使用哪个解释器来执行脚本文件。在这种情况下，它指定了使用Node.js作为解释器来执行该脚本。 具体解释如下： #!：这个字符序列称为&quot;shebang&quot;，它告诉操作系统以下内容是用于解释执行脚本的命令。 /usr/bin/env：这是一个可执行文件，通常用于在系统的环境变量中查找指定的命令或程序。在这里，它被用于寻找可用的node命令。 node：这是Node.js的可执行文件。当操作系统执行这个脚本时，它会找到/usr/bin/env node，然后使用Node.js来解释和执行接下来的脚本内容。 因此，#! /usr/bin/env node 帮助我们确保无论用户的系统上Node.js的安装路径如何，都可以正确地执行我们的Node.js脚本。这对于全局命令行工具非常有用，因为它们需要在不同的系统上运行，而这些系统可能有不同的Node.js安装路径。这个shebang注释确保了脚本的可移植性和跨平台兼容性。 获取命令行参数： 在我们的自定义全局命令中，通常需要获取和解析命令行参数，以便根据用户的输入来执行不同的操作。我们可以在cli.js文件中编写如下代码来获取命令行参数： console.log(process.argv); 当我们运行像my-cli --help这样的命令时，控制台将会打印出以下内容： [ '/usr/local/bin/node', '/usr/local/bin/my-cli', '--help' ] 在这个输出中，process.argv数组包含了命令行中的所有参数。具体来说： process.argv[0] 是 Node.js 的可执行文件路径（在这里是/usr/local/bin/node）。 process.argv[1] 是我们的全局命令的路径（在这里是/usr/local/bin/my-cli）。 后续项包含传递给命令的参数，例如--help。 我们可以根据这些参数来编写逻辑，以决定如何处理用户的输入。这是实现命令行交互能力的一部分，允许我们根据用户的需求来执行不同的功能操作。比如： if(process.argv[2] === '--help'){ console.log('获取到了参数') } 但在实际情况中，我们可以使用一些第三方的包去管理我们的指令；比如：commander（命令参数处理工具）。 Commander命令参数处理工具 Commander 是一个强大的Node.js模块，用于处理命令行参数。以下是使用Commander的基本步骤： 安装Commander 首先，我们需要在npm上搜索并安装Commander模块，这可以通过以下命令完成： npm install commander 引入和使用Commander 在我们的项目中，我们可以引入Commander模块并开始使用它来处理命令行参数。通常，我们会在脚本的开头加上如下注释来指定Node.js作为解释器： #! /usr/bin/env node 接下来，在我们的cli.js文件中，引入Commander并调用program.parse(process.argv)来处理命令行参数： const { program } = require('commander'); program.parse(process.argv); 添加命令和选项 现在，我们可以添加命令和选项来定制我们的命令行工具的行为。例如，我们可以使用program.option()来定义选项： program.option('-f --framework &lt;framework&gt;', '设置框架') 这个例子中，我们定义了一个名为-f或--framework的选项，还提供了一个描述。这将允许用户在命令行中设置一个框架参数。 program.option('-f --framework &lt;framework&gt;', '设置框架') 是使用Commander库定义命令行选项的语句。让我们解释这行代码的作用： program.option()：这是Commander库提供的一个方法，用于定义命令行选项。 -f 和 --framework：这两个部分是选项的名称，它们以两种形式存在，一种是短格式（单字符，前面带一个短划线 -），一种是长格式（多字符，前面带两个短划线 --）。用户可以使用其中任何一种形式来指定选项。 &lt;framework&gt;：这是用尖括号括起来的参数占位符，表示该选项需要一个参数值。在这种情况下，用户需要在选项后面提供一个框架名称作为参数。 '设置框架'：这是选项的描述文本，用于向用户解释选项的用途或目的。在帮助信息中，这个描述文本将帮助用户了解选项的含义。 综合起来，这行代码的作用是定义一个名为-f（或--framework）的命令行选项，该选项需要用户提供一个框架名称作为参数。用户可以通过命令行来设置这个框架选项，而描述文本 '设置框架' 会在帮助信息中显示，以帮助用户理解这个选项的目的。 示例用法： my-cli --framework react 在这个示例中，--framework选项后面的react是用户提供的参数值，用来指定所选的框架。 显示帮助信息 使用Commander，我们还可以轻松地为我们的命令行工具生成帮助信息。只需在脚本中调用program.parse(process.argv)后，运行时，如果用户输入--help选项，将会显示帮助信息。例如： my-cli --help 这将在终端中显示以下信息： Usage: my-cli [options] Options: -f --framework &lt;framework&gt; 设置框架 -h, --help display help for command 处理命令行输入 最后，我们可以通过检查命令行输入来执行不同的操作。在我们的例子中，如果用户没有提供-f或--framework参数，Commander会提示错误，要求用户输入框架参数： my-cli -f 这将导致终端显示以下错误消息： error: option '-f --framework &lt;framework&gt;' argument missing 用户可以通过在-f后面输入框架参数来解决此错误，如： my-cli -f hello 这样，我们就可以使用Commander轻松处理命令行参数，增加命令和选项，以及生成帮助信息，从而更好地控制和定制我们的命令行工具的行为。 如何处理自定义命令参数 在命令行工具开发中，我们经常需要处理自定义的命令参数，以满足用户的需求。在这篇文章中，我们将探讨如何使用Node.js和Commander库来实现这一目标。我们的目标是创建一个命令行工具，允许用户通过输入my-cli create xxx来创建一个项目。同时，我们将通过--help命令自动生成帮助信息。 首先，让我们来看看在bin/cli.js中的代码： #! /usr/bin/env node const { program } = require('commander'); // 定义一个选项 program.option('-f --framework &lt;framework&gt;', '设置框架'); // 定义一个自定义命令 program .command('create &lt;project&gt; [other...]') //定义命令 .alias('crt') //设置别名 .description('创建项目') //备注 .action((project, args) =&gt; { //回调函数 console.log(project); console.log(args); }); // 解析命令行参数 program.parse(process.argv); 我们首先引入了Commander库，并定义了一个选项，使用了-f（短格式）和--framework（长格式），允许用户设置一个框架名称作为参数。 接着，我们使用program.command()定义了一个名为create（或别名crt）的自定义命令。这个命令接受一个project参数和可选的other参数。 我们定义了一个.action()回调函数，用于处理命令的实际操作。在这里，我们简单地打印了project参数和args参数，以便演示如何访问这些自定义命令参数。 最后，我们使用program.parse(process.argv)来解析命令行参数。 现在，让我们运行以下命令来测试： my-cli create myproject otherOptions 结果将是： myproject [ 'otherOptions' ] 我们成功地捕获和处理了命令行参数。 另外，我们可以运行--help命令来查看自动生成的帮助信息： my-cli --help 输出内容： Options: -f --framwork &lt;framwork&gt; 设置框架 -h, --help display help for command Commands: create|crt &lt;product&gt; [orther...] 创建项目 help [command] display help for command 你会发现，Commander自动将我们的自定义命令和选项集成到了帮助信息中，以帮助用户了解如何正确使用我们的命令行工具。 通过这个例子，我们学到了如何使用Node.js和Commander库来处理自定义命令参数，以及如何生成帮助信息，使我们的命令行工具更加友好和易用。 逻辑代码模块化拆分 在开发命令行工具时，将代码模块化拆分是一个良好的实践，有助于保持代码的可维护性和可扩展性。下面，我们将根据不同的功能进行拆分，并创建模块化的代码结构。 首先，我们新建一个lib/core文件夹，并在其中创建以下模块。 1. help.js 模块 在lib/core文件夹下创建一个help.js文件，其内容如下： const setupHelp = (program) =&gt; { program.option('-f --framework &lt;framework&gt;', '设置框架'); }; module.exports = setupHelp; 此模块用于配置命令行工具的帮助选项，并将其导出供其他模块使用。 2. myCommander.js 模块 接下来，在lib/core文件夹中创建一个myCommander.js文件： const setupMyCommander = (program) =&gt; { program.command('create &lt;project&gt; [other...]') .alias('crt') .description('创建项目') .action((project, args) =&gt; { console.log(project); console.log(args); }); }; module.exports = setupMyCommander; 这个模块用于配置自定义命令，并将其导出供其他模块使用。 3. action.js 模块 最后，在lib/core文件夹下创建一个action.js文件，其中包含命令的实际操作逻辑： const performAction = (project, args) =&gt; { console.log(project); console.log(args); }; module.exports = performAction; 这个模块包含了实际操作的代码，并将其导出供其他模块使用。 接下来，让我们在 /bin/cli.js 中引入这些模块，并将它们组合在一起： #! /usr/bin/env node const { program } = require('commander'); // 导入模块 const setupHelp = require('../lib/core/help'); const setupMyCommander = require('../lib/core/myCommander'); const performAction = require('../lib/core/action'); // 配置帮助选项 setupHelp(program); // 配置自定义命令 setupMyCommander(program); // 设置命令的实际操作 program.action(performAction); // 解析命令行参数 program.parse(process.argv); 通过这种方式，我们将代码逻辑模块化拆分，使其更易于理解和维护。同时，也提供了更好的可扩展性，以便将来添加更多功能或命令时能够更轻松地扩展我们的命令行工具。 命令行交互问答工具: Inquirer 通常，在命令行中需要与用户进行交互式的操作，比如询问用户一些问题，获取输入等。这时候，我们可以使用 Inquirer 库来方便地实现这些功能。 安装 Inquirer 首先，我们需要安装 Inquirer 库，可以通过以下命令进行安装： npm install --save inquirer@^8.0.0 使用示例 安装完成后，我们可以在根目录下创建一个 /test/inquirer.js 文件来测试一下： const inquirer = require('inquirer'); inquirer.prompt([ { type: 'input', name: 'username', message: '你的名字', } ]).then(res =&gt; { console.log(res); }); 在当前文件夹内运行以下命令： node inquirer.js 这将提示你输入名字，然后打印出你输入的内容： { username: '11' } 创建一个交互式命令 接下来，我们可以尝试改造之前的 create 命令。 打开 /lib/core/action.js 文件，引入 inquirer，同时在根目录下创建 /config.js 用于保存一些配置项： /** action.js */ const inquirer = require('inquirer'); const config = require('../../config'); const myAction = (project, args) =&gt; { inquirer.prompt([ { type: 'list', name: 'framework', message: '请选择你使用的框架', choices: config.framework, } ]).then(res =&gt; { console.log(res); }); } module.exports = myAction; config.js 文件内容如下： module.exports = { framework: ['egg', 'koa', 'express'] } 然后在 /bin/cli.js 文件中引入并使用这个模块： const { program } = require('commander'); const setupHelp = require('../lib/core/help'); const setupMyCommander = require('../lib/core/myCommander'); const performAction = require('../lib/core/action'); setupHelp(program); setupMyCommander(program); program.action(performAction); program.parse(process.argv); 现在，在项目根目录下运行以下命令： my-cli create nodetest 将会在控制台中出现一个选项供你选择，选择完成后回车，你将得到你选择的值： ? 请选择你使用的框架 koa { framework: 'koa' } 通过这样的方式，我们使用 Inquirer 实现了一个交互式命令，使我们的命令行工具更加灵活和友好。 当使用inquirer.prompt()时，我们可以传递一个配置对象，以定制交互式的提示。以下是一些常用的配置项及其说明： type（类型）: 定义了用户交互的类型。常用的类型包括： input: 接收用户的文本输入。 list: 提供一个列表供用户选择。 checkbox: 提供一个多选框列表供用户选择。 confirm: 提供一个是/否 的确认选择。 name（名称）: 定义了交互结果在返回的对象中的键名。 message（消息）: 显示给用户的问题或提示信息。 default（默认值）: 设定一个默认值，如果用户直接按下回车，则使用该值。 choices（选项）: 用于list和checkbox类型的交互，提供可供选择的选项。 validate（验证）: 可以是一个函数，用于验证用户的输入，返回 true 表示合法，返回错误消息字符串表示非法。 filter（过滤）: 可以是一个函数，用于对用户的输入进行处理，返回处理后的值。 when（条件）: 可以是一个函数，根据前一个问题的答案来确定是否需要显示当前问题。 pageSize（分页大小）: 用于list类型的交互，设置显示的选项数量。 prefix（前缀）: 在问题显示前，可添加一个前缀。 suffix（后缀）: 在问题显示后，可添加一个后缀。 transformer（转换器）: 用于对用户输入和交互结果的进一步处理。 loop（循环）: 当type为list时，选择到最后一个选项会回到第一个选项。 validate（验证）: 可以是一个函数，用于对用户的输入进行验证。 default（默认值）: 设置一个默认值，如果用户直接按下回车，则使用该值。 这些参数可以根据需求组合使用，以实现丰富的交互体验。 示例: inquirer.prompt([ { type: 'input', name: 'username', message: '请输入你的名字', default: 'John Doe', // 默认值 validate: function (value) { if (value.length) { return true; // 输入合法 } return '请输入你的名字'; // 输入非法时的错误消息 } }, { type: 'list', name: 'color', message: '选择一种颜色', choices: ['Red', 'Green', 'Blue'], // 提供的选项 pageSize: 5 // 分页大小 }, // ... ]).then(answers =&gt; { console.log(answers); }); 如何下载远程项目代码 download-git-repo是一个用于从 Git 仓库下载代码的 Node.js 模块。它可以将远程仓库中的代码下载到本地的文件夹中。 安装插件： npm install download-git-repo 使用方法 首先，在我们之前创建的 /config.js 文件中添加了远程项目的仓库地址： module.exports = { framwork: ['egg', 'koa', 'express'], framworkUrl: { 'egg': 'https://github.com/LonJinUp/lonjin-helper', 'koa': 'https://github.com/LonJinUp/wxTabBar', 'express': 'https://github.com/LonJinUp/vue-prettier-plugin' } } 接着，我们创建了 /lib/core/download.js 文件，引入了 download-git-repo 并定义了一个函数： const download = require('download-git-repo') const downFramwork = (url, project) =&gt; { download(`direct:${url}`, project, { clone: true }, (error) =&gt; { console.log(error) }) } module.exports = downFramwork 关于download-git-repo中download参数详细解释如下： download(repository, destination, options, callback) repository: 一个字符串，表示 Git 仓库的地址。可以是 HTTPS 或者 SSH 形式的 Git 仓库地址，也可以是 GitHub、GitLab 或者 Bitbucket 等托管服务的地址。 destination: 一个字符串，表示目标文件夹的路径，代码将会下载到该文件夹中。 options: 一个包含配置选项的对象，可以用来定制下载的行为。常用选项包括： clone: 一个布尔值，表示是否使用 Git 的克隆功能，默认为 false。如果设置为 true，将会使用 Git 克隆整个仓库，否则将会直接下载 ZIP 归档文件（速度更快，但不支持私有仓库）。 checkout: 一个字符串，表示在下载后将会检出的分支或标签名。 depth: 一个整数，表示 Git 克隆时的深度（即历史记录的数量），默认为 undefined，表示克隆完整的历史记录。 callback: 一个回调函数，当下载完成时会调用该函数，可以获取到错误信息。 最后，我们回到了 /lib/core/action.js 中，导入了我们编写好的函数，并做了一些调整。我们也将之前的 inquirer 改成了 await 的写法以提高代码的可读性。 const inquirer = require('inquirer') const config = require('../../config') const download = require('./download') const myAction = async (project, args) =&gt; { const answer = await inquirer.prompt([ { type: 'list', name: 'framework', message: '请选择你使用的框架', choices: config.framework } ]) // 下载模板 download(config.frameworkUrl[answer.framework], project) } module.exports = myAction 最后，我们执行如下命令： my-cli create text-download-1 然后根据你的选择，会下载相应的远程代码，并且文件夹的名称将与 create 命令后面的参数一致。 ","link":"https://lonjinup.github.io/node-02-cli/"},{"title":" vue2项目如何在运行时通过prettier格式化代码","content":"vue2项目如何在运行时通过prettier格式化代码 今天遇到一个问题，老vue2项目由于之前没有使用eslint和prettier进行代码检查和格式化，随着开发人员增加，每个开发人员使用的编辑器不同、格式化插件不同，提交代码时候老会冲突，调研了几个方案，具体如下： 团队统一使用vscode，添加vscode中的prettier插件，添加.vscode文件夹，统一设置配置文件。 项目安装perttier，提交代码前通过命令进行代码格式化。 项目安装perttier，同时使用vscode中的prettier插件，运行时也可以进行格式化。 项目安装perttier和eslint，配合vscode中的两个插件进行处理。 方案1和方案3比较依赖编辑器，如果开发人员不用vscode进行开发，那么就无法进行格式化；方案2每次提交之前都需要运行命令，不够方便；方案4也比较依赖编辑器，而且如果使用eslint，之前的代码肯需要进行一些处理，或者把大部分eslint规则关闭，不够灵活，且折腾下来比较耗时。 那么有没有一种方案，配置简单，且不依赖编辑器上的插件，在运行时只要保存代码即可进行格式化呢？ vue-prettier-plugin 在项目初始化生命周期中启动插件，使用chokidar对整个目录的文件进行监听，发现文件有变化就使用prettier进行格式后进行覆盖保存。 安装插件 npm install vue-prettier-plugin --save-dev 在vue.config.js或webpack.js中引入插件，并初始化： const VuePrettierPlugin = require('vue-prettier-plugin') module.exports = { // ...其他配置 configureWebpack: { plugins: [ new VuePrettierPlugin( { // Prettier 格式化选项 printWidth: 100, tabWidth: 4, // ...其他选项 }, 'src/',//格式化文件路径，默认 src/ ), ], }, }; 运行项目，如果代码有更改，插件就会根据配置项自动格式化文件。 结尾 通过这个插件，我们即可不依赖编辑器、在运行时修改文件即可进行格式化代码。 插件npm地址： vue-prettier-plugin 插件github地址： vue-prettier-plugin ","link":"https://lonjinup.github.io/vue-prettier-plugin/"},{"title":"如何封装优雅、高效的uni-app请求：让开发更轻松","content":"#封装优雅、高效的uni-app请求：让开发更轻松 大家好，今天我想分享一些关于uni-app开发中封装高效、优雅的request请求的经验。之前我在uni-app开发小程序：项目架构以及经验分享 的文章中，已经分享了一些有用的经验技巧，包括二次封装uni-app的API。下面我将详细介绍如何封装一个强大且易用的request请求，希望能够对你的开发工作有所帮助。 为什么需要封装request请求？ 在uni-app开发中，我们经常需要与后端服务器进行数据交互。为了提高开发效率、代码的可维护性以及降低重复代码的使用，我们通常会对网络请求进行封装。 封装request请求的好处有很多： 简化代码：将一些重复性的请求处理逻辑抽离出来，使得业务代码更加清晰简洁，易于阅读和维护。 易于管理：统一管理接口地址、错误处理和请求拦截，方便后期维护和更新。 增强可扩展性：如果后端接口发生变化，只需要修改请求封装的部分而不影响业务代码。 支持 async、await，以提高代码的可读性和简洁性。 在请求库中实现全局的 loading 功能，让用户在发送请求时能够看到加载动画，增强用户体验。 统一处理请求错误，例如网络连接失败时，给予用户友好的错误提示，提高用户满意度。 考虑实现多种请求方式，包括 GET、POST、PUT 等，以满足不同场景下的需求。 为了避免重复请求，可以实现请求拦截功能，在请求发送前判断是否已经在进行相同的请求，如果是，则取消重复请求。 先上一下最终的使用方式： api.js // 引入请求 import request from '@/utils/request' //接口示例 export const info = data =&gt; request.post('/v1/api/info', data) 页面中使用 &lt;script&gt; import { info } from '@/api/user.js' export default { methods: { async getUserinfo() { let res = await info() } } } &lt;/script&gt; coding 1.创建基础请求 首先，我们导入了一些公共方法，比如toast用于显示提示信息，clearStorageSync和getStorageSync用于操作本地缓存，还有useRouter用于跳转页面等。 然后，我们定义了一个名为baseRequest的异步函数。这个函数接收四个参数：url表示请求的地址，method表示请求方法，默认GET请求，data表示要发送的数据，默认为空对象，loading表示是否显示加载动画，默认为true。 在函数内部，我们构建了一个Promise对象，用于支持async 、await调用。 在异步请求中，我们使用了uni.request方法发送请求。我们在请求中传入了请求地址、请求方法、请求头、数据、和超时时间等信息。 如果请求成功，并且状态码为200，那么我们会处理返回的数据。这里的处理逻辑可以根据实际业务需求来修改。如果返回的resultCode为PA-G998(业务逻辑)，表示用户未登录或登录过期，我们会清除本地缓存并跳转到登录页面。否则，我们会将请求成功返回的数据传递给Promise对象的reslove方法。 如果请求失败，我们会显示网络连接失败的提示，并将错误信息传递给Promise对象的reject方法。 import {toast, clearStorageSync, getStorageSync, useRouter} from './utils' // 公共方法 import {BASE_URL} from '@/config/index' //获取请求域名 const baseRequest = async (url, method, data = {}, loading = true) =&gt;{ let header = {} return new Promise((reslove, reject) =&gt; { uni.request({ url: BASE_URL + url, method: method || 'GET', header: header, timeout: 10000, data: data || {}, success: (successData) =&gt; { const res = successData.data if(successData.statusCode == 200){ // 业务逻辑，自行修改 if(res.resultCode == 'PA-G998'){ clearStorageSync() useRouter('/pages/login/index', 'reLaunch') }else{ reslove(res.data) } }else{ toast('网络连接失败，请稍后重试') reject(res) } }, fail: (msg) =&gt; { toast('网络连接失败，请稍后重试') reject(msg) } }) }) } 2.简化入参 上面只是封装了一个最最基础的请求，该方法接受的参数比较多，这个时候我们就需要去做一次简化参数的操作： 首先我们创建一个名为request的对象，并使用forEach方法遍历包含不同HTTP请求方法的数组。对于每个HTTP请求方法，它会定义一个对应的函数，并将其作为request对象的属性。 这样，在使用request对象时，可以直接调用request.GET()、request.POST()等方法来发起不同类型的HTTP请求，而不需要每次都显式地指定请求的方法。这样可以使代码更加简洁和易于维护。 最后导出request对象 const request = {} ['options', 'get', 'post', 'put', 'head', 'delete', 'trace', 'connect'].forEach((method) =&gt; { request[method] = (api, data, loading) =&gt; baseRequest(api, method, data, loading) }) export default request 使用方式如下： /api/user.js 文件 import request from '@/utils/request' //个人信息 export const info = data =&gt; request.post('/v1/api/info', data) 页面使用： import { info } from '@/api/user.js' export default { onLoad() { this.getUserinfo() }, methods: { async getUserinfo() { let res = await info() } } } 禁止重复请求 为了节省网络资源、提高性能和响应速度以及避免数据错误，我们需要对发起的请求做一些限制来避免重复请求，常见的限制方法如下： 1.使用防抖和节流：可以使用防抖和节流的技术来控制请求的触发频率，确保在一段时间内只发起一次请求。 2.设置请求锁：可以在发起请求之前设置一个请求锁，防止重复触发请求。 3.合理设计页面和交互逻辑：在页面设计和交互逻辑中，合理安排请求的时机，避免不必要的重复请求。 我们可以在封装的接口请求中添加一个请求队列，如果有当前发起且没有返回结果的，就不允许再次请求，具体实现思路如下： 1.创建一个存放唯一ID的Map对象 2.当请求接口时候通过拿到的method、url、params、来生成唯一ID 3.请求完成后，把当前ID从对象中删除。 我们把检测唯一ID这个功能提炼出来，单独去封装一个class去实现；具体实现代码如下： 新建/utils/requestManager.js文件，创建一个对象，并初始化一个名为idMap的对象，最后导出对象 class RequestManager { constructor() { this.idMap = new Map() } } export default RequestManager 根据method、url、params、来生成唯一ID，这里要注意的是我们的params需要进行序列化处理，不然如果同一个接口、相同的请求方式、参数顺序不同也会判断为不同的请求。 class RequestManager { /** * 生成唯一ID的方法 * @param {string} method - 请求方法 * @param {string} url - 请求URL * @param {object} params - 请求参数 * @returns {string} - 生成的唯一ID */ generateUniqueId(method, url, params) { const idString = `${method}-${url}-${this.serializeObject(params)}` let id = 0; for (let i = 0; i &lt; idString.length; i++) { id = ((id &lt;&lt; 5) - id) + idString.charCodeAt(i) id |= 0; } return id.toString() } /** * 序列化对象为字符串 * @param {object} obj - 要序列化的对象 * @returns {string} - 序列化后的字符串 */ serializeObject(obj) { const keys = Object.keys(obj).sort() const serializedObj = {} for (let key of keys) { const value = obj[key] if (value !== null &amp;&amp; typeof value === 'object') { serializedObj[key] = this.serializeObject(value) } else { serializedObj[key] = value } } return JSON.stringify(serializedObj) } } 写完生成方法，相对应的实现一下删除方法： class RequestManager { /** * 根据ID删除map对象中的请求信息 * @param {string} id - 要删除的唯一ID */ deleteById(id) { this.idMap.delete(id) } } 上面就实现了基本的功能，下面我们写一个方法，去组合一下上面的功能，简化使用： class RequestManager { /** * 生成唯一ID，并将ID和请求信息存储到map对象中 * @param {string} method - 请求方法 * @param {string} url - 请求URL * @param {object} params - 请求参数 * @returns {string|boolean} - 生成的唯一ID，如果存在相同id则返回false */ generateId(method, url, params) { const id = this.generateUniqueId(method, url, params) if (this.idMap.has(id)) { return false } this.idMap.set(id, { method, url, params }) return id } } 到这里我们的方法就写完了，下面来看一下如何使用： //引入方法 import RequestManager from '@/utils/requestManager.js' const manager = new RequestManager() //创建 const baseRequest = async (url, method, data = {}, loading = true) =&gt;{ // 生成唯一ID, 如果返回false 代表重复请求 let requestId = manager.generateId(method, url, data) if(!requestId) { console.log('重复请求') return false } return new Promise((reslove, reject) =&gt; { uni.request({ complete: ()=&gt;{ // 请求完成，清除当前请求的唯一ID manager.deleteById(requestId) }, }) }) } 添加全局loading 添加全局loading就比较简单了，我们前面定义了入参数loading，如果为true，在创建Promise后，调用uni.showLoading即可。 同时需要在uni.request中添加complete方法，在请求完成后去关闭loading。 const baseRequest = async (url, method, data = {}, loading = true) =&gt;{ return new Promise((reslove, reject) =&gt; { // 开启loading loading &amp;&amp; uni.showLoading({title: 'loading'}) uni.request({ // ... complete: ()=&gt;{ // 关闭loading uni.hideLoading() }, // ...省略下方代码 }) }) } 结尾 所有代码已放到github；请访问 uni-app-template，如果觉得不做，记得给个star ","link":"https://lonjinup.github.io/uni-request/"},{"title":"【node学习-01】node.js基础","content":"node基础 node是什么？ Node.js 不是一门语言，是一个运行时，和浏览器更像，只不过运行在服务端。 这个运行时的方言是 JavaScript（不包含 BOM、DOM API，增加了 Stream、网络等 API）。 Node.js 是靠 Chrome V8 引擎运行 JavaScript。 对应到 Java 我们可以理解 Node.js 是 JDK，装上就能在服务端跑 JavaScript 代码了。Chrome 和 Node.js 同样是 JavaScript 运行时，都使用了 V8 引擎，主要区别在于 V8 只实现了 ECMAScript 的数据类型、对象和方法，Chrome 运行时提供了 Window、DOM、BOM，而 Node.js 运行时提供了global、 Buffer、net 等模块 node可以干什么？ 后端web服务器开发与网络爬虫开发 脚手架命令行工具开发 图形界面应用程序开发 环境搭建与基础入门 安装node 打开 node.js官网，选择长期维护版进行安装。 终端下输入 node -v 可以输出版本号即可证明安装成功 如何使用node.js 运行JavaScript代码 新建 index.js 文件，写入如下内容： let a = 1 console.log(a) 终端下输入： node index.js 控制台就会打出1 文件操作与模块化的概念 读取文件内容 新建read.js，引入fs模块，通过fs下的readFile进行读取： // 引入fs 模块 var fs = require('fs') // 文件路径 编码格式 回调函数（异常，文件内容） fs.readFile('./index.txt', 'utf8', function (error, data) { console.log(error) // null console.log(data) // txt 文件中的内容 }) 写入文件内容 写入文件依旧通过fs下的writeFile来实现，代码如下： // 引入fs 模块 var fs = require('fs') // 文件路径 内容 回调函数（异常） fs.writeFile('./index.txt', 'hello lonjin', function (error) { !error &amp;&amp; console.log('写入成功') }) 追加内容 通过上面内容我们可以完成文件的读取与写入，那么追加就比较简单了，具体代码如下： // 引入fs 模块 var fs = require('fs') fs.readFile('./index.txt', 'utf8', function (error, data) { if (!error) { let newData = data + new Date() fs.writeFile('./index.txt', newData, function (error) { !error &amp;&amp; console.log('追加成功') }) } }) 模块化编程的概念 当我们在Node.js中写代码时，我们通常需要使用不同的模块来完成不同的任务。require('fs')就是Node.js中的模块系统，通过它我们可以引入其他模块，例如fs模块来进行文件操作。 为什么我们需要模块化呢？在JavaScript中，如果我们把所有代码都写在一个文件中，那么文件将变得非常大且难以维护。同时，如果我们需要在多个文件中重复使用某个功能，那么我们需要在每个文件中都写入这个功能，这样会导致代码冗余和维护成本的增加。因此，我们需要一种能够拆分代码、相互独立、导入导出的方式来进行模块化编程。 在JavaScript中，有多种模块化的概念，比如CommonJS、AMD、ES6等。Node.js采用了CommonJS规范，即通过require()来引入模块，通过module.exports来导出模块。在ES6中，我们可以使用import和export来进行模块化编程。而AMD则是另外一种模块化方案，它采用了异步模块定义，适合在浏览器端进行模块化编程。 通俗一点的说，模块化编程其实就是拆分代码、相互独立、导入导出；好比造车，汽车轮胎算一个模块，汽车引擎算一个模块、汽车车体算一个模块，通过各个模块的组装，最终生产出一辆汽车。JavaScript中的模块化的概念也是近几年才出现的，之前的js并没有模块化的概念。 npm包管理器 npm（Node Package Manager）是 Node.js 的包管理器，用于管理和共享 JavaScript 代码。它是 Node.js 官方提供的默认包管理工具，用于安装、发布、更新和管理 JavaScript 包和依赖项。 作用 包管理：npm 允许开发者在项目中安装、更新和卸载依赖的第三方包或模块，提供了一个方便的方式来管理项目的依赖关系。 代码共享：开发者可以通过 npm 发布自己编写的模块或应用，并将其共享给其他开发者使用。 版本控制：npm 提供了丰富的版本管理功能，开发者可以指定安装特定版本的包，以确保项目的稳定性和兼容性。 常用命令 npm init：初始化一个新的项目，生成 package.json 文件。 npm install：安装项目依赖，根据 package.json 中的配置自动下载并安装依赖。 npm install &lt;package&gt;：安装指定的包。 npm install --save-dev &lt;package&gt;：安装开发环境依赖，仅在开发阶段使用。 npm update：更新项目依赖的包到最新版本。 npm uninstall &lt;package&gt;：卸载指定的包。 npm run &lt;script&gt;：运行项目中定义的脚本命令，可以在 package.json 的 scripts 部分定义自定义命令。 npm publish：将自己编写的模块发布到 npm 公共注册表，供其他人使用。 npm search ：在 npm 注册表中搜索指定的包。 npm outdated：检查项目中已安装包的更新状态。 这只是一些常用的 npm 命令，npm 还提供了其他许多命令和功能，可以根据具体需求参考官方文档或使用 npm help 命令获取更多信息。 管理npm包 新建一个time文件夹，文件夹下建立index.js，下面我们输出一个当前日期： let time = Date.now() console.log(time) //1692708681030 如果我们想输出一个年-月-日 时：分：秒的格式，则可以利用npm上的包进行处理，比如moment。 安装： npm i moment 引入&amp;&amp;使用： const moment = require('moment') let time = Date.now() console.log(moment(time).format('YYYY-MM-DD HH:mm:ss')) //2023-08-22 20:51:21 这就是npm包最简单的一个使用。 ","link":"https://lonjinup.github.io/node-01/"},{"title":"uni-app开发小程序：项目架构以及经验分享","content":"uni-app开发小程序：项目架构以及经验分享 2022年的时候，公司为了快速完成产品并上线，所以选用微信小程序为载体；由于后期还是打算开发App；虽然公司有ios和Android，但是如果能一套代码打包多端，一定程度上可以解决成本。前端技术栈也是vue，在考察选择了uni-app。后来多个小程序项目都采用了uni-app开发，积累了一定的经验以及封装了较多业务组件，这里就分享一下uni-app项目的整体架构、方法封装组件库选择以及注意事项。全文代码都会放到github，先赞后看，月入百万！ 创建项目 uni-app提供了两种创建项目的方式： 1.通过HBuilderX可视化工具创建 2.通过vue-cli命令创建 ⚠️需要注意的是，一定要根据项目需求来选择项目的创建方式；如果只是单独的开发小程序或App，且开发环境单一，可以使用HBuilderX可视化工具创建。如果多端开发，以及同一套代码可能会打包生成多个小程序建议使用vue-cli进行创建，不然后期想搞自动化构建以及按指定条件进行编译比较痛苦。关于按条件编译，文章后面会有详细说明。 使用vue-cli安装和运行： 1.全局安装 vue-cli npm install -g @vue/cli 2.创建uni-app vue create -p dcloudio/uni-preset-vue 项目名称 3.进入项目文件夹 cd 项目名称 4.运行项目，如果是已微信小程序为主，可以在package.json中的命令改为： &quot;scripts&quot;: { &quot;serve&quot;: &quot;npm run dev:mp-weixin&quot; } 然后执行 npm run serve 使用cli创建项目默认不带css预编译，需要手动安装一下，这里已sass为例： npm i sass --save-dev npm i sass-loader --save-dev 整体项目架构 通过HBuilderX或者vue-cli创建的项目，目录结构有稍许不同，但基本没什么差异，这里就按vue-cli创建的项目为例，整体架构配置如下： ├──dist 编译后的文件路径 ├──package.json 配置项 ├──src 核心内容 ├──api 项目接口 ├──components 全局公共组件 ├──config 项目配置文件 ├──pages 主包 ├──static 全局静态资源 ├──store vuex ├──mixins 全局混入 ├──utils 公共方法 ├──App.vue 应用配置，配置App全局样式以及监听 ├──main.js Vue初始化入口文件 ├──manifest.json 配置应用名称、appid等打包信息 ├──pages.json 配置页面路由、导航条、选项卡等页面类信息 └──uni.scss 全局样式 封装方法 工欲善其事，必先利其器。在开发之前，我们可以把一些全局通用的方法进行封装，以及把uni-app提供的api进行二次封装，方便使用。全局的公共方法我们都会放到/src/utils文件夹下。 封装常用方法 下面这些方法都放在/src/utils/utils.js中，文章末尾会提供github链接方便查看。如果项目较大，建议把方法根据功能定义不同的js文件。 小程序Toast提示 /** * 提示方法 * @param {String} title 提示文字 * @param {String} icon icon图片 * @param {Number} duration 提示时间 */ export function toast(title, icon = 'none', duration = 1500) { if(title) { uni.showToast({ title, icon, duration }) } } 缓存操作（设置/获取/删除/清空） /** * 缓存操作 * @param {String} val */ export function setStorageSync(key, data) { uni.setStorageSync(key, data) } export function getStorageSync(key) { return uni.getStorageSync(key) } export function removeStorageSync(key) { return uni.removeStorageSync(key) } export function clearStorageSync() { return uni.clearStorageSync() } 页面跳转 /** * 页面跳转 * @param {'navigateTo' | 'redirectTo' | 'reLaunch' | 'switchTab' | 'navigateBack' | number } url 转跳路径 * @param {String} params 跳转时携带的参数 * @param {String} type 转跳方式 **/ export function useRouter(url, params = {}, type = 'navigateTo') { try { if (Object.keys(params).length) url = `${url}?data=${encodeURIComponent(JSON.stringify(params))}` if (type === 'navigateBack') { uni[type]({ delta: url }) } else { uni[type]({ url }) } } catch (error) { console.error(error) } } 图片预览 /** * 预览图片 * @param {Array} urls 图片链接 */ export function previewImage(urls, itemList = ['发送给朋友', '保存图片', '收藏']) { uni.previewImage({ urls, longPressActions: { itemList, fail: function (error) { console.error(error,'===previewImage') } } }) } 图片下载 /** * 保存图片到本地 * @param {String} filePath 图片临时路径 **/ export function saveImage(filePath) { if (!filePath) return false uni.saveImageToPhotosAlbum({ filePath, success: (res) =&gt; { toast('图片保存成功', 'success') }, fail: (err) =&gt; { if (err.errMsg === 'saveImageToPhotosAlbum:fail:auth denied' || err.errMsg === 'saveImageToPhotosAlbum:fail auth deny') { uni.showModal({ title: '提示', content: '需要您授权保存相册', showCancel: false, success: (modalSuccess) =&gt; { uni.openSetting({ success(settingdata) { if (settingdata.authSetting['scope.writePhotosAlbum']) { uni.showModal({ title: '提示', content: '获取权限成功,再次点击图片即可保存', showCancel: false }) } else { uni.showModal({ title: '提示', content: '获取权限失败，将无法保存到相册哦~', showCancel: false }) } }, fail(failData) { console.log('failData', failData) } }) } }) } } }) } 更多函数就不在文章中展示了，已经放到/src/utils/utils,js里面，具体可以到github查看。 请求封装 为了减少在页面中的请求代码，所以我们要对uni-app提供的请求方式进行二次封装，在/src/utils文件夹下建立request.js，具体代码如下： import {toast, clearStorageSync, getStorageSync, useRouter} from './utils' import {BASE_URL} from '@/config/index' const baseRequest = async (url, method, data, loading = true) =&gt;{ header.token = getStorageSync('token') || '' return new Promise((reslove, reject) =&gt; { loading &amp;&amp; uni.showLoading({title: 'loading'}) uni.request({ url: BASE_URL + url, method: method || 'GET', header: header, timeout: 10000, data: data || {}, success: (successData) =&gt; { const res = successData.data uni.hideLoading() if(successData.statusCode == 200){ // 这里根据自己的业务逻辑去调整 if(res.resultCode == 'PA-G998'){ clearStorageSync() useRouter('/pages/login/index', 'reLaunch') }else{ reslove(res.data) } }else{ toast('网络连接失败，请稍后重试') reject(res) } }, fail: (msg) =&gt; { uni.hideLoading() toast('网络连接失败，请稍后重试') reject(msg) } }) }) } const request = {}; ['options', 'get', 'post', 'put', 'head', 'delete', 'trace', 'connect'].forEach((method) =&gt; { request[method] = (api, data, loading) =&gt; baseRequest(api, method, data, loading) }) export default request 请求封装好以后，我们在/src/api文件夹下按业务模块建立对应的api文件，拿获取用户信息接口举例子： 在/src/api文件夹下建立user.js，然后引入request.js import request from '@/utils/request' //个人信息 export const info = data =&gt; request.post('/v1/api/info', data) 在页面中直接使用： import {info} from '@/api/user.js' export default { methods: { async getUserinfo() { let info = await info() console.log('用户信息==', info) } } } 自定义tabBar 写uni-app或者小程序基本避不开这个话题了，很多情况下，官方提供的tabBar方案并不能满足产品需求/ui要求，官方也提供了自定义tabBar的方案，但此方案有很多弊端，比如：切换时候会tabBar会有明显的闪动。可以参考之前写的文章小程序自定义TabBar 如何实现“keep-alive”，文章中是原生小程序，但思路在uni-app中同样适用，如果感兴趣，可以评论区提问。 版本切换 很多场景下，需要根据不同的环境去切换不同的请求域名、APPID等字段，这时候就需要通过环境变量来进行区分。下面案例我们就分为三个环境：开发环境(dev)、测试环境(test)、生产环境(prod)。 建立env文件 在项目根目录建立下面三个文件并写入内容(常量名要以VUE开头命名)： .env.dev(开发环境) VUE_APP_MODE=build VUE_APP_ID=wxbb53ae105735a06b VUE_APP_BASE=https://www.baidu.dev.com .env.test(测试环境) VUE_APP_MODE=build VUE_APP_ID=wxbb53ae105735a06c VUE_APP_BASE=https://www.baidu.test.com .env.prod(生产环境) VUE_APP_MODE=wxbb53ae105735a06d VUE_APP_ID=prod VUE_APP_BASE=https://www.baidu.prod.com 修改package.json文件 &quot;scripts&quot;: { &quot;dev:mp-weixin&quot;: &quot;cross-env UNI_PLATFORM=mp-weixin vue-cli-service uni-build --watch --mode dev&quot;, &quot;build:mp-weixin&quot;: &quot;cross-env UNI_PLATFORM=mp-weixin vue-cli-service uni-build --watch --mode prod&quot; }, 然后执行 npm run dev:mp-weixin 在/src/pages/index/index.vue下，打印： onLoad() { console.log(process.env.VUE_APP_MODE, '====VUE_APP_BASE') console.log(process.env.VUE_APP_BASE, '====VUE_APP_BASE') }, 此时输出结果就是 dev ====VUE_APP_BASE https://www.baidu.dev.com ====VUE_APP_BASE 动态修改appid 如果同一套代码，需要打包生成多个小程序，就需要动态修改appid了；文章开头说过appid在/src/manifest.json文件中配置，但json文件又不能直接写变量，这时候就可以参考官方 提出的解决方案：建立vue.config.js文件，具体操作如下。 在根目录下建立vue.config.js文件写入以下内容： // 读取 manifest.json ，修改后重新写入 const fs = require('fs') const manifestPath = './src/manifest.json' let Manifest = fs.readFileSync(manifestPath, { encoding: 'utf-8' }) function replaceManifest(path, value) { const arr = path.split('.') const len = arr.length const lastItem = arr[len - 1] let i = 0 let ManifestArr = Manifest.split(/\\n/) for (let index = 0; index &lt; ManifestArr.length; index++) { const item = ManifestArr[index] if (new RegExp(`&quot;${arr[i]}&quot;`).test(item)) ++i if (i === len) { const hasComma = /,/.test(item) ManifestArr[index] = item.replace( new RegExp(`&quot;${lastItem}&quot;[\\\\s\\\\S]*:[\\\\s\\\\S]*`), `&quot;${lastItem}&quot;: ${value}${hasComma ? ',' : ''}` ) break } } Manifest = ManifestArr.join('\\n') } // 读取环境变量内容 replaceManifest('mp-weixin.appid', `&quot;${process.env.VUE_APP_ID}&quot;`) fs.writeFileSync(manifestPath, Manifest, { flag: 'w' }) 如果是通过HBuilderX可视化工具创建的项目，则无法去自动根据环境去修改appid，只能去手动修改。 组件库 uni-app最受欢迎的可能就是插件市场了，插件市场提供了很多优秀的插件/组件库供我们选择，比较火的就是自家的uni-ui以及uView UI，大部分组件还是比较好用的，如果做中大型项目以及UI要求较高的情况下，还是比较推荐自己搭一套组件库，方便扩展以及维护。 结尾 关于uni-app项目的起步工作就到这里了，后面有机会写一套完整的uni搭建电商小程序项目，记得关注。代码已经提交到github，如果对你有帮助，记得点个star! ","link":"https://lonjinup.github.io/uni-app-template-01/"},{"title":"优秀技术博客的持续创作技巧","content":"如何写作？如何持续性创作 最近看了张鑫旭大佬写的《技术写作指南》；在这里总结一下，顺便聊一聊写博客这个话题。 为什么要写 关于为什么要写博客，每个人都有不同的答案；有的人可能是为了记录一下学习总结，有的人可能是希望自己的文章可以给别人带来一定的帮助，也有可能是为了获得一定的知名度，发展自媒体。 我为什么要写博客呢？这得从刚入行说起了。刚入行的前两年感觉非常迷茫，呆的公司技术老旧，只能在下班时间去自己学习，那时候基本都是看别人的视频课程；学习过程中记录笔记是非常有必要的。再后来接触了掘金，发现了很多优质文章，所以写博客的念头愈演愈烈。所以就在网上简单的搭建了一个博客。 如何定标题 虽然常说内容为王，但是好的标题能让你的文章有更多的点击率，如果标题不吸引人，那么读者可能都不会点进详情去看。我想很多人起标题时候都会头疼，这个问题也经常困扰着我，如何能让标题更有吸引力。下面分享一下我起标题的一些经验和方法。 标题与文章关联 首先我很讨厌标题党，标题为深入了解xxxx，结果进去查看文章没有一点深度，这样的文章很让人讨厌，所以我建议文章标题最起码要符合内容。同时标题内尽量包含整篇文章的关键字，这样便于搜索引擎抓取，同时也考虑用户搜索习惯。下面用我之前写的一篇文章小程序实现TabBar创意动画(文末附完整源代码)来举例子。 先解析一下标题关键词：小程序、TabBar、创意动画、附完整源代码，这个标题基本上涵盖了我上面讲的要领，而且很符合用户的搜索习惯，用户搜索小程序TabBar动画、小程序TabBar技巧等基本都可以显示在第一位。 适当性的修饰 如果发布在第三方平台，有时候标题起的太过死板点击率少的可怜；在掘金上看过不少优秀的标题，本人这方面经验也不是很多，可以参考一下掘金2022榜单： 总结一下：这些标题要么是疑问句？引起读者的好奇心；要么就是事件的起因+解决方案+结果。 使用黑科技 前段时间大火的openai不就可以派上用场了吗？下面试一下效果： 优化过的标题，基本上比我之前起的标题要好一些，再自己修改修改就可以直接用了。 写作框架 一篇好文章一定具备以下特征： 1.文章连贯，前后呼应，在整篇文章中，每段文字最好有一定的连贯性，也就是小时候写作文老师经常提到的承上启下。 2.突出重点，在写文章时候一定不要忘了核心主题，切记不要脱离文章主题。所以在写文章之前，可以给自己列一个大纲，避免写着写着跑题了。 具体的写作套路 下面罗列了不同类型文章的写作框架，大家写文章时候可以参考一下： 1.技术科普 2.原理剖析 3.功能实现 4.使用教程 5.问题解决 如何坚持 说实话，坚持一个事情是非常难的，尤其是写作这种事情。因为写作给作者带来的汇报/反馈短期内表现不出来，一旦没有结果反馈，慢慢就会失去兴趣。比如游戏；在我们玩游戏时候为什么能够那么上瘾呢？因为短期内的付出都会带来一定的结果反馈。既然我们可以乐此不疲的玩游戏、刷视频、追剧，那么我相信也可以进行坚持写作。 关于这方面的经验，本人也不是很多；今年也没写几篇文章。不过还是在2023年打算坚持一下写作。这里我总结了一下张鑫旭大佬提供的方法： 多多奖励自己，每写完一篇文章，都要给自己一些奖励，比方说奖励自己玩一盘游戏 学会任务分解，比如每天坐地铁上班时候先罗列一下文章选题/框架，在公司摸鱼时候可以搜集一下相关资料，下班吃完饭再一气呵成。 敢于放纵自己，如果平时工作或者加班太忙，确实没有时间；也不必勉强自己，该放松的时候就放松。 总结 写技术类博客，当时可能不会有什么技术反馈，但是只要你能坚持1周一篇的稳定更新，2年内绝对可以超过绝大多数人。而且你的博客有一定的曝光，也可能会给你带来一些不错的工作机会。不管出于什么原因，希望各位可以坚持输出，加油吧！ ","link":"https://lonjinup.github.io/blogstudy/"},{"title":"vuepress自动化部署到github","content":"vuepress自动化部署github 最近打算把一些项目中常用的函数方法统一封装一下，同时发布到npm，以便于项目中使用。vuepress使用上相对简单，就不做过多的演示了，这里主要讲解一下如何自动化部署到github,生成预览地址。 生成TOKEN 登录github，点击右侧头像,点击Settings 左侧菜单下找到 Developer settings，点击进入 在 Personal access tokens 分类下找到 Tokens (classic)，点击进入 点击 Generate new token 按钮，点击 Generate new token (classic) 设置 token名称为 ACCESS_TOKEN，把生成的token复制一下 设置TOKEN 进该项目的仓库中，点击settings 点击左侧 Secrets 点击右侧按钮 new repository secret 创建的名字和 .yml 中的 secret.xxx 要对应，值就写刚刚生成的 Github 密钥 创建配置文件 在根目录下创建配置文件 .github/workflows/jekyll-gh-pages.yml 添加配置 # action 的名称 name: Deploy GitHub Pages # 触发条件：在 push 到 master 分支后 on: push: branches: - master # 任务 jobs: build-and-deploy: # 服务器环境：最新版 Ubuntu runs-on: ubuntu-latest steps: # 拉取代码 - name: Checkout uses: actions/checkout@v2 with: persist-credentials: false # 生成静态文件 - name: Build run: npm install &amp;&amp; npm run docs:build # 部署到 GitHub Pages - name: Deploy # 使用别人写好的一个 action uses: JamesIves/github-pages-deploy-action@releases/v3 with: # 这里的 ACCESS_TOKEN 名字需要和下文中的相对应 ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }} # 打包后的文件部署到哪个分支上 BRANCH: gh-pages # 打包后的文件在哪里 FOLDER: docs/.vuepress/dist 设置GitHub Pages 进该项目的仓库中，点击settings 点击项目左侧的Pages 找到Build and deployment这一项，Source选择Deploy from a branch Branch选择gh-pages /(root)然后保存即可 结尾 到这里就已经配置结束了，只要master分支有变化，就会自动化执行一次，生成新的文档。 ","link":"https://lonjinup.github.io/vuepress-setting/"},{"title":"vueRouter实现原理","content":"vueRouter 实现原理 前置知识 想了解vueRouter，需要先了解vue中的插件、混入、Vue.observable、插槽、render函数、运行时和完整版Vue的概念，如果没有了解，可以先在官网复习一波。 vueRouter两种模式 总所周知，vueRouter分为hash模式和history模式；两种区别如下： 模式名称 实现原理 Hash模式 hash模式以url中#号后面的内容作为路径，通过监听hashchange事件获取到当前路由地址然后找到对应的组件进行渲染 history模式 通过popstate事件，根据当前路由地址找到相应的组件进行渲染(需要服务端支持) 实现思路 先看一下我们平时使用vueRouter的关键代码： // router/index.js // 1.引入VueRouter import VueRouter from 'vue-router' // 2.引入vue import Vue from 'vue' // 3. 注册路由插件 Vue.use(VueRouter) // 4.添加路由规则 const routes = [ { path: '/', name: 'index', component: Layout }, ] // 5.创建路由对象，传入路由规则 const router = new VueRouter({routes}) // 6.导出router export default router // main.js import Vue from 'vue' import router from './router' new Vue({ // 7. 注册 router 对象 router, render: h =&gt; h(App) }).$mount('#app') 这里我们需要解一下Vue.use()方法：该方法至少传入一个参数，该参数类型必须是 Object 或 Function，如果是 Object 那么这个 Object 需要定义一个 install 方法，如果是 Function 那么这个函数就被当做 install 方法。在Vue.use()执行时 install 会默认执行，当 install 执行时第一个参数就是 Vue，其他参数是 Vue.use()执行时传入的其他参数；同时Vue.use()会自动阻止多次注册相同插件。 了解完使用流程，我们来分析一下它的实现思路： 创建VueRouter插件，静态方法install，在install方法中，判断插件是否已经被加载，同时在vue加载的时候把传入的router对象挂载到vue实例上。 创建VueRouter类: 初始化options(记录构造函数中传入的对象)、routeMap(记录路由地址和组件的对应关系)、data(相应式的对象，可以记录当前路由地址，当路由地址变化时候，对应的组件做相应的更新) 创建initRouteMap()方法，遍历所有路由信息，把组件和路由的映射记录到routeMap对象中 注册popstate事件，当路由地址发生变化，重新记录当前的路径 创建router-link和router-view组件 当路径改变的时候通过当前路径在routerMap对象中找到对应的组件，渲染router-view 分析完大概思路，我们就可以创建文件开始编写。 实现 install 方法 首先我们需要创建一个vueRouter文件夹，里面创建一个index.js 文件，我们在上面分析了一下VueRouter在使用时候有new的操作，所以我们使用ES6中class来实现。具体步骤如下： // 设置全局变量 let _Vue = null class VueRouter { static install(Vue) { // 1.判断当前插件是否安装 if(VueRouter.install.isInstalled) return; VueRouter.install.isInstalled = true // 2.把vue构造函数记录到全局变量 _Vue = Vue // 3.把创建vue实例的时候传入的router对象挂载到vue全局对象上 _Vue.mixin[{ beforeCreate() { // 判断当前实例上是否有router if(this.$options.router) { _Vue.prototype.$router = this.$options.router } } }] } constructor(options) { this.options = options; this.routerMap = {} } } constructor 构造函数 在constructor构造函数中，首先我们先把传入的options保存，然后初始化routerMap，到时候需要便利传入进来的路由规则，然后以键值对的形式存入到routerMap中，最后，我们需要创建一个响应式的data对象，Vue中提供了 observable 方法来帮助我们创建响应式的对象，使用方法也比较简单，在data中我们设置一个变量current来记录当前路由。 constructor(options) { // 记录构造函数中传入的options属性 this.options = options // 初始化routerMap，用于记录路由表 this.routerMap = {} // 创建响应式的data对象 this.data = _Vue.observable({ // 当前路由对象,用于记录当前路由 current: '/' }) } createRouterMap 便利路由规则 在上一步我们已经在构造函数中初始化了routerMap对象，这里我们需要写个方法去便利路由规则，然后存储到routerMap中。代码如下： createRouterMap() { // 便利路由规则，吧路由规则挂载到routerMap上 this.$options.router.forEach(item =&gt; { this.routerMap[item.path] = item.component }) } 创建组件 在使用vueRouter时，我们会用到router-link组件和router-view组件，这俩功能就不细说了，创建组件也是比较简单的，vue提供了 Vue.component方法，使用方式如下： initComponents(Vue) { Vue.component('router-link',{ props: { to: String }, render(h) { return h('a',{ attrs: { href: this.to }, },this.$slots.default) }, }) Vue.component('router-view',{ render(h) { // 获取当前路由匹配到的组件 const component = self.routerMap[self.data.current] return h(component) } }) } 创建完成后，我们还需要调用一下，目前初始化函数有两个：便利路由规则方法、创建组件方法，我们可以再写一个init方法，来调用初始化的函数： // 初始化方法 init() { this.createRouterMap() this.initComponents(_Vue) } 同时我们需要在constructor构造函数中调用一下： constructor(options) { this.options = options this.routerMap = {} this.data = _Vue.observable({ current: '/' }) // 初始化方法 this.init() } 接下来我们可以试着在router文件夹中把引入的VueRouter插件改成我们写的插件： // router/index.js import VueRouter from '../vueRouter' 然后运行项目看是否显示成功。 实现点击事件 前面我们已经添加了router-link组件，接下来我们需要点击的时候去更改data中的current来记录当前的路径： Vue.component('router-link',{ props: { to: String }, render(h) { return h('router-link',{ attrs: { href: this.to }, on: { click: this.clickHandler } },this.$slots.default) }, methods: { clickHandler(e) { // 改变url中的路径 history.pushState({}, '', this.to) // 修改响应式data中的current self.data.current = this.to // 阻止a标签默认事件 e.preventDefault() } } }) 我们还需要添加一个监听事件，如果点击浏览器左侧的前进和后退按钮，我们的页面也应该做出相应的变化： initEvent() { window.addEventListener('popstate', () =&gt; { this.data.current = window.location.pathname }) } 最后在init方法中调用一下即可 init() { this.createRouterMap() this.initComponents(_Vue) this.initEvent() } 这样一个小型的vueRouter基本就完成了，hash模式也比较简单，我们只需要把点击事件方法改变一下即可： Vue.component('router-link',{ props: { to: String }, render(h) { return h('router-link',{ attrs: { href: this.to }, on: { click: this.clickHandler } },this.$slots.default) }, methods: { clickHandler(e) { // 判断模式 self.options.mode == 'history' &amp;&amp; history.pushState({}, '', this.to) self.options.mode == 'hash' &amp;&amp; (window.location.hash = `#${this.to}`) self.data.current = this.to e.preventDefault() } } }) 同时修改一下监听事件 initEvent() { if(this.options == 'history') { window.addEventListener('popstate', () =&gt; { this.data.current = window.location.pathname }) }else{ window.addEventListener('hashchange', () =&gt; { this.data.current = window.location.hash.substr(1) ? window.location.hash.substr(1) : '/' }) } } 结尾 这样我们的hash模式和history模式就实现完成了，关于一些细节方面的东西就不进行模拟了，感兴趣的可以尝试实现一下。 ","link":"https://lonjinup.github.io/vuerouter/"},{"title":"TypeScript基础速览","content":"TypeScript TypeScript解决JavaScript类型系统的问题TS大大提高代码的可靠程度。JavaScript自有类型系统的问题，所以我们可以使用TypeScript来健壮我们的代码。首先我们需要了解强类型和弱类型语言的区别。 强类型：语言层面限制函数的实参类型和形参类型类型必须一致，可以说强类型不允许随意的隐式转换。 弱类型：若类型语言不会限制实参的类型，允许隐式类型的转换 前置知识 静态类型与动态类型 静态类型：一个变量声明时它的类型就是明确的，声明过后，他的类型就不允许再修改。 动态类型：在运行阶段才能明确变量类型，变量的类型随时可以改变。也可以说变量是没有类型的，变量中存放的值是有类型的。 JavaScript类型系统特征 JavaScript是弱类型且动态语言，JavaScript早期需求很简答；脚本语言, 没有编译环节。 而强类型的优势在于： 1、错误更早暴露 2、代码更智能，编码更准确 3、重构更牢靠 4、减少不必要的类型判断 TypeScript概述 TypeScript是JavaScript的超集，同时TypeScript功能更强大，生态也健全更完善。说了那么多优点，它的缺点是语言本身多了许多概念（接口、泛型等），在项目初期，TS会增加一些成本。 准备工作(安装与编译) 全局安装 npm install -g typescript //mac下安装前面需要加sudo。也可以在项目中局部安装 编译 可以执行下面命令进行编译，会在当前目录下产生一个test.js文件 tsc test.ts 这样可能还是比较麻烦，我们可以借助插件方便我们提高效率： npm install -g ts-node 安装完后只需执行ts-node test.ts就可以在控制台查看输出结果。 tsconfig.json配置 生成配置文件 我们可以通过tsc --init去生成ts配置文件: tsc --init 编译文件 会生成一个tsconfig.json文件，我们在ts文件中可以随便写点什么： //测试tsconfig.json const test:string='tsconfig.json'; 然后打开tsconfig.json文件，找到complilerOptions属性下的removeComments:true（这个配置是编译后不输出注释），取消掉注释，然后执行命令： tsc 这时候打开生成的js文件，发现没有注释，说明成功。 tsconfig.json配置项 下面给列一下常用的配置项，更多可以查看 配置查询网站 include 、exclude 和 files 如果有多个ts文件，只想编译一个可以在ts配置项中加入include： &quot;include&quot;:[&quot;text.ts&quot;], 如果想除了某个文件不编译，剩下的都编译，可以使用exclude： &quot;exclude&quot;:[&quot;text.ts&quot;], files和include没有什么区别： &quot;files&quot;:[&quot;text.ts&quot;], removeComments 这个配置意思就是编译后不输出注释 strict 这个设置为true,就代表严格执行ts语法，要严格按照ts语法来编写。 noImplicitAny 允许你的注解类型 any 不用特意表明，如果此时设置了true,看例子： //这时候编译会报错 function test(name) { return name; } //正确 function test(name:any) { return name; } strictNullChecks 意思就是，不强制检查null类型,此时如果配置为true看例子: //此时就不会报错 const test: string = null; outDir和rootDir 此项配置是来指定文件目录和打包后存放目录，rootDir为文件目录，outDir为打包后保存的目录 { &quot;outDir&quot;: &quot;./build&quot; , &quot;rootDir&quot;: &quot;./src&quot; , } 编译ES6语法 可以使用target和allowJs，target默认为true &quot;target&quot;:'es5' , // 可以转化为目标标准 &quot;allowJs&quot;:true, // 这个配置项的意思是联通 sourceMap sourceMap简单说，Source map 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。调试的时候就可以使用sourceMap文件来调试ts源代码。 noUnusedLocals 设置noUnusedLocals为true，编译代码： const name:tring='111'; export const age = &quot;text&quot;; 这时候就会报错，因为有name变量没有使用。 原始数据类型 let a:string='lonjin'; let b:number=100; //NaN Infinity let c:boolean=true; let g:void=undefined; //空值,常用于表述没有任何返回值的函数 let h:null=null; let i:undefined=undefined; 在非严格模式（strictNullChecks）下，string, number, boolean 都可以为null let d:string=null; let e:number=null; let f:boolean=null; 如果想使用Symbol,必须在tsconfig.json中修改lib包含ES2015: let j:symbol=Symbol(); 如果想使用console.log,也需要在tsconfig.json中lib中添加dom选项 //tsconfig.json &quot;lib&quot;: [&quot;es2015&quot;,&quot;dom&quot;], //index.ts console.log(111) TypeScript作用域问题 在ts中，默认文件中的成员会作为全局成员，所以多个文件中有相同成员就会出现冲突(尤其在小程序项目中使用ts时)，解决方法如下： 方法1:创建一个立即执行函数，隔离作用域 (function () { const a = 123 })() 方法2:在当前文件使用 export，也就是把当前文件变成一个模块。在小程序中，每个page下的index.ts中如果不写export就会报作用域错误。 const a = 123 export {} TypeScript中Object类型 ts中的Object类型并不单指对象类型，而是泛指非原始类型，也就是对象、数组、还有函数。 // object 类型是指除了原始类型以外的其它类型,所以可以为函数，数组这种值 let obj:object=function(){}; let obj2:object=[1,2,3]; 如果需要明确限制对象类型，则应该使用这种类型对象字面量的语法，或者是「接口」 let obj3:{name:string,age:number}={name:'lonjin',age:18} TypeScript中数组类型 数组类型的两种表示方式: //方式1 let arr:Array&lt;number&gt;=[1,2,3,4,5]; //方式2 let arr2:number[]=[1,2,3,4,5]; 如果数组中又有number类型又有string类型，则可以用｜符号来区别定义 let arr:(number|string)[]=['tom',1]; 项目中经常遇到数组中有对象的存在，可以使用下面方法去定义： let arr:{name:string,age:number}[]=[ {name:'tom',age:18} ] 这样写起来会很麻烦，我们可以使用ts中的类型别名来解决这个问题(后面会详细讲解) type PeopleType={name:String,age:Number}; let arr:PeopleType[]=[ {name:'lonjin',age:18} ] 元组类型 在数组中如果里面又有string和number,可以使用｜来进行定义，但一定程度上并不严格。比如改成下面这种格式： let arr:(number|string)[]=[111,'222',111]; ts并没有报错，如果想要严格限制，则可以使用元组来进行约束，元组就是明确元素数量和类型的一个数组 let arr:[number,string,number]=[111,'222',111]; Enum枚举 平时我们可能需要定义多种状态来表示对应的含义，大多数情况下我们会这么写： const Status={ ONE:0, TWO:1, THREE:2 } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } 这时候枚举就派上用场了： //默认为数字，从0开始 enum Status{ one, two, three, } console.log(Status.one,Status.two,Status.three) //0 1 2 //也可以为字符串 const enum PropStatus{ one='a', two='b', three='c' } console.log(PropStatus.one,PropStatus.two,PropStatus.three) //a b c 细心的童鞋可以看到我在后面的枚举前面加了const，我们编译一下看看有什么不同： var Status; (function (Status) { Status[Status[&quot;one&quot;] = 0] = &quot;one&quot;; Status[Status[&quot;two&quot;] = 1] = &quot;two&quot;; Status[Status[&quot;three&quot;] = 2] = &quot;three&quot;; })(Status || (Status = {})); console.log(Status.one, Status.two, Status.three); console.log(&quot;a&quot; /* one */, &quot;b&quot; /* two */, &quot;c&quot; /* three */); 可以看到，第一个没加const，它编译后会入侵编译结果，而如果使用常量枚举，就不会入侵编译结果。 TypeScript函数类型 函数类型比较简单，主要就是参数的约定以及返回值约定： function fn(num:number,num2:number,...args:number[]):string{ return 'fn' }; fn(1,2) fn(1,2,3) fn(1,2,3,4) 箭头函数： const fn4=(a:number,b:number):string=&gt;{ return 'lonjin' } 可选参数和默认参数： function fn2(a:number,b?:number,c:number=4,...agrs:number[]){ console.log(a,b,c,agrs) } fn2(1,2)//1 2 4 [] fn2(1,2,3)//1 2 3 [] fn2(1,2,3,4,5)//1 2 3 [ 4, 5 ] TypeScript任意类型 很多场景下我们并不需要对类型有明确的约束，这时候就可以使用any，any虽好，可不要过度使用哦！ function fn(val:any){ console.log(val) } //可以传任意类型 fn(1) fn('lonjin') fn(true) TypeScript隐式类型推断 隐式类型推断很好理解，如果我们在声明一个变量时候没有定义它的类型，ts根据变量后的值进行类型推断： let n=100; //相当于 let n:number=100; 如果我们在声明时候没有赋值，则会被推断为any： let n; // 相当于 let n:any;可以赋值任意类型数据 n=100; n='lonjin'; n=true; TypeScript类型断言 在实际场景中，我们可能会遇到以下情况：从接口中获取到一个数组，数组中存放的都是都是数字，我们需要取到某个值然后再进行一系列的计算： //接口中返回的数组 let arr=[1,2,3,4,5]; let num=arr.find(n=&gt;n&gt;4); //报错：ts并不确定num是不是一个number let num: number | undefined let num2=num+1 这时候我们就可以使用类型断言进行处理，告诉ts这确定是一个数字 let arr=[1,2,3,4,5]; let num =arr.find(n=&gt;n&gt;4); let num2=num as number let num3=num2+1 断言除了as，还有另外一种书写方法： let arr=[1,2,3,4,5]; let num =arr.find(n=&gt;n&gt;4); let num3=&lt;number&gt;num+1 TypeScript接口 接口主要约束对象中的数据类型，基本使用如下： interface People{ name:string, age:number, } const people:People={ name:'lonjin', age:18 } 很多情况下，我们可能确定不了是否会有某个值，这时候我们就需要使用可选参数了： interface People{ name:string, age:number, sex?:boolean, } const people:People={ name:'lonjin', age:18, } 有时候我们根本不知道这个对象中要放什么，可以理解为动态场景，可以给对象任意添加一些数值： interface People{ name:string, [prop:string]:any }; const people:People={ name:'lonjin', }; people.say=function(){ console.log('hello') }; people.home='beijing' 如果我们希望某些值设置为只读，可以在接口中加入修饰符readonly: interface People{ name:string, age:number, readonly hasCar:boolean, } const people:People={ name:'lonjin', age:18, hasCar:false } //报错：无法分配到 &quot;hasCar&quot; ，因为它是只读属性。 people.hasCar=true; TypeScript类的基本使用 基本使用比较简单，我们直接看代码： class People{ class People{ name:string; age:number; constructor(name:string,age:number){ this.name=name; this.age=age; } say(message:string):void{ console.log(`my name is ${this.name},${message}`) } } let tom=new People('tom',18) 类的修饰符 在类中，一共有三个修饰符： pubilc:公有成员,如果没有加修饰符，则默认为pubilc。 private:只能在成员方法内部访问 protected:也不能在外部访问，和private的区别就是，protected是只允许在子类中访问成员 class People{ public name:string; private age:number; protected sex:boolean; constructor(name:string,age:number){ this.name=name; this.age=age; this.sex=true; } say(message:string):void{ console.log(`my name is ${this.name},${message}`) } } class Son extends People{ constructor(name:string,age:number){ super(name,age); console.log(this.sex)//true } } 除了上面提到的，还可以设置只读属性readonly。顾名思义，只允许读取，不允许修改。如果前面有修饰符，就跟在修饰符后面： public name:string; private age:number; protected readonly sex:boolean;//只读属性 constructor(name:string,age:number){ this.name=name; this.age=age; this.sex=true; } say(message:string):void{ console.log(`my name is ${this.name},${message}`) } } 类与接口 如果类与类之间有共同特性，可以使用类来进行抽离，举个例子，人会吃东西，也会跑，车只会跑，但不会吃东西，所以我们可以把这些抽离出来： interface Eat{ eat(food:string):void; } interface Run{ run(type:string):void; } class People implements Eat,Run{ eat(food:string):void{ console.log(`eat ${food}`) }; run(type:string){ console.log(`people ${type}`) } } class Car implements Run{ run(type:string):void{ console.log(`car is ${type}`) } } 抽象类 抽象类也用来约束子类当中某些成员，与接口不同的是，抽象类可以包含具体的实现,也可以只约束方法，具体例子如下： //抽象类 abstract class Eat{ eat(food:string):void{ console.log(`eat ${food}`) } //约束People中必须有run方法 abstract run(type:number):void; } class People extends Eat{ run(type: number): void { console.log(`run ${type}`) } } let tom=new People(); tom.eat('foods'); tom.run(100) 泛型 泛型就是在定义函数、接口、或者类的时候没有具体定义类型，在使用时候才进行定义： //比如我们写一个函数，函数中接收两个值，最终return一个数组回去，我们接收的参数可能是字符串，也可能是数字 function add&lt;T&gt;(n:T,m:T):T[]{ let a=[n,m]; return a; } let str=add&lt;number&gt;(1,2) let num=add&lt;string&gt;('one','two') ","link":"https://lonjinup.github.io/typescript-ji-chu-su-lan/"},{"title":"ES6新特性速览","content":"ES6新特性速览 虽然ES6现在基本都是前端必会内容了，网上也一堆文章了，但有些初学者可能看完还是记不住，所以便写一篇文章快速过一下ES6的一些新特性，加深印象。如果你还没有学ES6，还是推荐你阅读一下阮一峰的ES6入门指南。 ☀️如果觉得文章不错，欢迎点赞❤️、关注🌟、收藏📄！ 🚀ES6的新特性，大致可以归为4大类： 解决原有语法上的一些问题或者不足 对原有语法进行增强 全新的对象、全新的方法、全新的功能 全新的数据类型和数据结构（symbol、set、map、etc.） 块级作用域 作用域——某个成员能够起作用的范围,在ES2015之前，只有两种作用域：全局作用域和函数作用域。在ES2015中新增：块级作用域. //var 会变量提升，所以值会是undefined console.log(a);//undefined var a=1; //let 不会进行变量提升 console.log(b)//Cannot access 'b' before initialization let b=2; //块级作用域 { let c=20; } console.log(c) //c is not defined //const 申明时候必须赋值，且声明之后不可修改值，但可以修改对象中的某个值, //const 和let一样，也存在块级作用域 const a={name:'lonjin'}; a.name='tom'; console.log(a)//{ name: 'tom' } 经典面试题： for(var i=1;i&lt;6;i++){ setTimeout(() =&gt; { console.log(i) }, 0); } // 6 6 6 6 6 for(let i=1;i&lt;6;i++){ setTimeout(() =&gt; { console.log(i) }, 0); } // 1 2 3 4 5 数组的解构 基本使用 const arr=[1,2,3,4,5]; const [a, b, c] = arr; console.log(a,b,c) //1 2 3 只获取数组中第三个成员，方法，前面两个用逗号隔开，只声明第三个 const arr=[1,2,3]; const [,,c]=arr; console.log(c) //3 提取数组当前位置开始的所有成员(注意：三个点的用法只能在解构成员的最后使用) const arr=[1,2,3,4,5]; const [a,...arr2]=arr; console.log(arr2) //[ 2, 3, 4, 5 ] 可以给提取到的成员设置默认值，如果没有提取到值，就会赋为默认值 const arr=[1,2,3,4,5]; const [a,b,c,d,e,f=6]=arr; console.log(f) //6 对象的解构 基本使用(和数组解构基本相同) const data={name:&quot;lonjin&quot;,age:18}; const {name}=data; console.log(name) //lonjin 如果解构过程中遇到命名重复，可使用重命名的方式解决；设置默认值方法如下： const data={name:&quot;lonjin&quot;,age:18}; const name='tom'; const {name:newName}=data; console.log(newName) //lonjin 同样也可以设置默认值 const data={name:&quot;lonjin&quot;,age:18}; const name='tom'; const {name:newName,say='hello'}=data; console.log(newName+','+say) //lonjin,hello 解构常用方法，如console.log const {log}=console; log(1)//1 模版字符串 反引号定义字符串，若字符串中需要有反引号，可以用\\反斜杠转义 支持字符串中直接换行 支持插值表达式写法 `hello, ${name} const name='lonjin'; const text=`hello ${name} \\nuser age ${17+1}`; console.log(text) /* hello lonjin user age 18 */ 带标签的模板字符串 标签模板字符串的作用：是对我们的模板字符串进行加工处理，然后返回新内容 const name='lonjin', sex=true, age=18; function fn(strings,...args){ //string为text中普通string数组 console.log(strings) //[ 'my name is ', ',my age', ',my sex', '' ] //args为插值表达式中的值 console.log(args) // [ 'lonjin', 18, true ] //可以处理完数据return出去 let sex=args[2]?'man':woman; return strings[0]+args[0]+strings[1]+args[1]+strings[2]+sex } const text=fn`my name is ${name}my age${age}my sex ${sex}`; console.log(text) //my name is lonjinmy age18my sex man 字符串的扩展方法 includes():判断一个字符串是否包含在另一个字符串中,返回true或者false const str='erro type end.'; let f1=str.includes('erro'); console.log(f1)//true startsWith():判断当前字符串是否以另外一个给定的子字符串开头，返回true或者false const str='erro type end.'; let f2=str.startsWith('erro'); console.log(f2) //true endsWith:判断当前字符串是否以另外一个给定的子字符串结尾，返回true或者false const str='erro type end.'; let f3=str.endsWith('.'); console.log(f3) //true 参数默认值 函数参数默认值 function fn(status=false){ console.log(status) } fn(true) fn() /* true false */ 剩余参数 只能出现在最后，且只能使用一次 function fn(...args){ console.log(args) }; fn(1,2,3,4,5) //[ 1, 2, 3, 4, 5 ] 展开数组 想依次打印数组的值 let arr=['a','b','c']; console.log(...arr); //a b c 箭头函数 基本使用 //普通函数 function fn(num){ return num+1 }; console.log(fn(2)) //3 //箭头函数 const fn2=n=&gt;n+1; console.log(fn2(2))//3 箭头函数的this 箭头函数不会改变this指向，也就是说在箭头函数的外面拿到的this是什么，在箭头函数内部拿到的this也就是什么。 const name='tom' const people={ name:'lonjin', say(){ console.log(`this name is ${this.name}`) }, say2:()=&gt;{ console.log(`this name is ${this.name}`) } } people.say();//this name is lonjin people.say2()//this name is undefined 对象的扩展 对象字面量的增强 对象中属性名和属性值相同就可以缩写 函数表达式也可以缩写 动态属性名，可以直接使用计算属性名，使用方括号的形式使用 const username='lonjin'; const people={ age:18, username, [Math.random()]:123, } console.log(people) //{ age: 18, username: 'lonjin', '0.3692996732470484': 123 } Object.assign 将多个源对象中的属性复制到一个目标对象中；第一个参数为目标对象，如果有相同的，后面的会覆盖之前的值。 let obj={ a:123, b:456, } let obj2={ a:789, c:234 } let obj3={ d:123, c:678 } // const n=Object.assign(obj,obj2) //console.log(n)//{ a: 789, b: 456, c: 234 } const m=Object.assign(obj,obj2,obj3); console.log(m) //{ a: 789, b: 456, c: 678, d: 123 } Object.is 判断两个对象是否相等，和严格相等运算符(===)类似,但有两个值他们判断起来不太一样:+0与-0、NaN console.log( //0==false //true //+0 === -0 // true // NaN === NaN //false //Object.is(NaN,NaN) //true Object.is(+0,-0) //false ) Proxy 代理对象:为对象设置访问代理器 const people={ name:&quot;lonjin&quot;, age:18, } let peopleProxy=new Proxy(people,{ //监听读取 get(target,property){ // target为对象 // property为要读取的键 console.log(target,property) //{ name: 'lonjin', age: 18 } name //返回读取的内容 return property in target?target[property]:'none' }, //监听属性设置 set(target,property,value){ /*target---目标对象 property---要设置的键名 value---要设置的新值 */ if(property=='age'){ if(!Number.isInteger(value)){ throw new TypeError('Value must be a number') } } target[property]=value } }) console.log(peopleProxy.name)//lonjin console.log(peopleProxy.say)//none // peopleProxy.age='28';//throw new TypeError('Value must be a number') peopleProxy.age=20; defineProperty和Proxy的区别 defineProperty只能监视属性的读写，Proxy能够见识到更多对象操作。比如属性的删除： const people={ name:&quot;lonjin&quot;, age:18, }; let peopleProxy=new Proxy(people,{ deleteProperty(target,property){ //target 为代理对象 //property 为要删除的键名 delete target[property] } }); delete peopleProxy.age; console.log(peopleProxy) //{ name: 'lonjin' } Proxy更好的支持数组对象的监视,vue3中就采用了Proxy来实现数据监听 //监听数组push操作 let arr=[]; let newArray=new Proxy(arr,{ set(target,property,value){ target[property]=value; return true } }); newArray.push(1); newArray.push(2); console.log(newArray) //[1,2] 更多操作就不在这里写了，推荐大家一篇文章你不知道的 Proxy可以看一下。 Reflect Reflect成员方法就是Proxy处理对象的默认实现，Reflect并非一个构造函数，所以不能通过new()来调用。 let people={ name:'lonjin', say:'hello', } let peopleProxy=new Proxy(people,{ //如果我们没有定义get方法，那么Proxy会默认一个get方法如下，返回Reflect get(target,property){ return Reflect.get(target,property) } }) Reflect最大作用是提供了一套完整的对象调用方法 let people={ name:'lonjin', say:'hello', } console.log('name' in people) console.log(Reflect.has(people,'name')) console.log(delete people['say']); console.log(Reflect.deleteProperty(people,'say')); console.log(Object.keys(people)); console.log(Reflect.ownKeys(people)); Reflect一共有13个静态方法，更多查看MDN-Reflect Class 基本使用 class People{ constructor(name){ this.name=name } say(){ console.log(`this name ${this.name}`) } }; let user=new People('lonjin'); user.say() //this name lonjin 静态方法 静态方法可以直接通过类型本身去调用，而实例方法需要通过这个类型构造的实例对象去调用，只需要在方法前面加static constructor(name){ this.name=name } say(){ console.log(`this name ${this.name}`) } static created(name){ return new People(name) } }; let user=People.created('lonjin'); user.say() //this name lonjin class的继承 class继承只需要用关键词extends实现，super为父类构造函数 class People{ constructor(name){ this.name=name } say(){ console.log(`this name ${this.name}`) } }; class Child extends People{ constructor(name,age){ super(name); this.age=age; } message(){ console.log(`my name is${this.name},my age is ${this.age}`) } }; let tom=new Child('tom',18); tom.message(); //static Set数据结构 set的内部成员是不允许重复的，也就是每一个值在set中都是唯一的。我们平时可以利用Set来实现数组去重 //基本使用 let setArray=new Set(); setArray.add(1); setArray.add(2); setArray.add(3); setArray.add(4); setArray.add(4); console.log(setArray) //Set(4) { 1, 2, 3, 4 } //遍历 setArray.forEach(i=&gt;{console.log(i)}); //1 2 3 4 //获取数量 console.log(setArray.size) //4 //删除(返回true或者false) console.log(setArray.delete(1))//true //判断是否有某个值(返回true或者false) console.log(setArray.has(3))//true //清空 setArray.clear(); 数组去重 Array.from+set //方法1 let arr=[1,2,3,4,5,5,6]; let newArr=Array.from(new Set(arr)); console.log(newArr) //[ 1, 2, 3, 4, 5, 6 ] 展开运算符 let arr=[1,2,3,4,5,5,6]; console.log([...new Set(arr)]); //[ 1, 2, 3, 4, 5, 6 ] Map js的对象本质上是键值对的集合，但是传统上只能用字符串当作键。所以ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。与对象最大的区别就是可以使用任意类型作为键，而对象只能使用字符串作为键 let m=new Map(); let n={name:'tom'}; // 设置值 m.set(n,18) //读取值 console.log(m.get(n))//18 //判断是否有某个值 // m.has(); //删除 // m.delete() //清空 // m.clear() //遍历 m.forEach((val,key)=&gt;{ console.log(val,key) }) Symbol 一种全新的原始数据类型， 表示一个独一无二的值。主要解决对象中属性名冲突的问题 //创建一个独一无二的属性名，且外部无法访问到(模拟私有成员) let name=Symbol(); let people={ [name]:'lonjin', say(){ console.log(this[name]) } }; people.say()//lonjin 如果我们希望重新使用同一个Symbol值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局 //全局注册表 let n1=Symbol.for('name'); let n2=Symbol.for('name'); console.log(n1===n2)//true 获取对象中的键时候，如果使用for in，就获取不到Symbol类型的键；必须使用Object.getOwnPropertySymbols()进行获取。 let people={ [Symbol()]:'tom', age:18 } console.log(Object.keys(people)) console.log(JSON.stringify(people)) console.log(Object.getOwnPropertySymbols(people)) /* [ 'age' ] {&quot;age&quot;:18} [ Symbol() ] */ for of方法 ES6借鉴其他语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。 遍历数组 let arr=[1,2,3,4,5]; for(const item of arr){ console.log(item) } //1 2 3 4 5 可以使用break进行退出 //可以使用break进行退出 let arr=[1,2,3,4,5]; for(const item of arr){ console.log(item) if(item&gt;3){ break } } //1 2 3 4 遍历Set let n=new Set([1,2,3,4]); for(const item of n){ console.log(item) } //1 2 3 4 遍历Map可以配合数组结构语法，直接获取键值 let n=new Map(); n.set('name','tom'); n.set('age',18); for(const [key,value] of n){ console.log(key+'----'+value) } /* name----tom age----18 */ 可迭代接口 ES6提供了Iterable接口，实现了Iterable接口就是for...of的前提 let arr=new Set([1,2,3,4,5]); const iterator=arr[Symbol.iterator](); console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) /* { value: 1, done: false } { value: 2, done: false } { value: 3, done: false } { value: 4, done: false } { value: 5, done: false } { value: undefined, done: true } */ 实现可迭代接口 由于for...of方法不能便利普通对象，我们可以手动实现一下 const obj = { store: ['foo', 'bar', 'baz'], [Symbol.iterator]: function () { let index = 0 const self = this return { next: function () { const result = { value: self.store[index], done: index &gt;= self.store.length } index++ return result } } } } for(const item of obj){ console.log(item) } //foo bar baz 迭代器模式 开发一个任务清单应用 // 迭代器设计模式 const todos = { life: ['吃饭', '睡觉', '打豆豆'], learn: ['语文', '数学', '外语'], work: ['喝茶'], // 提供统一遍历访问接口 each: function (callback) { const all = [].concat(this.life, this.learn, this.work) for (const item of all) { callback(item) } }, // 提供迭代器（ES2015 统一遍历访问接口） [Symbol.iterator]: function () { const all = [...this.life, ...this.learn, ...this.work] let index = 0 return { next: function () { return { value: all[index], done: index++ &gt;= all.length } } } } } Generator Generator函数是ES6提供的一种异步编程解决方案,来避免异步编程中回调嵌套过深。 基本使用 function * fn(){ console.log('1') yield 100 console.log('2') yield 200 console.log('3') yield 300 } const f=fn(); console.log(f.next()) console.log(f.next()) console.log(f.next()) console.log(f.next()) /* 1 { value: 100, done: false } 2 { value: 200, done: false } 3 { value: 300, done: false } { value: undefined, done: true } */ 使用 Generator 函数实现 iterator 方法 const todos = { life: ['吃饭', '睡觉', '打豆豆'], learn: ['语文', '数学', '外语'], work: ['喝茶'], [Symbol.iterator]: function * () { const all = [...this.life, ...this.learn, ...this.work] for (const item of all) { yield item } } } for (const item of todos) { console.log(item) } ","link":"https://lonjinup.github.io/es6-xin-te-xing-su-lan/"},{"title":"手写Promise太难？拆封组合法你也可以手写Promise","content":"手写Promise太难？拆封组合法你也可以手写Promise 现在面试也越来越内卷了，动不动就手写各种源码。当然手写源码不是目的，可能就是为了考察对知识的掌握程度。很多人一听到手写Promise就头大，毫无思路，其实我们把Promise功能需求拆封一下，分步骤实现；写起来就相对简单了，并且易于理解，下面就带大家手写一个Promise。 ☀️阅读小提示：本文看起来篇幅很长，因为每部分都贴出了完整代码，所以代码量比较大。每个步骤新增/修改的代码部分都会标明步骤和思路，跟着步骤阅读即可。耐心看完，相信会有收获！ Promise基本逻辑实现 先贴代码，分析一下： new Promise((resolve,reject)=&gt;{ console.log('LonJIn带你手写Promise'); resolve('hello') }).then((res)=&gt;{ console.log(res) }) 核心逻辑分析 首先，我们看到Promise前面调用了new，说明Promise是一个类 它有三种状态：等待(pending)、成功(fulfilled)、失败(rejected)，状态一旦从pending变成fulfilled或rejected就不可更改 在new Promise中传入了一个函数，我们可以把它称之为执行器，执行器会立即执行 在执行器中传入了resolve和reject,用来改变它的状态 then方法内部做的事情就是判断状态，如果状态是成功，调用成功回调函数,如果状态是失败，就调用失败回调函数,且then方法会接收一个成功或者失败的值。 代码实现 我们先建立一个MyPromise.js文件，在这个文件中编写我们的Promise。 //定义三个常量 const PENDING='pending', //等待 FULFILLED='fulfilled', //成功 REJECTED='rejected'; //失败 class MyPromise{ constructor(exector){ // 立即执行函数，传入resolve方法和reject方法 exector(this.resolve,this.reject) }; //定义一个初始状态 status=PENDING; //保存成功后的值 value=undefined; //保存失败后的值 reason=undefined; //成功 resolve=value=&gt;{ //判断当前状态是否为PENDING，如果不是就return if(this.status!==PENDING)return; //更改状态为fulfilled this.status=FULFILLED; //保存成功的返回值 this.value=value; }; //失败 reject=reason=&gt;{ //判断当前状态是否为PENDING，如果不是就return if(this.status!==PENDING)return; //更改状态为rejected this.status=REJECTED; //保存失败的返回值 this.reason=reason; }; //then方法会接收两个回调函数，分别为成功和失败的回调函数 then(successCallback,failCallback){ //判断当前状态，然后调用相应的函数 if(this.status===FULFILLED){ //传入返回值 successCallback(this.value) }else if(this.status===REJECTED){ //传入返回值 failCallback(this.reason) } } } //导出MyPromise module.exports = MyPromise 我们上面分析的基本完成，新建一个index.js导入测试一下： //index.js const MyPromise=require('./MyPromise'); let n=new MyPromise((resolve,reject)=&gt;{ console.log('lonjin'); resolve(200) // reject('erro') }) n.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro) }) //lonjin //200 调用之后可以正常输出，说明之前写的没有问题，但还有个问题：我们没有考虑异步的时候该怎么办？比如下面的代码： //index.js const MyPromise=require('./MyPromise'); let n=new MyPromise((resolve,reject)=&gt;{ //由于setTimeout为异步代码，then会马上执行，但此时状态还为pending之前并没有判断等待这个状态 setTimeout(() =&gt; { resolve(200) }, 100); }) n.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro) }) 处理异步调用 由于执行器可能有异步代码，所以我们在then方法中还需要判断一下状态，然后做相应的处理 代码如下(为了思路清晰，只对做更改的地方加注释，会标注实现步骤，按步骤阅读即可): const PENDING='pending', FULFILLED='fulfilled', REJECTED='rejected'; class MyPromise{ constructor(exector){ exector(this.resolve,this.reject) }; status=PENDING; value=undefined; reason=undefined; //定义一个成功回调函数 successCallback=undefined; //定义一个失败回调函数 failCallback=undefined; resolve=value=&gt;{ if(this.status!==PENDING)return; this.status=FULFILLED; this.value=value; /* 步骤2 ------------------------------------------------- 判断成功回调是否存在，如果存在，直接调用 */ this.successCallback &amp;&amp; this.successCallback(this.value) }; reject=reason=&gt;{ if(this.status!==PENDING)return; this.status=REJECTED; this.reason=reason; /* 步骤3 ------------------------------------------------- 判断失败回调是否存在，如果存在，直接调用 */ this.failCallback &amp;&amp; this.failCallback(this.reason) }; then(successCallback,failCallback){ if(this.status===FULFILLED){ successCallback(this.value) }else if(this.status===REJECTED){ failCallback(this.reason) }else{ /* 步骤1 ------------------------------------------------- 等待状态，处理异步逻辑 由于不知道状态，所以我们需要把成功和失败的回调函数先保存起来 保存回调函数 */ this.successCallback=successCallback; this.failCallback=failCallback; } } } //导出MyPromise module.exports = MyPromise 验证代码： //index.js const MyPromise=require('./MyPromise'); let n=new MyPromise((resolve,reject)=&gt;{ //由于setTimeout为异步代码，then会马上执行，但此时状态还为pending之前并没有判断等待这个状态 setTimeout(() =&gt; { resolve(200) }, 100); }) n.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro) }) 我们可以看到代码可以正常输出，异步就算处理完成。 实现then()多次调用 Promise的then方法是可以被多次调用的。如果是同步回调，那么直接返回当前的值就行；如果是异步回调，那么保存的成功失败的回调，需要用不同的值保存，因为都互不相同。所以之前的代码需要改造一下。 //index.js const MyPromise=require('./MyPromise'); let n=new MyPromise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(200) }, 100); }) //多次调用的情况 目前只会输出一次 n.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro) }) n.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro) }) n.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro) }) 代码实现 为了解决多次调用的情况，之前我们定义了一个successCallback回调函数，默认为undefined,这时候我们需要把它改成数组形式，在resolve或reject回调函数中取数组最后一个保存的回调执行即可 const PENDING='pending', FULFILLED='fulfilled', REJECTED='rejected'; class MyPromise{ constructor(exector){ exector(this.resolve,this.reject) }; status=PENDING; value=undefined; reason=undefined; /* 步骤1 ------------------------------------- 将successCallback和failCallback改成数组 */ successCallback=[]; failCallback=[]; resolve=value=&gt;{ if(this.status!==PENDING)return; this.status=FULFILLED; this.value=value; /* 步骤3 ------------------------------------- 判断successCallback数组中是否有值，有值的话就取数组最后的执行 */ while(this.successCallback.length)this.successCallback.shift()(this.value) }; reject=reason=&gt;{ if(this.status!==PENDING)return; this.status=REJECTED; this.reason=reason; /* 步骤4 ------------------------------------- 判断failCallback数组中是否有值，有值的话就取数组最后的执行 */ while(this.failCallback.length)this.failCallback &amp;&amp; this.failCallback.shift()(this.reason) }; then(successCallback,failCallback){ if(this.status===FULFILLED){ successCallback(this.value) }else if(this.status===REJECTED){ failCallback(this.reason) }else{ /* 步骤2 ------------------------------------- 将successCallback和failCallback函数push到数组中 */ this.successCallback.push(successCallback); this.failCallback.push(failCallback); } } } module.exports = MyPromise 验证代码： //index.js const MyPromise=require('./MyPromise'); let n=new MyPromise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(200) }, 500); }) n.then((val)=&gt;{ console.log('one-'+val) },(erro)=&gt;{ console.log(erro) }) n.then((val)=&gt;{ console.log('two-'+val) },(erro)=&gt;{ console.log(erro) }) n.then((val)=&gt;{ console.log('three-'+val) },(erro)=&gt;{ console.log(erro) }) /* one-200 two-200 three-200 */ 代码正常输出，证明无问题。 实现then方法的链式调用 还是先理一下需求，再进行开发： then方法的链式调用会返回一个Promise，且then方法的return值会作为参数传给下一个then 代码实现 const PENDING='pending', FULFILLED='fulfilled', REJECTED='rejected'; class MyPromise{ constructor(exector){ exector(this.resolve,this.reject) }; status=PENDING; value=undefined; reason=undefined; successCallback=[]; failCallback=[]; resolve=value=&gt;{ if(this.status!==PENDING)return; this.status=FULFILLED; this.value=value; while(this.successCallback.length)this.successCallback.shift()(this.value) }; reject=reason=&gt;{ if(this.status!==PENDING)return; this.status=REJECTED; this.reason=reason; while(this.failCallback.length)this.failCallback &amp;&amp; this.failCallback.shift()(this.reason) }; then(successCallback,failCallback){ /* 步骤1 ------------------------ 1.then方法会返回一个Promise,所以这里需要创建一个Promise，然后return回去 2. 我们先把 成功回调函数保存为n 3.然后在MyPromise类的外部再写一个resolvePromise做处理 */ let prmoise2=new MyPromise((resolve,reject)=&gt;{ if(this.status===FULFILLED){ //保存成功回调函数 let n=successCallback(this.value) //传入resolvePromise函数中去做判断 resolvePromise(n,resolve,reject) }else if(this.status===REJECTED){ failCallback(this.reason) }else{ this.successCallback.push(successCallback); this.failCallback.push(failCallback); } }); return prmoise2; } } /* 步骤2 --------------------------- //判断x是不是其实例的对象 */ function resolvePromise(n,resolve,reject){ // 判断x是不是其实例对象，如果是就直接调用then方法 if(n instanceof MyPromise){ n.then(resolve,reject) }else{ //普通值，直接调用resolve resolve(n) } } module.exports = MyPromise 🚀验证代码 const MyPromise=require('./MyPromise'); let n=new MyPromise((resolve,reject)=&gt;{ resolve('lonjin') }) function m(){ return new MyPromise((resolve,reject)=&gt;{ console.log('------') resolve('hello') }) } n.then((res)=&gt;{ console.log(res) return m(); }) .then((res)=&gt;{ console.log(res) }) /* lonjin ------ hello */ ⚠️特殊情况处理 1️⃣ 如果then方法返回的是自己的promise对象，则会发生promise的嵌套，这个时候程序会报错,如下代码： var promise = new Promise((resolve, reject) =&gt; { resolve(100) }) var n = promise.then(value =&gt; { console.log(value) return n }) // 100 // Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt; 2️⃣ 同时还要处理一种情况，如果我们在new MyPromise中传入的立即执行器中代码报错，以及then()中写的代码报错，我们都需要捕获到，然后执行reject 3️⃣ 之前一直是处理resolve的情况，还需要处理一下reject的情况 这时候我们需要改造一下刚才写的代码： const PENDING='pending', FULFILLED='fulfilled', REJECTED='rejected'; class MyPromise{ /* 步骤1 ------------------- 捕获一下立即执行器中的错误 */ constructor(exector){ try{ exector(this.resolve,this.reject) }catch(e){ reject(e) } }; status=PENDING; value=undefined; reason=undefined; successCallback=[]; failCallback=[]; resolve=value=&gt;{ if(this.status!==PENDING)return; this.status=FULFILLED; this.value=value; /* 步骤6 ------------- 由于修改了下面的successCallback，所以不需要传递this.value */ while(this.successCallback.length)this.successCallback.shift()() }; reject=reason=&gt;{ if(this.status!==PENDING)return; this.status=REJECTED; this.reason=reason; /* 步骤7 ------------- 由于修改了下面的failCallback，所以不需要传递this.reason */ while(this.failCallback.length)this.failCallback &amp;&amp; this.failCallback.shift()() }; then(successCallback,failCallback){ let prmoise2=new MyPromise((resolve,reject)=&gt;{ if(this.status===FULFILLED){ /* 步骤2 --------------------- 因为new Promise需要执行完成之后才有promise2，同步代码中没有pormise2， 所以这部分代码需要异步执行 ，我们把prmoise2传入resolvePromise函数中 去判断一下prmoise2是否等于n，同时需要捕获一下错误 */ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else if(this.status===REJECTED){ /* 步骤3 --------------------- 处理一下失败的情况 */ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else{ /* 步骤5 --------------------- 修改一下异步情况 */ this.successCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); this.failCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); } }); return prmoise2; } } function resolvePromise(prmoise2,n,resolve,reject){ /* 步骤4 ---------------- 如果n和prmoise2相等 则返回错误提示 */ if(prmoise2===n){ return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } // 判断x是不是其实例对象 if(n instanceof MyPromise){ n.then(resolve,reject) }else{ //普通值，直接调用resolve resolve(n) } } //导出MyPromise module.exports = MyPromise 🚀验证代码 //验证1 //index.js const MyPromise = require('./myPromise') var promise = new MyPromise((resolve, reject) =&gt; { resolve(100) }) var p1 = promise.then(value =&gt; { console.log(value) return p1 }) p1.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro.message) }) // 100 // Chaining cycle detected for promise #&lt;Promise&gt; //验证2 var errofn = new MyPromise((resolve, reject) =&gt; { throw new Error('执行器抛出异常！') }) errofn.then((val)=&gt;{ console.log(val) },(erro)=&gt;{ console.log(erro) }) // 执行器错误 将then方法的参数变成可选参数 我们知道，调用then()时候也可以不传递任何参数，如下面这种情况 let promise =new Promise((resolve,reject)=&gt;{ resolve('lonjin') }) promise.then().then().then((value)=&gt;{ console.log(value) }) //lonjin 相当于这样： promise .then(value =&gt; value) .then(value =&gt; value) .then(value =&gt; value) .then(value =&gt; console.log(value)) 所以我们要把then方法的参数改为可选参数，如果有参数就传入，如果没有返回value: 代码实现 const PENDING='pending', FULFILLED='fulfilled', REJECTED='rejected'; class MyPromise{ constructor(exector){ try{ exector(this.resolve,this.reject) }catch(e){ reject(e) } }; status=PENDING; value=undefined; reason=undefined; successCallback=[]; failCallback=[]; resolve=value=&gt;{ if(this.status!==PENDING)return; this.status=FULFILLED; this.value=value; while(this.successCallback.length)this.successCallback.shift()() }; reject=reason=&gt;{ if(this.status!==PENDING)return; this.status=REJECTED; this.reason=reason; while(this.failCallback.length)this.failCallback &amp;&amp; this.failCallback.shift()() }; then(successCallback,failCallback){ /*步骤1 ---------------- 判断参数是否存在 */ successCallback=successCallback?successCallback:value=&gt;value; failCallback=failCallback?failCallback:reason=&gt;{throw reason}; let prmoise2=new MyPromise((resolve,reject)=&gt;{ if(this.status===FULFILLED){ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else if(this.status===REJECTED){ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else{ this.successCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); this.failCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); } }); return prmoise2; } } function resolvePromise(prmoise2,n,resolve,reject){ if(prmoise2===n){ return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } if(n instanceof MyPromise){ n.then(resolve,reject) }else{ resolve(n) } } module.exports = MyPromise 🚀验证代码 const MyPromise = require('./myPromise') let promise =new MyPromise((resolve,reject)=&gt;{ resolve('lonjin') }) promise.then().then().then((value)=&gt;{ console.log(value) }) //lonjin Promise.all()方法实现 还是先分析一下all方法： function fn1(){ return new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve('fn1') }, 3000); }) } function fn2(){ return new Promise((resolve,reject)=&gt;{ resolve('fn2') }) } Promise.all(['a','b',fn1(),fn2(),'e']) .then((res)=&gt;{ console.log(res) },(erro)=&gt;{ console.log(erro) }) //[ 'a', 'b', 'fn1', 'fn2', 'e' ] all方法接收一个数组，其内部可以传入普通值和Promise对象 all方法返回的也是一个Promise对象，其返回值为一个数组 all方法中传入的Promise对象，如果都是成功，返回为成功，如果有一个失败，就会走失败的回调函数 分析完代码，我们就可以进行编写了，具体代码如下： 代码实现 const PENDING='pending', FULFILLED='fulfilled', REJECTED='rejected'; class MyPromise{ constructor(exector){ try{ exector(this.resolve,this.reject) }catch(e){ reject(e) } }; status=PENDING; value=undefined; reason=undefined; successCallback=[]; failCallback=[]; resolve=value=&gt;{ if(this.status!==PENDING)return; this.status=FULFILLED; this.value=value; while(this.successCallback.length)this.successCallback.shift()() }; reject=reason=&gt;{ if(this.status!==PENDING)return; this.status=REJECTED; this.reason=reason; while(this.failCallback.length)this.failCallback &amp;&amp; this.failCallback.shift()() }; then(successCallback,failCallback){ successCallback=successCallback?successCallback:value=&gt;value; failCallback=failCallback?failCallback:reason=&gt;{throw reason}; let prmoise2=new MyPromise((resolve,reject)=&gt;{ if(this.status===FULFILLED){ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else if(this.status===REJECTED){ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else{ this.successCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); this.failCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); } }); return prmoise2; }; /* all()实现all方法 */ static all(array){ // 要返回的数组 let result=[]; //记录执行次数 let index=0; //all方法返回的也是一个promise return new MyPromise((resolve,reject)=&gt;{ //定义一个存到result数组中的方法 function addItem(key,value){ result[key]=value; index++; //如果index等于传入array的长度，说明执行完成 if(index==array.length){ resolve(result) } } //循环array for(let i=0;i&lt;array.length;i++){ //当前的参数 let current=array[i]; //判断一下当前的返回值是普通值还是promise if(current instanceof MyPromise){ current.then(value=&gt;addItem(i,value),reason=&gt;reject(reason)); }else{ addItem(i,current) } } }) } } function resolvePromise(prmoise2,n,resolve,reject){ if(prmoise2===n){ return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } if(n instanceof MyPromise){ n.then(resolve,reject) }else{ resolve(n) } } module.exports = MyPromise Promise.resolve()方法实现 resolve方法可以接受一个prmoise对象，也可以接收一个普通值，如果是普通值需要包装成一个prmoise返回。 代码实现 const PENDING='pending', FULFILLED='fulfilled', REJECTED='rejected'; class MyPromise{ constructor(exector){ try{ exector(this.resolve,this.reject) }catch(e){ reject(e) } }; status=PENDING; value=undefined; reason=undefined; successCallback=[]; failCallback=[]; resolve=value=&gt;{ if(this.status!==PENDING)return; this.status=FULFILLED; this.value=value; while(this.successCallback.length)this.successCallback.shift()() }; reject=reason=&gt;{ if(this.status!==PENDING)return; this.status=REJECTED; this.reason=reason; while(this.failCallback.length)this.failCallback &amp;&amp; this.failCallback.shift()() }; then(successCallback,failCallback){ successCallback=successCallback?successCallback:value=&gt;value; failCallback=failCallback?failCallback:reason=&gt;{throw reason}; let prmoise2=new MyPromise((resolve,reject)=&gt;{ if(this.status===FULFILLED){ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else if(this.status===REJECTED){ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else{ this.successCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); this.failCallback.push(()=&gt;{ setTimeout(() =&gt; { try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); } }); return prmoise2; }; static all(array){ let result=[]; let index=0; return new MyPromise((resolve,reject)=&gt;{ function addItem(key,value){ result[key]=value; index++; if(index==array.length){ resolve(result) } } for(let i=0;i&lt;array.length;i++){ let current=array[i]; if(current instanceof MyPromise){ current.then(value=&gt;addItem(i,value),reason=&gt;reject(reason)); }else{ addItem(i,current) } } }) }; /* resolve方法 */ static resolve(value){ //判断value 是否为MyPromise的实例，如果是，直接返回 if( value instanceof MyPromise) return value; //如果不是，return一个prmoise return new MyPromise(resolve=&gt;resolve(value)) } } function resolvePromise(prmoise2,n,resolve,reject){ if(prmoise2===n){ return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } if(n instanceof MyPromise){ n.then(resolve,reject) }else{ resolve(n) } } module.exports = MyPromise 代码验证 const MyPromise = require('./myPromise'); MyPromise.resolve('lonjin').then((res)=&gt;{ console.log(res) }); //lonjin finally()方法实现 finally()方法返回一个Promise。在Promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。 这避免了同样的语句需要在then()和catch()中各写一次的情况。 返回的是Promise 无论成功和失败都会执行 代码实现 //MyPromise中 finally(callback){ // 使用then方法拿到当前的promise的状态 return this.then(value=&gt;{ /* 如果callback是一个异步的promise对象，我们还需要等待其执行完毕，所以需要用到静态方法resolve 把callback调用之后返回的promise传递过去，并且执行promise，且在成功之后返回value */ return MyPromise.resolve(callback()).then(()=&gt;value) },reason=&gt;{ // 失败之后调用的then方法，然后把失败的原因返回出去 return MyPromise.resolve(callback()).then(() =&gt; { throw reason }) }) } 代码验证 const MyPromise = require('./myPromise') function fn1(){ return new MyPromise((resolve,reject)=&gt;{ setTimeout(() =&gt; { reject('100') }, 3000); }) } fn1().finally(()=&gt;{ console.log('finally') }).then((value)=&gt;{ console.log(value) },(erro)=&gt;{ console.log(erro) }) //finally // 100 catch方法的实现 catch方法是为了捕获promise对象的所有错误回调的 直接调用then方法，然后成功的地方传递undefined，错误的地方传递reason catch方法是作用在原型对象上的方法 代码实现 catch (failCallback) { // 直接调用then方法，然后成功的地方传递undefined，错误的地方传递reason return this.then(undefined, failCallback) } 完整代码 完整代码在下方，所有的都加了注释，需要的直接复制到编辑器看吧！ //定义三个常量 const PENDING='pending', //等待 FULFILLED='fulfilled', //成功 REJECTED='rejected'; //失败 class MyPromise{ constructor(exector){ // 立即执行函数，传入resolve方法和reject方法 //同时捕获一下错误 try{ exector(this.resolve,this.reject) }catch(e){ this.reject(e) } }; //定义一个初始状态 status=PENDING; //保存成功后的值 value=undefined; //保存失败后的值 reason=undefined; //定义一个成功回调函数 successCallback=[]; //定义一个失败回调函数 failCallback=[]; //成功 resolve=value=&gt;{ //判断当前状态是否为PENDING，如果不是就return if(this.status!==PENDING)return; //更改状态为fulfilled this.status=FULFILLED; //保存成功的返回值 this.value=value; //判断成功回调是否存在，如果存在，直接调用 while(this.successCallback.length)this.successCallback.shift()() }; //失败 reject=reason=&gt;{ //判断当前状态是否为PENDING，如果不是就return if(this.status!==PENDING)return; //更改状态为rejected this.status=REJECTED; //保存失败的返回值 this.reason=reason; //判断成功回调是否存在，如果存在，直接调用 while(this.failCallback.length)this.failCallback &amp;&amp; this.failCallback.shift()() }; //then方法会接收两个回调函数，分别为成功和失败的回调函数 then(successCallback,failCallback){ //处理then方法可选参数 successCallback=successCallback?successCallback:value=&gt;value; failCallback=failCallback?failCallback:reason=&gt;{throw reason} let prmoise2=new MyPromise((resolve,reject)=&gt;{ //判断当前状态，然后调用相应的函数 if(this.status===FULFILLED){ //成功状态 //传入返回值 /*因为new Promise需要执行完成之后才有promise2，同步代码中没有pormise2， 所以这部分代码需要异步执行 */ setTimeout(() =&gt; { //捕获错误 try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else if(this.status===REJECTED){ //失败状态 //传入返回值 setTimeout(() =&gt; { //捕获错误 try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }else{ //等待状态 //保存回调函数(考虑到异步情况) this.successCallback.push(()=&gt;{ setTimeout(() =&gt; { //捕获错误 try{ let n=successCallback(this.value) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); this.failCallback.push(()=&gt;{ setTimeout(() =&gt; { //捕获错误 try{ let n= failCallback(this.reason) resolvePromise(prmoise2,n,resolve,reject) }catch(e){ reject(e) } }, 0); }); } }); return prmoise2; }; // 直接调用then方法，然后成功的地方传递undefined，错误的地方传递reason catch (failCallback) { return this.then(undefined, failCallback) } finally(callback){ // 使用then方法拿到当前的promise的状态 return this.then(value=&gt;{ /* 如果callback是一个异步的promise对象，我们还需要等待其执行完毕，所以需要用到静态方法resolve 把callback调用之后返回的promise传递过去，并且执行promise，且在成功之后返回value */ return MyPromise.resolve(callback()).then(()=&gt;value) },reason=&gt;{ // 失败之后调用的then方法，然后把失败的原因返回出去 return MyPromise.resolve(callback()).then(() =&gt; { throw reason }) }) } static all(array){ // 要返回的数组 let result=[]; //记录执行次数 let index=0; //all方法返回的也是一个promise return new MyPromise((resolve,reject)=&gt;{ //定义一个存到result数组中的方法 function addItem(key,value){ result[key]=value; index++; if(index==array.length){ resolve(result) } } //循环array for(let i=0;i&lt;array.length;i++){ //当前的参数 let current=array[i]; //判断一下当前的返回值是普通值还是promise if(current instanceof MyPromise){ current.then(value=&gt;addItem(i,value),reason=&gt;reject(reason)); }else{ addItem(i,current) } } }) }; static resolve(value){ //判断value 是否为MyPromise的实例，如果是，直接返回 if( value instanceof MyPromise) return value; //如果不是，return一个prmoise return new MyPromise(resolve=&gt;resolve(value)) } } //判断x是不是其实例的对象 function resolvePromise(prmoise2,n,resolve,reject){ //如果n和prmoise2相等 则返回错误提示 if(prmoise2===n){ console.log('相等') return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } // 判断x是不是其实例对象 if(n instanceof MyPromise){ n.then(resolve,reject) }else{ //普通值，直接调用resolve resolve(n) } } //导出MyPromise module.exports = MyPromise ","link":"https://lonjinup.github.io/shou-xie-promise-tai-nan-chai-feng-zu-he-fa-ni-ye-ke-yi-shou-xie-promise/"},{"title":"JavaScript异步编程","content":"JavaScript异步编程 采用单线程模式工作的原因 最早js语言就是运行在浏览器端的语言，目的是为了实现页面上的动态交互。实现页面交互的核心就是DOM操作，这就决定了它必须使用单线程模型，否则就会出现很复杂的线程同步问题。 假设在js中有多个线程一起工作，其中一个线程修改了这个DOM元素，同时另一个线程又删除了这个元素，此时浏览器就无法明确该以哪个工作线程为准。所以为了避免线程同步的问题，从一开始，js就设计成了单线程的工作模式。所以，js执行环境中负责执行代码的线程只有一个。 单线程的优势和弊端 这种模式最大的优势就是更安全，更简单，缺点也很明确，就是如果中间有一个特别耗时的任务，其他的任务就要等待很长的时间，出现假死的情况。 为了解决这种问题，js有两种任务的执行模式：同步模式（Synchronous）和异步模式（Asynchronous）。 同步模式与异步模式 同步模式API和异步模式API的特点: 同步模式的API的特点就是任务执行完代码才会继续往下走，例如：console.log 异步模式的API的特点就是下达这个任务开启的指令之后代码就会继续执行，代码不会等待任务的结束 同步模式 同步模式 ：指的是代码的任务依次执行，后一个任务必须等待前一个任务结束才能开始执行。程序的执行顺序和代码的编写顺序是完全一致的。在单线程模式下，大多数任务都会以同步模式执行。 console.log('hello') function fn () { console.log('fn') } function say () { console.log('say hello') fn() } say() console.log('bye') // hello // say hello // fn // bye // 使用调用栈的逻辑 异步模式 异步模式： 不会去等待这个任务的结束才开始下一个任务，都是开启过后就立即往后执行下一个任务。耗时函数的后续逻辑会通过回调函数的方式定义。在内部，耗时任务完成过后就会自动执行传入的回调函数。 console.log('timer1') // 延时器 setTimeout(function timer1 () { console.log('timer2') }, 1800) // 延时器中又嵌套了一个延时器 setTimeout(function timer2 () { console.log('timer3') setTimeout(function inner () { console.log('timer4') }, 1000) }, 1000) console.log('timer5') // timer1 // timer5 // timer3 // timer2 // timer4 js线程某个时刻发起了一个异步调用，它紧接着继续执行其他的任务，此时异步线程会单独执行异步任务，执行过后会将回调放到消息队列中，js主线程执行完任务过后会依次执行消息队列中的任务。js是单线程的，浏览器不是单线程的，有一些API是有单独的线程去做的。 Promise——优雅的异步编程方案 Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。Promise汉译过来就是承诺的意思，比传统的解决方案——回调函数和事件——更合理和更强大。Promise简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 Promise的特点 它有三种状态：pending(进行中)、 （已成功）和rejected（已失败） 它的状态是不可逆的,一旦状态改变，就不会再变。 即便promise中没有任何的异步操作，then方法的回调函数仍然会进入到事件队列中排队。 Promise的基本用法 resolve let promise=new Promise((resolve,reject)=&gt;{ console.log('hello') resovle('hi') }) promise.then((data)=&gt;{ console.log(data) },(erro)=&gt;{ console.log(erro) }) //hello //hi reject let promise=new Promise((resovle,reject)=&gt;{ console.log('hello') reject('erro') }) promise.then((data)=&gt;{ console.log(data) },(erro)=&gt;{ console.log(erro) }) //hello //erro Promise案例 使用Promise封装一个ajax请求: function ajax(url){ return new Promise((resolve,reject)=&gt;{ // 创建一个XMLHttpRequest对象去发送一个请求 const xhr=new XMLHttpRequest(); // 先设置一下xhr对象的请求方式是GET，请求的地址就是参数传递的url xhr.open('GET',url) // 设置返回的类型是json，是HTML5的新特性 // 我们在请求之后拿到的是json对象，而不是字符串 xhr.responseType='json'; xhr.onload=()=&gt;{ console.log(xhr.status) if(xhr.status==200){ //请求成功，返回结果 resolve(xhr.response) }else{ //失败返回错误信息 reject(new Error(xhr.statusText)) } }; //开始执行 xhr.send(); }) }; ajax('app.json').then((res)=&gt;{ console.log(res) },(err)=&gt;{ console.log(err) }) Promise链式调用 Promise对象then方法，返回了全新的promise对象。可以再继续调用then方法，如果return的不是promise对象，而是一个值，那么这个值会作为resolve的值传递，如果没有值，默认是undefined 后面的then方法就是在为上一个then返回的Promise注册回调 前面then方法中回调函数的返回值会作为后面then方法回调的参数 如果回调中返回的是Promise，那后面then方法的回调会等待它的结束 ","link":"https://lonjinup.github.io/javascript-yi-bu-bian-cheng/"},{"title":"函数式编程","content":"函数式编程 为什么要学函数式编程？ 函数式表成是随着React的流行收到越来越多的关注（React的高阶组件使用了高阶函数来实现，高阶函数就是函数式编程的一个特性。Redux也使用了函数式编程的思想。） Vue3也开始拥抱函数式编程 函数式编程可以抛弃this 打包过程中可以更好的利用tree shaking过滤无用代码 方便测试、方便并行处理 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda 什么是函数式编程？ 函数式编程，缩写FP，是一种编程范式，也是一种编程风格，和面向对象是并列的关系。函数式编程我们可以认为是一种思维模式，加上实现方法。其思维方式就是把现实世界事物和事物之间的联系抽象到程序世界（是对运算过程进行抽象） 常听说的编程范式还有面向过程编程（按照步骤来实现）、面向对象编程（把现实中的事物抽象成类和对象，通过封装、继承和多态来演示不同事物之间的联系）。 函数式编程和面向对象编程的不同 从思维方式上来说,面向对象编程是对事物的抽象，而函数式编程是对运算过程的抽象 对于函数式编程思维方式的理解 程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数。 函数式编程中的函数指的不是程序中的函数Function，而是数学中的函数即映射关系，例如：y=sin(x)，是这种x和y的关系 相同的输入时钟要得到相同的输出（纯函数） 函数式编程用描述数据（函数）之间的映射 //非函数式 let num1=1, num2=2; let sum=num1+num2; console.log(sum); //函数式 function add(m,n){ return m+n; }; let sum2=add(3,4); console.log(sum2); 函数式编程的前置知识 函数是一等公民 在JS中函数就是一个普通的对象，我们可以把函数存储到变量/数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new Function('alert(1)')来构造一个新的函数。 函数可以存储在变量中: // 把函数赋值给变量 let fn = function () { console.log(&quot;hi&quot;) } fn() // 一个示例 const BlogController = { index (posts) { return Views.index(posts) }, show (post) { return Views.show(post) }, create (attrs) { return Db.create(attrs) }, update (post, attrs) { return Db.update(post, attrs) }, destroy (post) { return Db.destroy(post) } } // 优化 赋值的是Views的index方法，不是方法的调用 const BlogController = { index: Views.index, show: Views.show, create: Db.create, update: Db.update, destroy: Db.destroy } 函数可以作为参数 函数可以作为返回值 高阶函数 高阶函数英文叫Higher-order function。JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 1.接受一个或多个函数作为输入 2.输出一个函数 函数可以作为参数 //模拟数组中的某些操作 // forEach // 定义一个遍历数组的并对每一项做处理的函数，第一个函数是一个数组，第二个参数是一个函数。 function forEach(array,fn){ for(let i=0;i&lt;array.length;i++){ fn(array[i]) } }; let arr=[1,2,3,4,5]; forEach(arr,items=&gt;{ console.log(items) }) // filter // 遍历数组，并把满足条件的元素存储成数组，再进行返回 function filter(array,fn){ let newArr=[]; for(let i=0;i&lt;array.length;i++){ if(fn(array[i])){ newArr.push(array[i]) } }; return newArr } let a=filter(arr,item=&gt;item%2==0) console.log(a) 函数做为返回值 // test1:一个函数返回另一个函数 function todo(){ let text='hello world'; return function(){ console.log(text) } } //方式1 调用 const fn=todo() fn() //方式2 调用 todo()() //test2:让函数只执行一次 function once(fn){ let status=false; return function(){ if(!status){ status=true; return fn.apply(this,arguments) } } }; let pay = once(function(money){ console.log(`支付了 ${money}元`) }) pay(100) pay(200) 使用高阶函数的意义 抽象可以帮我们屏蔽细节，我们只需要知道我们的目标和解决这类问题的函数，我们不需要关心实现的细节 高阶函数是用来抽象通用的问题 用高阶函数模拟常用函数 map:便利数组中每一个元素，然后生成新的数组 const map=(array,fn)=&gt;{ let arr=[]; for(let i of array){ arr.push(fn(i)) } return arr } let arr=[1,2,3,4,5]; arr=map(arr,v=&gt;v*v); console.log(arr) every:数组中的每一个元素是否都匹配我们指定的一个条件，如果都满足返回true，如果不满足返回false const every=(array,fn)=&gt;{ let status=true; for(let i of array){ status=fn(i) if(!status){ break } } return status } let arr=[1,2,3,4,5]; let n=every(arr,v=&gt;v&gt;=1); console.log(n) some:判断数组中是否有一个元素满足我们指定的条件，满足是true，都不满足为false const some=(array,fn)=&gt;{ let status=false; for(let i of array){ status=fn(i); if(status){ break; } } return status } let arr=[4,5,6,7]; let n=some(arr,v=&gt;v&gt;7); console.log(n); 闭包 函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除。但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。闭包的核心作用就是把函数内部成员的作用范围延长。 function makeFn () { let msg = 'Hello function' } // 正常情况下，执行完makeFn，里面的变量msg会释放掉 // 但是下面的情况 function makeFn () { let msg = 'Hello function' return function () { console.log(msg) } } // 在上面函数中，返回了一个函数，而且在函数中还访问了原来函数内部的成员，就可以称为闭包 const fn = makeFn() fn() // fn为外部函数，当外部函数对内部成员有引用的时候，那么内部的成员msg就不能被释放。当我们调用fn的时候，我们就会访问到msg。 //注意的点： //1、我们可以在另一个作用域调用makeFn的内部函数 //2、当我们调用内部函数的时候我们可以访问到内部成员 闭包应用 计算数字的次方 function pow(power){ return function(number){ return Math.pow(number,power) } } //求平方 let pow2=pow(2); console.log(pow2(2)) //立方 let pow3=pow(3); console.log(pow3(2)) 计算不同级别的员工工资(不同员工基本工资相等，绩效不同) function peopleMoney(moeny){ return function(value){ return moeny+value } } let lv1=peopleMoney(1000); let lv2=peopleMoney(2000); console.log(lv1(200)) console.log(lv2(1300)) 纯函数 相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，如y = f(x) let numbers = [1, 2, 3, 4, 5] // 纯函数 // 对于相同的函数，输出是一样的 // slice方法，截取的时候返回截取的函数，不影响原数组 numbers.slice(0, 3) // =&gt; [1, 2, 3] numbers.slice(0, 3) // =&gt; [1, 2, 3] numbers.slice(0, 3) // =&gt; [1, 2, 3] // 不纯的函数 // 对于相同的输入，输出是不一样的 // splice方法，返回原数组，改变原数组 numbers.splice(0, 3) // =&gt; [1, 2, 3] numbers.splice(0, 3) // =&gt; [4, 5] numbers.splice(0, 3) // =&gt; [] // 下面函数也是纯函数 function getSum (n1, n2) { return n1 + n2 } console.log(getSum(1, 2)) // 3 console.log(getSum(1, 2)) // 3 console.log(getSum(1, 2)) // 3 函数式编程不会保留计算中间的结果，所以变量是不可变的(无状态的) 我们也可以把一个函数的执行结果交给另一个函数处理 Lodash——纯函数js库 Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。 安装： npm init -y npm i lodash 使用： var _ = require('lodash'); //数组合并 var arr=[1,2,3] var newArr=_.concat(arr,[4,5,6],[7,8,9]) console.log(newArr) //数组反转 let className=['tom','bob','nike']; console.log(_.reserve(className)) console.log(className) // 数组的翻转不是纯函数，因为会改变原数组。这里的reserve是使用了数组的reverse，所以也不是纯函数 纯函数的好处 可缓存 因为对于相同的输入始终有相同的结果，那么可以把纯函数的结果缓存起来，可以提高性能。 const _ = require('lodash'); /* _.memoize(func, [resolver]):创建一个会缓存 func 结果的函数。 如果提供了 resolver ，就用 resolver 的返回值作为 key 缓存函数的结果。 默认情况下用第一个参数作为缓存的 key。 func 在调用时 this 会绑定在缓存函数上。*/ //计算两个数字的和 function add(m,n){ console.log('once') return m+n } let fn=_.memoize(add); console.log(fn(4,5)); console.log(fn(4,5)); console.log(fn(4,5)); // 输出的once只执行了一次，因为其结果被缓存下来了 模拟_.memoize const _ = require('lodash'); function add(m,n){ console.log('once') return m+n } function memoize (f) { let cache = {} return function () { // arguments是一个伪数组，所以要进行字符串的转化 let key = JSON.stringify(arguments) console.log(key) // 如果缓存中有值就把值赋值，没有值就调用f函数并且把参数传递给它 cache[key] = cache[key] || f.apply(f,arguments) console.log(cache) return cache[key] } } let getAreaWithMemory1 = memoize(add) console.log(getAreaWithMemory1(4,5)) /* 输出 {&quot;0&quot;:4,&quot;1&quot;:5} once { '{&quot;0&quot;:4,&quot;1&quot;:5}': 9 } 9 */ 可测试 纯函数让测试更加的方便 并行处理 多线程环境下并行操作共享的内存数据很可能会出现意外情况。纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 虽然JS是单线程，但是ES6以后有一个Web Worker，可以开启一个新线程 柯里化 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 当函数有多个参数的时候，我们可以对函数进行改造。我们可以调用一个函数，只传递部分的参数（这部分参数以后永远不变），然后让这个函数返回一个新的函数。新的函数传递剩余的参数，并且返回相应的结果。 // 下面这段代码是解决了不纯的函数的问题，但是里面出现了硬编码 function checkAge (age) { let mini = 18 return age &gt;= mini } // 普通的纯函数 function checkAge (min, age) { return age &gt;= min } console.log(checkAge(18, 20)) //true console.log(checkAge(18, 24)) //true console.log(checkAge(20, 24)) //true // 经常使用18，这段代码是重复的。避免重复 function checkAge (min) { return function (age) { return age &gt;= min } } let checkAge18 = checkAge(18) let checkAge20 = checkAge(20) console.log(checkAge18(20)) //true console.log(checkAge18(24)) //true Lodash中的柯里化 —— curry() 功能：创建一个函数，该函数接收一个或多个 func的参数，如果 func 所需要的参数都被提供则执行 func 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。 参数：需要柯里化的函数 返回值：柯里化后的函数 //案例 const _ = require('lodash'); function getSum(a,b,c){ return a+b+c } const curried=_.curry(getSum) console.log(curried(1,2,3)) console.log(curried(1)(2)(3)) console.log(curried(1)(2,3)) 柯里化的实现 实现一个柯里化转换函数要进行分析 1.入参出参：调用传递一个纯函数的参数，完成之后返回一个柯里化函数 2.入参情况分析： 如果curried调用传递的参数和getSum函数参数个数相同，那么立即执行并返回调用结果 如果curried调用传递的参数是getSum函数的部分参数，那么需要返回一个新的函数，并且等待接收getSum的其他参数 3 重点关注： 获取调用的参数 判断个数是否相同 function getSum (a, b, c) { return a + b + c } // 模拟柯里化函数 function curry (func) { // 取名字是为了下面实参小于形参的时候用的 return function curriedFn(...args) { // 判断实参和形参的个数 if(args.length &lt; func.length) { return function() { // 等待传递的剩余参数，如果剩余函数的参数加上之前的参数等于形参，那么就返回func // 第一部分参数在args里面，第二部分参数在arguments里面，要将两个合并并且展开传递（使用...） // concat函数要合并两个数组，arguments为伪数组，所以用Array.from进行转换 return curriedFn(...args.concat(Array.from(arguments))) } } // 如果实参大于等于形参的个数 // args是剩余参数，是个数组形式，而返回的时候要展开（使用...） return func(...args) } } // test const curriedTest = curry(getSum) console.log(curriedTest(1, 2, 3)) // 6 console.log(curriedTest(1)(2, 3)) // 6 console.log(curriedTest(1, 2)(3)) // 6 总结 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数（比如match函数新生成了haveSpace函数，里面使用了闭包，记住了我们给传递的正则表达式的参数） 这是一种对函数参数的'缓存'（使用了闭包） 让函数变的更灵活，让函数的粒度更小 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能 函数组合 如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数。函数组合默认是从右到左执行 //例子：有一个数组，需要获取到数组最后一个元素 function reverse(array){ return array.reverse() } function first(array){ return array[0] } //es5 /* function getFirst(f,n){ return function(value){ return f(n(value)) } } */ //es6 const getFirst=(f,n)=&gt;value=&gt;f(n(value)); let compose=getFirst(first,reverse); console.log(compose([1,2,3,4,5])) //5 组合函数模拟 有一个数组，需要获取到数组中最后一个元素并换成大写 const reverse = arr =&gt; arr.reverse(); const first = arr =&gt; arr[0]; const toUpper = s =&gt; s.toUpperCase(); function compose (...args) { // 返回的函数，有一个传入的初始参数即value return function (value) { // ...args是执行的函数的数组，从右向左执行那么数组要进行reverse翻转 // reduce: 对数组中的每一个元素，去执行我们提供的一个函数，并将其汇总成一个单个结果 // reduce的第一个参数是一个回调函数，第二个参数是acc的初始值，这里acc的初始值就是value // reduce第一个参数的回调函数需要两个参数，第一个参数是汇总的一个结果，第二个参数是如果处理汇总的结果的函数并返回一个新的值 // fn指的是数组中的每一个元素（即函数），来处理参数acc，完成之后下一个数组元素处理的是上一个数组的结果acc return args.reverse().reduce(function (acc, fn) { return fn(acc) }, value) } } //test const fTest = compose(toUpper, first, reverse) console.log(fTest(['one', 'two', 'three'])) // THREE // ES6的写法（函数都变成箭头函数） const compose = (...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value) 函数组合-结合律 什么是函数组合结合律？ 下面三个情况结果一样，我们既可以把 g 和 h 组合，还可以把 f 和 g 组合 //伪代码 // 结合律（associativity） let f = compose(f, g, h) let associative = compose(compose(f, g), h) == compose(f, compose(g, h)) // true 实际案例 const _ = require('lodash'); // 方式一 const f = _.flowRight(_.toUpper, _.first, _.reverse) // 方式二 const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse) // 方式三 const f = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse)) // 无论上面那种写法，下面都输出THREE这个相同的结果 console.log(f(['one', 'two', 'three'])) // THREE 如何测试函数组合 如果我们运行的结果和我们的预期不一致，我们怎么调试呢？我们怎么能知道中间运行的结果呢？ 下面这个输入NEVER SAY DIE要对应输出nerver-say-die const _ = require('lodash') // 这里split函数需要传入两个参数，且我们最后调用的时候要传入字符串，所以字符串要在第二个位置传入，这里我们需要自己封装一个split函数 // _.split(string, separator) // 将多个参数转成一个参数，用到函数的柯里化 const split = _.curry((sep, str) =&gt; _.split(str, sep)) // 大写变小写，用到toLower()，因为这个函数只有一个参数，所以可以在函数组合中直接使用 // 这里join方法也需要两个参数，第一个参数是数组，第二个参数是分隔符，数组也是最后的时候才传递，也需要交换 const join = _.curry((sep, array) =&gt; _.join(array, sep)) const f = _.flowRight(join('-'), _.toLower, split(' ')) console.log(f('NEVER SAY DIE')) //n-e-v-e-r-,-s-a-y-,-d-i-e 但是最后的结果却不是我们想要的，那么我们怎么调试呢？ // NEVER SAY DIE --&gt; nerver-say-die const _ = require('lodash') const split = _.curry((sep, str) =&gt; _.split(str, sep)) const join = _.curry((sep, array) =&gt; _.join(array, sep)) // 我们需要对中间值进行打印，并且知道其位置，用柯里化输出一下 const log = _.curry((tag, v) =&gt; { console.log(tag, v) return v }) // 从右往左在每个函数后面加一个log，并且传入tag的值，就可以知道每次结果输出的是什么 const f = _.flowRight(join('-'), log('after toLower:'), _.toLower, log('after split:'), split(' ')) // 从右到左 //第一个log：after split: [ 'NEVER', 'SAY', 'DIE' ] 正确 //第二个log: after toLower: never,say,die 转化成小写字母的时候，同时转成了字符串，这里出了问题 console.log(f('NEVER SAY DIE')) //n-e-v-e-r-,-s-a-y-,-d-i-e // 修改方式，利用数组的map方法，遍历数组的每个元素让其变成小写 // 这里的map需要两个参数，第一个是数组，第二个是回调函数，需要柯里化 const map = _.curry((fn, array) =&gt; _.map(array, fn)) const f1 = _.flowRight(join('-'), map(_.toLower), split(' ')) console.log(f1('NEVER SAY DIE')) // never-say-die FP模块 函数组合的时候用到很多的函数需要柯里化处理，我们每次都处理那些函数有些麻烦，所以lodash中有一个FP模块 lodash 的 fp 模块提供了实用的对函数式编程友好的方法 提供了不可变 auto-curried iteratee-first data-last （函数之先，数据之后）的方法 const fp=require('lodash/fp'); // 函数置先，数据置后 console.log(fp.map(fp.toUpper,['a','b','c','d'])) //规则置前，数据置后 console.log(fp.split(' ')('hello word')) console.log(fp.split(' ','hello word')) Point Free Point Free是一种编程风格，具体的实现是函数的组合。Point Free： 我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。 不需要指明处理的数据 只需要合成运算过程 需要定义一些辅助的基本运算函数 例子1 /*将Hello World 转化为 hello_world */ const fp=require('lodash/fp'); const f=fp.flowRight(fp.replace(/\\s+/g,'_'),fp.toLower); console.log(f('Hello World')) //hello_world 例子2 //world wild web --&gt;W. W. W //思路： //把一个字符串中的额首字母提取并转换成大写，使用. 作为分隔符 const fp = require('lodash/fp') const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(' ')) console.log(firstLetterToUpper('world wild web')) //W. W. W // 上面的代码进行了两次的遍历，性能较低 // 优化 const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(' ')) console.log(firstLetterToUpper('world wild web')) //W. W. W Functor 为什么要学函子？ 函子(representative functor)是范畴论里的概念，指从任意范畴到集合范畴的一种特殊函子。 我们没有办法避免副作用，但是我们尽可能的将副作用控制在可控的范围内，我们可以通过函子去处理副作用，我们也可以通过函子去处理异常，异步操作等。 什么是Functor 容器：包含值和值的变形关系(这个变形关系就是函数) 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map方法可以运行一个函数对值进行处理(变形关系) class Container{ constructor(value){ // 这个函子的值是保存在内部的，不对外公布 // _下划线的成员都是私有成员，外部无法访问，值是初始化的传的参数 this._value=value } //有一个对外的方法map，接收一个函数（纯函数），来处理这个值 map(fn){ // 返回一个新的函子，把fn处理的值返回给函子，由新的函子来保存 return new Container(fn(this._value)) } } // 创建一个函子的对象 let r=new Container(5) .map(n=&gt;n+1) .map(n=&gt;n*n) // 返回了一个container函子对象，里面有值是36，不对外公布 console.log(r) //Container { _value: 36 } 上面还是面向对象的编程思想，要修改成函数式编程的思想，需要避免使用new class Container { //使用类的静态方法，of替代了new Container的作用 static of (value) { return new Container(value) } constructor (value) { this._value = value } map (fn) { return Container.of(fn(this._value)) } } const r = Container.of(5) .map(x=&gt;x+2) // 7 .map(x=&gt; x**2) // 49 console.log(r) // Container { _value: 49 } 总结 函数式编程的运算不直接操作值，而是由函子完成 函子就是一个实现了 map 契约的对象 我们可以把函子想象成一个盒子，这个盒子里封装了一个值 想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理 最终 map 方法返回一个包含新值的盒子（函子） 遗留问题：在上面说的函子中，如果value是null undefined，怎么办？ Container.of(null) .map(x=&gt;x.toUpper) // 报错，使得函数不纯 下面这些函子就是处理不同问题的函数 MyBe函子 MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围） class MayBe { static of (value) { return new MayBe(value) } constructor (value) { this._value = value } map(fn) { // 判断一下value的值是不是null和undefined，如果是就返回一个value为null的函子，如果不是就执行函数 return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value)) } // 定义一个判断是不是null或者undefined的函数，返回true/false isNothing() { return this._value === null || this._value === undefined } } const r = MayBe.of('hello world') .map(x =&gt; x.toUpperCase()) console.log(r) //MayBe { _value: 'HELLO WORLD' } // 如果输入的是null，是不会报错的 const rnull = MayBe.of(null) .map(x =&gt; x.toUpperCase()) console.log(rnull) //MayBe { _value: null } 但是这里有一个问题就是，如果map中间有好几步，最后返回是null，并不知道是哪一个步骤返回的。解决这个问题，需要看下一个函子。 Either函子 Either 两者中的任何一个，类似于 if...else...的处理 当出现问题的时候，Either函子会给出提示的有效信息， 异常会让函数变的不纯，Either 函子可以用来做异常处理 // 因为是二选一，所以要定义left和right两个函子 class Left { static of (value) { return new Left(value) } constructor (value) { this._value = value } map (fn) { return this } } class Right { static of (value) { return new Right(value) } constructor (value) { this._value = value } map (fn) { return Right.of(fn(this._value)) } } let r1 = Right.of(12).map(x =&gt; x + 2) let r2 = Left.of(12).map(x =&gt; x + 2) console.log(r1) // Right { _value: 14 } console.log(r2) // Left { _value: 12 } // 为什么结果会不一样？因为Left返回的是当前对象，并没有使用fn函数 // 那么这里如何处理异常呢？ // 我们定义一个字符串转换成对象的函数 function parseJSON(str) { // 对于可能出错的环节使用try-catch // 正常情况使用Right函子 try{ return Right.of(JSON.parse(str)) }catch (e) { // 错误之后使用Left函子，并返回错误信息 return Left.of({ error: e.message }) } } let rE = parseJSON('{name:xm}') console.log(rE) // Left { _value: { error: 'Unexpected token n in JSON at position 1' } } let rR = parseJSON('{&quot;name&quot;:&quot;xm&quot;}') console.log(rR) // Right { _value: { name: 'xm' } } console.log(rR.map(x =&gt; x.name.toUpperCase())) // Right { _value: 'XM' } IO函子 IO就是输入输出，IO 函子中的 _value 是一个函数，这里是把函数作为值来处理 IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操 作 把不纯的操作交给调用者来处理 因为IO函数需要用到组合函数，所以需要提前安装Lodash npm init -y npm i lodash const fp = require('lodash/fp') class IO { // of方法快速创建IO，要一个值返回一个函数，将来需要值的时候再调用函数 static of(value) { return new IO(() =&gt; value) } // 传入的是一个函数 constructor (fn) { this._value = fn } map(fn) { // 这里用的是new一个新的构造函数，是为了把当前_value的函数和map传入的fn进行组合成新的函数 return new IO(fp.flowRight(fn, this._value)) } } // test // node执行环境可以传一个process对象（进程） // 调用of的时候把当前取值的过程包装到函数里面，再在需要的时候再获取process const r = IO.of(process) // map需要传入一个函数，函数需要接收一个参数，这个参数就是of中传递的参数process // 返回一下process中的execPath属性即当前node进程的执行路径 .map(p =&gt; p.execPath) console.log(r) // IO { _value: [Function] } // 上面只是组合函数，如果需要调用就执行下面 console.log(r._value()) // /usr/local/bin/node Task函子（异步执行） 函子可以控制副作用，还可以处理异步任务，为了避免地狱之门。 异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示 folktale 一个标准的函数式编程库。和 lodash、ramda 不同的是，他没有提供很多功能函数。只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、 MayBe 等 folktale的安装 npm i folktale folktale中的curry函数 const {curry } = require('folktale/core/lambda'); // curry中的第一个参数是函数有几个参数，为了避免一些错误 const f = curry(2, (x, y) =&gt; x + y) console.log(f(1, 2)) // 3 console.log(f(1)(2)) // 3 folktale中的compose函数 const { compose, curry } = require('folktale/core/lambda') const { toUpper, first } = require('lodash/fp') // compose 组合函数在lodash里面是flowRight const r = compose(toUpper, first) console.log(r(['one', 'two'])) // ONE Task函子异步执行 folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的 函子 这里以 2.3.2 来演示 const { task } = require('folktale/concurrency/task') const fs = require('fs') // 2.0中是一个函数，函数返回一个函子对象 // 1.0中是一个类 //读取文件 function readFile (filename) { // task传递一个函数，参数是resolver // resolver里面有两个参数，一个是reject失败的时候执行的，一个是resolve成功的时候执行的 return task(resolver =&gt; { //node中读取文件，第一个参数是路径，第二个是编码，第三个是回调，错误在先 fs.readFile(filename, 'utf-8', (err, data) =&gt; { if(err) resolver.reject(err) resolver.resolve(data) }) }) } //演示一下调用 // readFile调用返回的是Task函子，调用要用run方法 readFile('package.json') .run() // 现在没有对resolve进行处理，可以使用task的listen去监听获取的结果 // listen传一个对象，onRejected是监听错误结果，onResolved是监听正确结果 .listen({ onRejected: (err) =&gt; { console.log(err) }, onResolved: (value) =&gt; { console.log(value) } }) /** { &quot;name&quot;: &quot;Functor&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;either.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;folktale&quot;: &quot;^2.3.2&quot;, &quot;lodash&quot;: &quot;^4.17.20&quot; } } */ 案例 const { task } = require('folktale/concurrency/task') const fs = require('fs') const { split, find } = require('lodash/fp') // 2.0中是一个函数，函数返回一个函子对象 // 1.0中是一个类 //读取文件 function readFile (filename) { // task传递一个函数，参数是resolver // resolver里面有两个参数，一个是reject失败的时候执行的，一个是resolve成功的时候执行的 return task(resolver =&gt; { //node中读取文件，第一个参数是路径，第二个是编码，第三个是回调，错误在先 fs.readFile(filename, 'utf-8', (err, data) =&gt; { if(err) resolver.reject(err) resolver.resolve(data) }) }) } //演示一下调用 // readFile调用返回的是Task函子，调用要用run方法 readFile('package.json') //在run之前调用map方法，在map方法中会处理的拿到文件返回结果 // 在使用函子的时候就没有必要想的实现机制 .map(split('\\n')) .map(find(x =&gt; x.includes('version'))) .run() // 现在没有对resolve进行处理，可以使用task的listen去监听获取的结果 // listen传一个对象，onRejected是监听错误结果，onResolved是监听正确结果 .listen({ onRejected: (err) =&gt; { console.log(err) }, onResolved: (value) =&gt; { console.log(value) // &quot;version&quot;: &quot;1.0.0&quot;, } }) Pointed函子 Pointed函子是实现了of静态方法的函子 of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文 Context（把值放到容器中，使用 map 来处理值） class Container { // Point函子 // 作用是把值放到一个新的函子里面返回，返回的函子就是一个上下文 static of (value) { return new Container(value) } …… } // 调用of的时候获得一个上下文，之后是在上下文中处理数据 Contanier.of(2) .map(x =&gt; x + 5) Monad函子（单子) IO函子的嵌套问题，用来解决IO函子多层嵌套的一个问题 const fp = require('lodash/fp') const fs = require('fs') class IO { static of (value) { return new IO(() =&gt; { return value }) } constructor (fn) { this._value = fn } map(fn) { return new IO(fp.flowRight(fn, this._value)) } } //读取文件函数 let readFile = (filename) =&gt; { return new IO(() =&gt; { //同步获取文件 return fs.readFileSync(filename, 'utf-8') }) } //打印函数 // x是上一步的IO函子 let print = (x) =&gt; { return new IO(()=&gt; { console.log(x) return x }) } // 组合函数，先读文件再打印 let cat = fp.flowRight(print, readFile) // 调用 // 拿到的结果是嵌套的IO函子 IO(IO(x)) let r = cat('package.json') console.log(r) // IO { _value: [Function] } console.log(cat('package.json')._value()) // IO { _value: [Function] } // IO { _value: [Function] } console.log(cat('package.json')._value()._value()) // IO { _value: [Function] } /** * { &quot;name&quot;: &quot;Functor&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;either.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;folktale&quot;: &quot;^2.3.2&quot;, &quot;lodash&quot;: &quot;^4.17.20&quot; } } */ 上面遇到多个IO函子嵌套的时候，那么_value就会调用很多次，这样的调用体验很不好。所以进行优化。 Monad 函子是可以变扁的 Pointed 函子，用来解决IO函子嵌套问题，IO(IO(x)) 一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad 实现一个Monad函子 const fp = require('lodash/fp') const fs = require('fs') class IO { static of (value) { return new IO(() =&gt; { return value }) } constructor (fn) { this._value = fn } map(fn) { return new IO(fp.flowRight(fn, this._value)) } join () { return this._value() } // 同时调用map和join方法 flatMap (fn) { return this.map(fn).join() } } let readFile = (filename) =&gt; { return new IO(() =&gt; { return fs.readFileSync(filename, 'utf-8') }) } let print = (x) =&gt; { return new IO(()=&gt; { console.log(x) return x }) } let r = readFile('package.json') .flatMap(print) .join() // 执行顺序 /** * readFile读取了文件，然后返回了一个IO函子 * 调用flatMap是用readFile返回的IO函子调用的 * 并且传入了一个print函数参数 * 调用flatMap的时候，内部先调用map，当前的print和this._value进行合并，合并之后返回了一个新的函子 * （this._value就是readFile返回IO函子的函数： * () =&gt; { return fs.readFileSync(filename, 'utf-8') } * ） * flatMap中的map函数执行完，print函数返回的一个IO函子，里面包裹的还是一个IO函子 * 下面调用join函数，join函数就是调用返回的新函子内部的this._value()函数 * 这个this._value就是之前print和this._value的组合函数，调用之后返回的就是print的返回结果 * 所以flatMap执行完毕之后，返回的就是print函数返回的IO函子 * */ r = readFile('package.json') // 处理数据，直接在读取文件之后，使用map进行处理即可 .map(fp.toUpper) .flatMap(print) .join() // 读完文件之后想要处理数据，怎么办？ // 直接在读取文件之后调用map方法即可 /** * { &quot;NAME&quot;: &quot;FUNCTOR&quot;, &quot;VERSION&quot;: &quot;1.0.0&quot;, &quot;DESCRIPTION&quot;: &quot;&quot;, &quot;MAIN&quot;: &quot;EITHER.JS&quot;, &quot;SCRIPTS&quot;: { &quot;TEST&quot;: &quot;ECHO \\&quot;ERROR: NO TEST SPECIFIED\\&quot; &amp;&amp; EXIT 1&quot; }, &quot;KEYWORDS&quot;: [], &quot;AUTHOR&quot;: &quot;&quot;, &quot;LICENSE&quot;: &quot;ISC&quot;, &quot;DEPENDENCIES&quot;: { &quot;FOLKTALE&quot;: &quot;^2.3.2&quot;, &quot;LODASH&quot;: &quot;^4.17.20&quot; } } */ ","link":"https://lonjinup.github.io/function-play/"},{"title":"JavaScript设计模式-策略模式","content":"JavaScript中策略模式 什么是策略模式 策略模式是一种简单却常用的设计模式，它的应用场景非常广泛。该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 该模式主要解决在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。它的优点是算法可以自由切换，同时可以避免多重if...else判断，且具有良好的扩展性。 案例1 在做电商系统时候很多情况下会根据商品来单独计算他们的价格，比如预售价、双十一价格、正常价等，我们可能会这么写： function getPrice(price, status) { if (status == 'default') { return price } else if (status == 'pre-sale') { return price * 0.8 } else if (status == 'doubleOneOne') { return price / 2 } } console.log(getPrice(100, 'doubleOneOne')) // 50 上面代码使用了比较多的if...else来进行不同情况下的判断，同时把计算逻辑放到了getPirce方法里面，导致方法比较臃肿，不易维护。可以把不同情况下的逻辑抽离出来，一方面方便维护，另一方面可以提高代码复用率。 function defaultPrice(price) { return price; } function preSale(price) { return price * 0.8; } function doubleOneOne(price) { return price / 2; } function getPrice(price, status) { if (status == 'default') { return defaultPrice(price) } else if (status == 'pre-sale') { return preSale(price) } else if (status == 'doubleOneOne') { return doubleOneOne(price); } } console.log(getPrice(100, 'pre-sale')) //80 上面代码虽然把计算逻辑单独抽离出来了，但是美中不足的地方就是还是有很多if...else，不够优雅，仔细观察，我们可以把各种情况当作key，然后去映射对应的方法，这样getPrice方法就相当纯粹了，后期增加不同的活动，单独维护映射关系以及计算方法即可。 function defaultPrice(price) { return price; } function preSale(price) { return price * 0.8; } function doubleOneOne(price) { return price / 2; } const priceList = { 'default': defaultPrice, 'pre-sale': preSale, 'doubleOneOne': doubleOneOne, }; function getPrice(price, status) { return priceList[status](price); } console.log(getPrice(100, 'doubleOneOne')); //50 案例2 先举个项目中常见的例子：表单验校，这个在我们开发中几乎都会遇到，对于表单中的各种值，在提交时会根据用户输入的值进行规则验校，如果不符合规则就提示用户，增加产品体验。下面就写一个基础的表单来示范： &lt;form id='forgot-password-wrapper' action=&quot;&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;mobile&quot;&gt;手机号&lt;/label&gt; &lt;input type=&quot;number&quot; id=&quot;mobile&quot; name=&quot;mobile&quot;&gt; &lt;label for=&quot;code&quot;&gt;验证码&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;code&quot; name=&quot;code&quot;&gt; &lt;label for=&quot;password&quot;&gt;新密码&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt; &lt;label for=&quot;passwordAgain&quot;&gt;新密码&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;passwordAgain&quot; name=&quot;passwordAgain&quot;&gt; &lt;button id='push'&gt;确认&lt;/button&gt; &lt;/form&gt; &lt;script&gt; const forgotPasswordForm = document.getElementById('forgot-password-wrapper') forgotPasswordForm.onsubmit = (e)=&gt;{ e.preventDefault() const mobile = document.getElementById('mobile').value const code = document.getElementById('code').value const password = document.getElementById('password').value const passwordAgain = document.getElementById('passwordAgain').value const mobileReg = /^[1][3,4,5,7,8,9][0-9]{9}$/ if(mobile === null || mobile === ''){ console.log('请输入手机号') return false; }else if(!mobileReg.test(mobile)){ console.log('请输入正确的手机号') return false; }else if(code === '' || code === null){ console.log('请输入验证码') return false; }else if(code.length != 6){ console.log('请输入6位数验证码') return false; }else if(password === '' || password === null){ console.log('请输密码') return false; }else if(passwordAgain === '' || passwordAgain === null){ console.log('请再次输密码') return false; }else if(passwordAgain != password){ console.log('两次输入密码不一致') return false; }else{ alert('提交成功') } } &lt;/script&gt; 可以看到，我们需要很多if...else来进行各种情况的判断，而且我们每增加一种，都需要动表单提交的内部代码，而且复用性几乎为0。下面我们可以使用策略模式改变一下： &lt;form id='forgot-password-wrapper' action=&quot;&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;mobile&quot;&gt;手机号&lt;/label&gt; &lt;input type=&quot;number&quot; id=&quot;mobile&quot; name=&quot;mobile&quot;&gt; &lt;label for=&quot;code&quot;&gt;验证码&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;code&quot; name=&quot;code&quot;&gt; &lt;label for=&quot;password&quot;&gt;新密码&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt; &lt;label for=&quot;passwordAgain&quot;&gt;新密码&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;passwordAgain&quot; name=&quot;passwordAgain&quot;&gt; &lt;button id='push'&gt;确认&lt;/button&gt; &lt;/form&gt; &lt;script&gt; /* 单独抽离规则 */ const rules = { isEmpty: (val, message)=&gt;{ if(val === '' || val == null) return message }, checkLength: (val, message, minLength, maxLength)=&gt;{ if(String(val).length &lt; minLength || String(val).length &gt; maxLength) return message }, checkMobile: (val, message)=&gt;{ const mobileReg = /^[1][3,4,5,7,8,9][0-9]{9}$/ if(!mobileReg.test(val)) return message }, isEqual: (val, message, valAgain)=&gt;{ if(val != valAgain) return message } } /* 表单验校封装 */ const checkFrom = { mobile: (val)=&gt;{ const mobileIsEmpty = rules.isEmpty(val, '请输入手机号') const mobileIsLegitimate = rules.checkMobile(val, '请输入正确的手机号') const message = mobileIsEmpty || mobileIsLegitimate if(message) return message }, code: (val)=&gt;{ const codeIsEmpty = rules.isEmpty(val, '请输入验证码') const codeLength = rules.checkLength(val, '请输入6位数验证码', 6, 6) const message = codeIsEmpty || codeLength if(message) return message }, password: (val, valAgain)=&gt;{ const passwordIsEmpty = rules.isEmpty(val, '请输入密码') const passwordCheckLength = rules.checkLength(val, '请输入8-10位密码', 8, 10) const passwordAgainIsEmpty = rules.isEmpty(valAgain, '请再次输入密码') const passwordAgainCheckLength = rules.checkLength(valAgain, '再次确认密码请输入8-10位', 8, 10) const passwirdIsEqual = rules.isEqual(val, '两次输入密码不一致', valAgain) const message = passwordIsEmpty || passwordCheckLength || passwordAgainIsEmpty || passwordAgainCheckLength || passwirdIsEqual if(message) return message } } /* 表单提交 */ const forgotPasswordForm = document.getElementById('forgot-password-wrapper') forgotPasswordForm.onsubmit = (e)=&gt;{ e.preventDefault() /* 获取value */ const mobile = document.getElementById('mobile').value const code = document.getElementById('code').value const password = document.getElementById('password').value const passwordAgain = document.getElementById('passwordAgain').value /* 规则验校 */ const checkMobile = checkFrom.mobile(mobile) const checkCode = checkFrom.code(code) const checkPassword = checkFrom.password(password, passwordAgain) const message = checkMobile || checkCode || checkPassword if(message){ alert(message) }else{ alert('提交成功') } } &lt;/script&gt; 从代码数量上来看，可能感觉比之前还要多，但是极大的提高了代码的复用性，我们可以把rules和checkFrom单独封装，在使用的地方直接引用，随着rules的不断增加、checkFrom的扩展，我们在处理各种验校就方便多了。 总结 在实际业务中，如果遇到多重条件嵌套问题时候，就应该考虑使用策略模式来进行优化，这样可以提高代码复用性、可读性，易于维护。 ","link":"https://lonjinup.github.io/factorypattern/"},{"title":"vue基础整理","content":"Vue. js基础 Vue的基础结构 Vue创建方式有两种： 方式1:这种方法就是Vue官网演示的创建一个基础Vue项目: &lt;body&gt; &lt;div id='app'&gt; {{message}} &lt;p&gt; {{content}} &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el:'#app', data:{ message:'hello', content:'say hi' } }) &lt;/script&gt; &lt;/html&gt; 方式2:使用render函数和$mount &lt;body&gt; &lt;div id='app'&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ data:{ message:'hello', content:'say hi' }, render(h) { return h('div',[ h('p',this.message), h('p',this.content) ]) }, }).$mount(&quot;#app&quot;) &lt;/script&gt; render方法接收一个参数，这个参数是h函数，h函数的作用就是创建虚拟dom,render方法就是把h函数创建的虚拟dom返回。 $mount方法就是把虚拟dom转化为真实dom，渲染到浏览器。vue-cli脚手架就是采用这种方式。 Vue生命周期 Vue生命周期已经有很多文章了，这里就不多讲了，借用一下官网的图片： Vue的常用语法和概念 差值表达式 可以通过双大括号，将data中的成员，显示在模板中的任何位置。如果我们的内容中有html表达式，差值表达式会把html内容解析成文本，html的内容会被转义，如果我们想把内容当做html输出的话， 我们可以使用v-html指令。 指令 Vue中的内置指令有14个，可以帮我们做很多事情，如果这些指令不满足你的需求，比如说你想让文本框在页面打开的时候获取焦点，你可以创建自定义指令，在自定义指令中操作dom。如果想看详细的指令介绍，可以观看官方文档。 计算属性和侦听器 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： &lt;div id=&quot;example&quot;&gt; {{ message.split('').reverse().join('') }} &lt;/div&gt; 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以对于复杂的逻辑，就可以使用计算属性。 简单的说: 1.计算属性其实就是Vue实例的一个属性 2.计算属性一般依赖传统的Vue实例属性 3.计算属性一般是通过运算得到的属性 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;{{reversedMessage}}&lt;/div&gt; &lt;/body&gt; &lt;script src='vue.js'&gt;&lt;/script&gt; &lt;script&gt; var app=new Vue({ el:&quot;#app&quot;, data:{ msg:&quot;hellow world&quot; }, //计算属性简单写法 computed:{ reversedMessage(){ return this.msg.split('').reverse().join('') } }, }) &lt;/script&gt; 计算属性是基于它们的依赖进行缓存的，只有在它相关的依赖发生改变时才会重新求值，即计算属性会对计算出来的结果进行缓存，这就意味着只要message还没有发生改变，多次访问reversedMessage计算属性会立即返回之前的计算结果。 侦听属性 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动:侦听属性(watch) &lt;body&gt; &lt;!-- 侦听器 --&gt; &lt;div id='app2'&gt; &lt;p&gt;FullName: {{fullName}}&lt;/p&gt; &lt;p&gt;FirstName: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src='vue.js'&gt;&lt;/script&gt; &lt;script&gt; var app2=new Vue({ el: '#app2', data: { firstName: 'first', lastName: 'last', fullName: '' }, watch: { firstName(newName, oldName) { this.fullName = newName + ' ' + this.lastName; } } }) &lt;/script&gt; watch中的对象在data中已经定义了,当我们输入firstName后， watch监听每次修改变化的新值，然后计算输出fullName。也就是上面的代码中，fullName一开始被渲染出来的时候是空值。 watch的高级用法 handler方法和immediate属性:如上所述，一开始被渲染出来的时候，fullName是空值,如果想要一开始就让最初绑定的值执行该怎么办？我们只需要给firstName绑定一个handler方法，之前我们写的watch方法其实默认写的就是这个handler，Vue会去处理这个逻辑，最终编译出来其实就只这个handler，设置immediate:true代表如果在 wacth 里声明了firstName之后，就会立即先去执行里面的handler方法，如果为false就跟我们以前的效果一样，不会在绑定的时候就执行. &lt;body&gt; &lt;!-- 侦听器 --&gt; &lt;div id='app2'&gt; &lt;p&gt;FullName: {{fullName}}&lt;/p&gt; &lt;p&gt;FirstName: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src='vue.js'&gt;&lt;/script&gt; &lt;script&gt; var app2=new Vue({ el: '#app2', data: { firstName: 'first', lastName: 'last', fullName: '' }, watch: { firstName:{ handler(NewNmae,OldName){ this.fullName = NewNmae + ' ' + this.lastName; }, // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法 immediate: true } } }) &lt;/script&gt; 组件和插槽 组件：可复用的vue实例，一个组件封装了html\\js\\css，element-ui中组件都是一个个可复用的vue实例。 插槽：插槽可以让我们在自定义组件中挖一个坑，在使用这个组件的时候去填坑，这样做的目的是让组件更灵活， 比如：vue-router中的router-link这个组件，它里面的文本是在外部使用时， 被传递进来，内部是使用操作来进行占位的。 插件：vue的插件机制我们都用过，比如vue-router，vuex，都是插件，当然我们也可以来开发自己的插件，当我们模拟vue-router时，就自己来写一个插件 混入mixin：如果多个组件都有相同的选项，就可以使用混入mixin的方式，把相同的选项进行合并，让代码重用，这是让组件重用的一种方式。 响应式原理：官方文档 ","link":"https://lonjinup.github.io/vue-ji-chu-zheng-li/"},{"title":"快速上手TypeScript","content":"TypeScript基础知识梳理 之前一直打算看看ts，但一直沉迷摸🐟无法自拔，公司目前项目中也没有ts项目。今年手上正好有两个小程序项目，于是打算用ts写一下，感受一下ts的“魅力”。顺便整理了一下学习笔记，希望能帮到有需要的人。同时也用XMind做了知识图谱，有需要源文件的可以联系我。 安装与编译 安装 npm install -g typescript //mac下安装前面需要加sudo 编译 可以执行下面命令进行编译，会在当前目录下产生一个test.js文件 tsc test.ts 这样可能还是比较麻烦，我们可以借助插件方便我们提高效率： npm install -g ts-node 安装完后只需执行ts-node test.ts就可以在控制台查看输出结果。 原始数据类型 js中数据类型分两种，原始数据类型和对象类型，原始类型包括：布尔值、数字、字符串、null、undefined以及Symbol。 布尔值 在TypeScript中，使用boolean定义布尔值类型 let isStatus:boolean=true; 数字 使用number定义数值类型 let isNumber:number=1; //16进制(编译后显示10进制数字) let isNumber16:number:=0b1010; 字符串 使用string定义字符串类型： let isString:string='hello word'; let year:number=2020; let add:string=`${isString},${year}!`; 空值 JavaScript 没有空值（Void）的概念，在TypeScript中，可以用void表示没有任何返回值的函数. function alertName():void{ alert(&quot;my name is tom&quot;) } 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null。 let unusable: void = undefined; Null 和 Undefined 在TypeScript中可以使用null和undefined来定义这两个原始数据类型 let u:undefined=undefined; let n:null=null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说undefined类型的变量，可以赋值给number类型的变量，而void类型的变量不能赋值给number类型的变量： let num:number=undefined;//不会报错 let u:undefined; let num: number = u;//也不会报错 let u:void; let num:number=u;// Type 'void' is not assignable to type 'number'. 任意值 任意值（Any）用来表示允许赋值为任意类型。 什么是任意值类型 如果是一个普通类型，在赋值过程中改变类型是不被允许的： let renyiString:string='string'; renyiString=8; //Type 'number' is not assignable to type 'string'. 但如果类型是Any,类型，则允许被赋值为任意类型: let renyiString:any='string'; renyiString=8; 在任意值上访问任何属性都是允许的： let anyThis:any='hello'; console.log(anyThis.myName) console.log(anyThis.myName.firstName) 也允许调用任何方法： let anyThing: any = 'Tom'; anyThing.setName('Jerry'); anyThing.setName('Jerry').sayHello(); anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： let something; something = 'seven'; something = 7; something.setName('Tom'); 等于 let something: any; something = 'seven'; something = 7; something.setName('Tom'); 数组的类型 基础表示 「类型 + 方括号」表示法 let numbers:number[]=[1,2,3,4,5] 此时不允许出现其他类型，而且如果使用数组中push等方法，添加元素也得符合相应类型。 数组泛型 我们也可以使用数组泛型（Array Generic） Array&lt;elemType&gt; 来表示数组 let fibonacci:Array&lt;number&gt;=[1,2,3,4,] 如果数组中又有number类型又有string类型，则可以用｜符号来区别定义： let arr:(number|string)[]=['tom',1]; 数组中对象类型的定义 项目中经常遇到数组中有对象的存在，对于这种就比较麻烦了，比如： let arr:{name:string,age:number}[]=[ {name:'tom',age:18} ] 这样就比较麻烦了，我们可以使用ts中的类型别名来解决这个问题： type PeopleType={name:String,age:Number}; let arr:PeopleType[]=[ {name:'bob',age:19} ] 也可以用类型定义也可以解决： class PeopleType{ name:string; age:number } let arr:PeopleType[]=[ {name:'bob',age:19} ] 元组的使用和类型约束 在数组中如果里面又有string和number,可以使用｜来进行定义，但一定程度上并不严格。比如改成下面这种格式： let arr:(number|string)[]=[111,'222',111]; ts并没有报错，如果想要严格限制，则可以这样进行约束： let arr:[number,string,number]=[111,'222',111]; Interface接口 比如我们要做一个筛选，吧不符合条件的过滤出去，我们可能会这样写： const types=(name:string,age:number,height:number)=&gt;{ age&gt;=20 &amp;&amp; height&gt;=180 &amp;&amp; console.log('符合条件'); age&lt;=20 &amp;&amp; height &lt;180 &amp;&amp;console.log('不符合') }; types('tom',20,180) //符合条件 但如果又修改了一些需求，可能还会去大量变更代码，在开发中，代码能复用肯定是最好的，所以可以把一些重复的代码抽离出来： interface People{ name:string; age:number; height:number; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const choose=(people:People)=&gt;{ console.log(people.name+'----'+people.age+'---'+people.height) } const people={ name:'tom', age:18, height:178 } types(people); choose(people); 接口与类型别名的区别 看起来两者没有什么区别，但有个小细节：类型别名可以直接给类型，接口必须代表对象 type People=string; interface People{ name:string; age:number; height:number; } 如果传入的参数中有不确定项，我们可以使用 ?: 来进行处理： interface People{ name:string; age:number; height:number; say?:string }; const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178 } const people2={ name:'tom', age:18, height:178, say:'hello' } types(people); types(people2); 这时候又有新需求了，如何在后面加入任意多的字段？这时候我们就可以这么写： interface People{ name:string; age:number; height:number; say?:string; [propname:string]:any; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123 } types(people); 接口里的方法 接口不仅仅可以存属性，也可以存方法： interface People{ name:string; age:number; height:number; goto():string; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, goto(){ return 'hello' } } types(people) 接口和类的约束 在ES6中是有类的概念，类可以和接口相结合： interface People{ name:string; age:number; height:number; goto():string; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123, goto(){ return 'hello' } }; class newPeople implements People{ name='bob'; age=19; height:190; say:'hello'; add:'new add2'; addNumber:123; goto(){ return 'hi' } }; let a=new newPeople(); console.log(a.goto()) types(people) 接口的继承 接口与接口也是可以继承的： interface People{ name:string; age:number; height:number; say?:string; [propname:string]:any; goto():string; } const types=(people:newPeople)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123, goto(){ return 'hello' }, back(){ console.log(1) } } interface newPeople extends People{ back():void } types(people) 类的基本使用 首先，我们先创建一个类： class Test{ name='say' say(){ return this.name } }; 这就是平时所写的类，在ts中的继承和ES6的继承是一样的，关键字也是extends，比如我们这里新建个类，继承Text; class Test{ name='say' say(){ return this.name } }; class NewTest extends Test{ back(){ return 'hello' } } const tom=new NewTest(); console.log(tom.say()); console.log(tom.back()); super关键字的使用 如果想在say方法中后面加点东西，可以这么操作： class Test{ name='say' say(){ return this.name } }; class NewTest extends Test{ back(){ return 'hello' } say(){ return super.say()+'----hello' } } const tom=new NewTest(); console.log(tom.say()); console.log(tom.back()); ts中类的访问类型 ts中的访问类型就是基于三个关键字：private、protected以及pubilc这三种访问类型。看例子，先定义一个类，然后用这个类的对象，进行赋值： class Person{ name:string } const person=new Person(); person.name='tom'; console.log(person.name) pubilc 运行可以看到正常的输出内容，这是因为如果不对name的访问属性进行定义，那么他的默认属性就是pubilc,从字面意思来看，它的意思就是公用的，允许在类的内部和外部被调用。 class Person{ public name:string } const person=new Person(); person.name='tom'; console.log(person.name) private private的属性意思就是只允许在类的内部调用，不能在外部调用 class Person{ private name:string; public say(){ console.log(this.name+'-----hello'); } } const person=new Person(); person.name='tom';//报错 console.log(person.name)//报错 protected protected允许在类内以及继承的子类中使用，把刚刚的name改成protected属性，这时候在外部就会报错，这时候再写一个继承，代码如下： class Person{ protected name:string; public say(){ console.log(this.name+'-----hello'); } } const person=new Person(); person.name='tom';//报错 console.log(person.name)//报错 class NewPerson extends Person{ public back(){ console.log(this.name) } } const newperson=new NewPerson(); newperson.back()//正常 类的构造函数 首先新建一个类：Person,定义一个name，并在new的时候进行参数传递，然后打印出来，这时候我们就可以使用构造函数constructor : class Person{ pubilc name:string; constructor(name){ this.name=name } }; const person=new Person('tom'); console.log(person.name); 可以看到可以打印出来，但是上面写法有点麻烦，还可以再进行简化： class Person{ constructor(pubilc name:string){} }; const person=new Person('tom'); console.log(person.name); 类继承中的构造器写法 普通的书写方法上面已经演示了，在子类中使用构造函数需要用**super()**调用父类的构造函数，直接看代码： class Person{ constructor(pubilc name:string){} }; class Teacher extends Person{ constructor(pubilc age:number){ super() } }; const teacher=new Teacher(18); console.log(teacher.age+'---'+teacher.name); ts中类的Getter、Setter、static以及readonly 在上面中提到了访问类型private,它的最大用处就是封装一个书写，然后通过Getter和Setter去访问和修改： class Person{ constructor(private _age:number){ } } 如果想让别人知道，就可以使用Getter来实现，他并不是一个方法，只是一个属性： class Person{ constructor(private _age:number){ }; get age(){ return this._age } }; const person=new Person(30); console.log(person.age) 这时候你可能会觉得这不是多此一举吗？但在Getter中可以对 _age进行处理： class Person{ constructor(private _age:number){ }; get age(){ return this._age-10 } }; const person=new Person(30); console.log(person.age) 既然 _age是私有的，我们无法进行改变，这时候就可以用Setter进行改变： class Person{ constructor(private _age:number){ }; get age(){ return this._age } set age(age:number){ this._age=age } }; const person=new Person(30); person.age=20; console.log(person.age) 在类中，如果想用这个类的实例，就必须先进行new操作，但有没有一种方法不需要new就可以？ //常规方法 class Person{ say(){ return 'say hello' } }; const person=new Person(); console.log(person.say()); 在ts中，我们不想new的话可以这么写： class Person{ static say(){ return 'say hello' } }; console.log(Person.say()) readonly在初始化后赋值，以后就不能进行修改 class Person{ constructor(readonly name:string){} } let p=new Person('tom'); p.name='bob'//报错 console.log(p.name); 类的抽象类 abstract 用于定义抽象类和其中的抽象方法。它有几个特点： 抽象类是不允许实例化的 //错误演示 abstract class Person { public abstract say() } const tom=new Person()//无法创建抽象类的实例 抽象类中的抽象方法必须被子类实现： //错误演示 abstract class Person { abstract say(){ console.log('hello') } } class Tom extends Person{ say(){ console.log('say hello') } }; //正确方法 abstract class Person { abstract say() } class Tom extends Person{ say(){ console.log('say hello') } }; tsconfig.json配置 生成 我们可以通过tsc --init去生成ts配置文件: tsc --init //终端执行 编译 会生成一个tsconfig.json文件，我们在ts文件中可以随便写点什么： //测试tsconfig.json const test:string='tsconfig.json'; 然后打开tsconfig.json文件，找到complilerOptions属性下的removeComments:true（这个配置是编译后不输出注释），取消掉注释，然后执行命令： tsc 这时候打开生成的js文件，发现没有注释，说明成功。 include 、exclude 和 files 如果有多个ts文件，只想编译一个可以在ts配置项中加入include： &quot;include&quot;:[&quot;text.ts&quot;], 如果想除了某个文件不编译，剩下的都编译，可以使用exclude： &quot;exclude&quot;:[&quot;text.ts&quot;], files和include没有什么区别： &quot;files&quot;:[&quot;text.ts&quot;], compilerOptions配置 removeComments 这个配置意思就是编译后不输出注释 strict 这个设置为true,就代表严格执行ts语法，要严格按照ts语法来编写。 noImplicitAny 允许你的注解类型 any 不用特意表明，如果此时设置了true,看例子： //这时候编译会报错 function test(name) { return name; } //正确 function test(name:any) { return name; } strictNullChecks 意思就是，不强制检查null类型,此时如果配置为true看例子: //此时就不会报错 const test: string = null; outDir和rootDir 此项配置是来指定文件目录和打包后存放目录，rootDir为文件目录，outDir为打包后保存的目录 { &quot;outDir&quot;: &quot;./build&quot; , &quot;rootDir&quot;: &quot;./src&quot; , } 编译ES6语法 可以使用target和allowJs，target默认为true &quot;target&quot;:'es5' , // 这一项默认是开启的，你必须要保证它的开启，才能转换成功 &quot;allowJs&quot;:true, // 这个配置项的意思是联通 sourceMap sourceMap 简单说，Source map 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 noUnusedLocals 设置noUnusedLocals为true，编译代码： const name:tring='111'; export const age = &quot;text&quot;; 这时候就会报错，因为有name变量没有使用。 更多 更多可以查看 配置查询网站 联合类型和类型保护 联合类型 联合类型的意思就是允许一个类型有两种或者两种以上的类型: interface Test{ name:string; say:()=&gt;{ } } interface Test2{ name:string; call:()=&gt;{}; } function Tom(fun: Test | Test2){ console.log(fun.name) } 如果此时修改一下方法： function Tom(fun: Test | Test2){ fun.say() } //报错 这是因为只能访问两个类型的共有方法。 类型保护-类型断言 上面的方法，如果修改完报错，这时候我们可以用as来判断： interface Test { text: boolean; say(): void } interface Test2 { text: boolean; skill():string } function judgeWho(val: Waiter | Teacher) { if (val.text) { (val as Teacher).skill(); }else{ (val as Waiter).say(); } } const a={ text:true, skill:function():void{ console.log(1) }, say:function():void{ console.log(2) } } judgeWho(a) //1 类型保护-in语法 in方法与断言比较类似，使用方法如下： interface Person{ name:string; say:()=&gt;{ } } interface Person2{ name:string; todo:()=&gt;{ } }; function tom(val:Person|Person2){ if('todo' in val){ val.todo() }else{ val.say() } } 类型保护-typeof语法 可以用typeof方法来判断： function add(name:string|number,name2:string|number){ if(typeof name==='string'||typeof name2=='string'){ return name+'---'+name2 }else{ return name+name2 } } add(1,2) 类型保护-instanecof语法 如果要保护类型是一个对象，就可以使用instanceof： class NumObject{ num:number } function numbers(num1:object|NumObject,num2:object|NumObject){ if(num1 instanceof NumObject &amp;&amp; num2 instanceof NumObject){ return num1.num+num2.num } } Enum枚举类型 我们平时会有这种写法： function getName(status:any){ if(status===0){ return 'one' }else if(status===1){ return 'two' }else{ return 'three' } } console.log(getName(0)) 这么写可能有点麻烦，阅读起来还是有点麻烦，这时候可以这么写： const Status={ ONE:0, TWO:1, THREE:3 } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(getName(0)); 这时候我们的枚举就要上场了： enum Status{ ONE, TWO, THREE } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(getName(1)); 一样也可以输出，因为枚举是有对应数字值的，默认从0开始，当然也可以改变： enum Status{ ONE=1, TWO,//2 THREE//3 } 也可以进行返查操作： enum Status{ ONE, TWO, THREE } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(Status.ONE,Status[1]); 泛型 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 在函数中使用 我们先编写一个函数： function add(one:string,two:string){ return `${one}${two}` } console.log(add('a','b')) 这时候我们希望参数更加灵活一些，两个参数为number或者string： function add(one:string|number,two:string|number){ return `${one}${two}` } console.log(add('a','b')) 这么书写有些麻烦，这时候就可以使用泛型： function add&lt;T&gt;(one:T,two:T){ return `${one}${two}` } console.log(add&lt;string&gt;('a','b')) 在使用中，泛型通常用 &lt;T&gt; 来进行表示。泛型可以有多个吗？当然可以： function add&lt;T,P&gt;(one:T,two:P){ return `${one}${two}` } console.log(add&lt;string,number&gt;('a',2)) 同时泛型也支持类型推断： function add&lt;T,P&gt;(one:T,two:P){ return `${one}${two}` } console.log(add&lt;string,number&gt;('a',2)) 在类中使用 首先先写一个类,且接受参数为一个数组，数组里面存放string类型的数据： class List { constructor(private list:string[]) {}; getItem(index:number):string{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 这时候如果我们传递数组时候里面又想放数字怎么办： class List { constructor(private list:string[]|number[]) {}; getItem(index:number):string|number{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 这么写就比较复杂了,这时候就可以使用泛型来简化我们的代码： class List&lt;T&gt;{ constructor(private list:T[]) {}; getItem(index:number):T{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 发现上面的代码没有报错？因为类型推论，所以不会报错，严格意义上应该new的时候加上类型： const list=new List&lt;string&gt;(['girl','boy','wom']); 还有一种场景，传递过来是一个数组对象，这时候可以通过继承来解决： interface People{ name:string } class List&lt;T extends People&gt;{ constructor(private list:T[]) {}; getItem(index:number):string{ return this.list[index].name } }; const list=new List( [ {name:'boy'}, {name:'girl'} ] ); console.log(list.getItem(1)) 泛型约束 上面例子中，泛型可以为任意值，但有时候我们希望还是能稍微约束一下： function list&lt;T extends number|string&gt;(name:T){ return `${name}` } console.log(list&lt;number&gt;(1)) class List&lt;T extends number|string&gt; { constructor(private list:T[]) { }; getItem(index:number):T{ return this.list[index] } } const list=new List([1,2]) console.log(list.getItem(0)) Namespace命名空间 新建一个ts项目 首先，我们建立一个项目文件，然后npm init -y生成package.json文件，然后再tsc -init生成ts配置文件。 在根目录下新建index.html文件，再建立一个src和bulid目录，在src目录下新建一个index.js。 配置tsconfig.json文件，设置入口和输出目录（outDir和rootDir）。 打开index.html,引入js文件： &lt;script src=&quot;./build/index.js&quot;&gt;&lt;/script&gt; 在新建的ts文件中随便写点什么： console.log('hello'); 然后tsc编译一下，打开控制台，我们就可以看到了 编写一个小组件 在我们刚刚建立的index.ts文件，写一个header、content和footer组件： class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } class Page { constructor() { new Header(); new Content(); new Footer(); } } 然后在index.html中加一行js代码： &lt;script&gt;new Page();&lt;/script&gt; 这时候我们可以看到内容正常输出，但有一个问题，我们的Header、content和footer都暴露了出来，并不是只暴露一个page，这时候我们的命名空间就派上了用场： 命名空间 命名空间声明的关键词是namespace 比如声明一个namespace Home,需要暴露出去的类，可以使用export关键词，这样只有暴漏出去的类是全局的，其他的不会再生成全局污染了。 namespace Home { class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } export class Page { constructor() { new Header(); new Content(); new Footer(); } } } 这么写也是比较麻烦，因为我们需要引入两个文件，我们可以通过配置来让他成为一个文件，打开tsconfig.json,找到这一行： &quot;module&quot;:&quot;commonjs&quot; //修改为： &quot;module&quot;:&quot;amd 然后找到这一行： { &quot;outFile&quot;: &quot;./build/index.js&quot; } 子命名空间 如果在刚刚的组件中再写一个会怎么样？ namespace Components { export namespace SubComponents { export class Test {} } //someting ... } //读取 // Components.SubComponents.Test ts中使用import 首先建立一个文件compontent.ts,随便写点东西，然后使用export导出： export class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } export class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } export class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } 然后在index.ts中导入一下： import { Header, Content, Footer } from &quot;./compontent&quot;; export class Page{ constructor(){ new Header(); new Content(); new Footer(); } } 运行tsc编译，打开build中的index.js,可以看到代码是define开头的，这是 amd 规范的代码，不能直接在浏览器中运行，可以在 Node 中直接运行，所以我们还需要借助require.js的支持： &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js&quot;&gt;&lt;/script&gt; 然后在index.html中使用require.js写法： &lt;script&gt; require([&quot;page&quot;], function (page) { new page.default(); }); &lt;/script&gt; ","link":"https://lonjinup.github.io/kuai-su-shang-shou-typescript/"},{"title":"ES6新特性速览","content":"ES6新特性速览 虽然ES6现在基本都是前端必会内容了，网上也一堆文章了，但有些初学者可能看完还是记不住，所以便写一篇文章快速过一下ES6的一些新特性，加深印象。如果你还没有学ES6，还是推荐你阅读一下阮一峰的ES6入门指南。 ☀️如果觉得文章不错，欢迎点赞❤️、关注🌟、收藏📄！ 🚀ES6的新特性，大致可以归为4大类： 解决原有语法上的一些问题或者不足 对原有语法进行增强 全新的对象、全新的方法、全新的功能 全新的数据类型和数据结构（symbol、set、map、etc.） 块级作用域 作用域——某个成员能够起作用的范围,在ES2015之前，只有两种作用域：全局作用域和函数作用域。在ES2015中新增：块级作用域. //var 会变量提升，所以值会是undefined console.log(a);//undefined var a=1; //let 不会进行变量提升 console.log(b)//Cannot access 'b' before initialization let b=2; //块级作用域 { let c=20; } console.log(c) //c is not defined //const 申明时候必须赋值，且声明之后不可修改值，但可以修改对象中的某个值, //const 和let一样，也存在块级作用域 const a={name:'lonjin'}; a.name='tom'; console.log(a)//{ name: 'tom' } 经典面试题： for(var i=1;i&lt;6;i++){ setTimeout(() =&gt; { console.log(i) }, 0); } // 6 6 6 6 6 for(let i=1;i&lt;6;i++){ setTimeout(() =&gt; { console.log(i) }, 0); } // 1 2 3 4 5 数组的解构 基本使用 const arr=[1,2,3,4,5]; const [a, b, c] = arr; console.log(a,b,c) //1 2 3 只获取数组中第三个成员，方法，前面两个用逗号隔开，只声明第三个 const arr=[1,2,3]; const [,,c]=arr; console.log(c) //3 提取数组当前位置开始的所有成员(注意：三个点的用法只能在解构成员的最后使用) const arr=[1,2,3,4,5]; const [a,...arr2]=arr; console.log(arr2) //[ 2, 3, 4, 5 ] 可以给提取到的成员设置默认值，如果没有提取到值，就会赋为默认值 const arr=[1,2,3,4,5]; const [a,b,c,d,e,f=6]=arr; console.log(f) //6 对象的解构 基本使用(和数组解构基本相同) const data={name:&quot;lonjin&quot;,age:18}; const {name}=data; console.log(name) //lonjin 如果解构过程中遇到命名重复，可使用重命名的方式解决；设置默认值方法如下： const data={name:&quot;lonjin&quot;,age:18}; const name='tom'; const {name:newName}=data; console.log(newName) //lonjin 同样也可以设置默认值 const data={name:&quot;lonjin&quot;,age:18}; const name='tom'; const {name:newName,say='hello'}=data; console.log(newName+','+say) //lonjin,hello 解构常用方法，如console.log const {log}=console; log(1)//1 模版字符串 反引号定义字符串，若字符串中需要有反引号，可以用\\反斜杠转义 支持字符串中直接换行 支持插值表达式写法 `hello, ${name} const name='lonjin'; const text=`hello ${name} \\nuser age ${17+1}`; console.log(text) /* hello lonjin user age 18 */ 带标签的模板字符串 标签模板字符串的作用：是对我们的模板字符串进行加工处理，然后返回新内容 const name='lonjin', sex=true, age=18; function fn(strings,...args){ //string为text中普通string数组 console.log(strings) //[ 'my name is ', ',my age', ',my sex', '' ] //args为插值表达式中的值 console.log(args) // [ 'lonjin', 18, true ] //可以处理完数据return出去 let sex=args[2]?'man':woman; return strings[0]+args[0]+strings[1]+args[1]+strings[2]+sex } const text=fn`my name is ${name}my age${age}my sex ${sex}`; console.log(text) //my name is lonjinmy age18my sex man 字符串的扩展方法 includes():判断一个字符串是否包含在另一个字符串中,返回true或者false const str='erro type end.'; let f1=str.includes('erro'); console.log(f1)//true startsWith():判断当前字符串是否以另外一个给定的子字符串开头，返回true或者false const str='erro type end.'; let f2=str.startsWith('erro'); console.log(f2) //true endsWith:判断当前字符串是否以另外一个给定的子字符串结尾，返回true或者false const str='erro type end.'; let f3=str.endsWith('.'); console.log(f3) //true 参数默认值 函数参数默认值 function fn(status=false){ console.log(status) } fn(true) fn() /* true false */ 剩余参数 只能出现在最后，且只能使用一次 function fn(...args){ console.log(args) }; fn(1,2,3,4,5) //[ 1, 2, 3, 4, 5 ] 展开数组 想依次打印数组的值 let arr=['a','b','c']; console.log(...arr); //a b c 箭头函数 基本使用 //普通函数 function fn(num){ return num+1 }; console.log(fn(2)) //3 //箭头函数 const fn2=n=&gt;n+1; console.log(fn2(2))//3 箭头函数的this 箭头函数不会改变this指向，也就是说在箭头函数的外面拿到的this是什么，在箭头函数内部拿到的this也就是什么。 const name='tom' const people={ name:'lonjin', say(){ console.log(`this name is ${this.name}`) }, say2:()=&gt;{ console.log(`this name is ${this.name}`) } } people.say();//this name is lonjin people.say2()//this name is undefined 对象的扩展 对象字面量的增强 对象中属性名和属性值相同就可以缩写 函数表达式也可以缩写 动态属性名，可以直接使用计算属性名，使用方括号的形式使用 const username='lonjin'; const people={ age:18, username, [Math.random()]:123, } console.log(people) //{ age: 18, username: 'lonjin', '0.3692996732470484': 123 } Object.assign 将多个源对象中的属性复制到一个目标对象中；第一个参数为目标对象，如果有相同的，后面的会覆盖之前的值。 let obj={ a:123, b:456, } let obj2={ a:789, c:234 } let obj3={ d:123, c:678 } // const n=Object.assign(obj,obj2) //console.log(n)//{ a: 789, b: 456, c: 234 } const m=Object.assign(obj,obj2,obj3); console.log(m) //{ a: 789, b: 456, c: 678, d: 123 } Object.is 判断两个对象是否相等，和严格相等运算符(===)类似,但有两个值他们判断起来不太一样:+0与-0、NaN console.log( //0==false //true //+0 === -0 // true // NaN === NaN //false //Object.is(NaN,NaN) //true Object.is(+0,-0) //false ) Proxy 代理对象:为对象设置访问代理器 const people={ name:&quot;lonjin&quot;, age:18, } let peopleProxy=new Proxy(people,{ //监听读取 get(target,property){ // target为对象 // property为要读取的键 console.log(target,property) //{ name: 'lonjin', age: 18 } name //返回读取的内容 return property in target?target[property]:'none' }, //监听属性设置 set(target,property,value){ /*target---目标对象 property---要设置的键名 value---要设置的新值 */ if(property=='age'){ if(!Number.isInteger(value)){ throw new TypeError('Value must be a number') } } target[property]=value } }) console.log(peopleProxy.name)//lonjin console.log(peopleProxy.say)//none // peopleProxy.age='28';//throw new TypeError('Value must be a number') peopleProxy.age=20; defineProperty和Proxy的区别 defineProperty只能监视属性的读写，Proxy能够见识到更多对象操作。比如属性的删除： const people={ name:&quot;lonjin&quot;, age:18, }; let peopleProxy=new Proxy(people,{ deleteProperty(target,property){ //target 为代理对象 //property 为要删除的键名 delete target[property] } }); delete peopleProxy.age; console.log(peopleProxy) //{ name: 'lonjin' } Proxy更好的支持数组对象的监视,vue3中就采用了Proxy来实现数据监听 //监听数组push操作 let arr=[]; let newArray=new Proxy(arr,{ set(target,property,value){ target[property]=value; return true } }); newArray.push(1); newArray.push(2); console.log(newArray) //[1,2] 更多操作就不在这里写了，推荐大家一篇文章你不知道的 Proxy可以看一下。 Reflect Reflect成员方法就是Proxy处理对象的默认实现，Reflect并非一个构造函数，所以不能通过new()来调用。 let people={ name:'lonjin', say:'hello', } let peopleProxy=new Proxy(people,{ //如果我们没有定义get方法，那么Proxy会默认一个get方法如下，返回Reflect get(target,property){ return Reflect.get(target,property) } }) Reflect最大作用是提供了一套完整的对象调用方法 let people={ name:'lonjin', say:'hello', } console.log('name' in people) console.log(Reflect.has(people,'name')) console.log(delete people['say']); console.log(Reflect.deleteProperty(people,'say')); console.log(Object.keys(people)); console.log(Reflect.ownKeys(people)); Reflect一共有13个静态方法，更多查看MDN-Reflect Class 基本使用 class People{ constructor(name){ this.name=name } say(){ console.log(`this name ${this.name}`) } }; let user=new People('lonjin'); user.say() //this name lonjin 静态方法 静态方法可以直接通过类型本身去调用，而实例方法需要通过这个类型构造的实例对象去调用，只需要在方法前面加static constructor(name){ this.name=name } say(){ console.log(`this name ${this.name}`) } static created(name){ return new People(name) } }; let user=People.created('lonjin'); user.say() //this name lonjin class的继承 class继承只需要用关键词extends实现，super为父类构造函数 class People{ constructor(name){ this.name=name } say(){ console.log(`this name ${this.name}`) } }; class Child extends People{ constructor(name,age){ super(name); this.age=age; } message(){ console.log(`my name is${this.name},my age is ${this.age}`) } }; let tom=new Child('tom',18); tom.message(); //static Set数据结构 set的内部成员是不允许重复的，也就是每一个值在set中都是唯一的。我们平时可以利用Set来实现数组去重 //基本使用 let setArray=new Set(); setArray.add(1); setArray.add(2); setArray.add(3); setArray.add(4); setArray.add(4); console.log(setArray) //Set(4) { 1, 2, 3, 4 } //遍历 setArray.forEach(i=&gt;{console.log(i)}); //1 2 3 4 //获取数量 console.log(setArray.size) //4 //删除(返回true或者false) console.log(setArray.delete(1))//true //判断是否有某个值(返回true或者false) console.log(setArray.has(3))//true //清空 setArray.clear(); 数组去重 Array.from+set //方法1 let arr=[1,2,3,4,5,5,6]; let newArr=Array.from(new Set(arr)); console.log(newArr) //[ 1, 2, 3, 4, 5, 6 ] 展开运算符 let arr=[1,2,3,4,5,5,6]; console.log([...new Set(arr)]); //[ 1, 2, 3, 4, 5, 6 ] Map js的对象本质上是键值对的集合，但是传统上只能用字符串当作键。所以ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。与对象最大的区别就是可以使用任意类型作为键，而对象只能使用字符串作为键 let m=new Map(); let n={name:'tom'}; // 设置值 m.set(n,18) //读取值 console.log(m.get(n))//18 //判断是否有某个值 // m.has(); //删除 // m.delete() //清空 // m.clear() //遍历 m.forEach((val,key)=&gt;{ console.log(val,key) }) Symbol 一种全新的原始数据类型， 表示一个独一无二的值。主要解决对象中属性名冲突的问题 //创建一个独一无二的属性名，且外部无法访问到(模拟私有成员) let name=Symbol(); let people={ [name]:'lonjin', say(){ console.log(this[name]) } }; people.say()//lonjin 如果我们希望重新使用同一个Symbol值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局 //全局注册表 let n1=Symbol.for('name'); let n2=Symbol.for('name'); console.log(n1===n2)//true 获取对象中的键时候，如果使用for in，就获取不到Symbol类型的键；必须使用Object.getOwnPropertySymbols()进行获取。 let people={ [Symbol()]:'tom', age:18 } console.log(Object.keys(people)) console.log(JSON.stringify(people)) console.log(Object.getOwnPropertySymbols(people)) /* [ 'age' ] {&quot;age&quot;:18} [ Symbol() ] */ for of方法 ES6借鉴其他语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。 遍历数组 let arr=[1,2,3,4,5]; for(const item of arr){ console.log(item) } //1 2 3 4 5 可以使用break进行退出 //可以使用break进行退出 let arr=[1,2,3,4,5]; for(const item of arr){ console.log(item) if(item&gt;3){ break } } //1 2 3 4 遍历Set let n=new Set([1,2,3,4]); for(const item of n){ console.log(item) } //1 2 3 4 遍历Map可以配合数组结构语法，直接获取键值 let n=new Map(); n.set('name','tom'); n.set('age',18); for(const [key,value] of n){ console.log(key+'----'+value) } /* name----tom age----18 */ 可迭代接口 ES6提供了Iterable接口，实现了Iterable接口就是for...of的前提 let arr=new Set([1,2,3,4,5]); const iterator=arr[Symbol.iterator](); console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) /* { value: 1, done: false } { value: 2, done: false } { value: 3, done: false } { value: 4, done: false } { value: 5, done: false } { value: undefined, done: true } */ 实现可迭代接口 由于for...of方法不能便利普通对象，我们可以手动实现一下 const obj = { store: ['foo', 'bar', 'baz'], [Symbol.iterator]: function () { let index = 0 const self = this return { next: function () { const result = { value: self.store[index], done: index &gt;= self.store.length } index++ return result } } } } for(const item of obj){ console.log(item) } //foo bar baz 迭代器模式 开发一个任务清单应用 // 迭代器设计模式 const todos = { life: ['吃饭', '睡觉', '打豆豆'], learn: ['语文', '数学', '外语'], work: ['喝茶'], // 提供统一遍历访问接口 each: function (callback) { const all = [].concat(this.life, this.learn, this.work) for (const item of all) { callback(item) } }, // 提供迭代器（ES2015 统一遍历访问接口） [Symbol.iterator]: function () { const all = [...this.life, ...this.learn, ...this.work] let index = 0 return { next: function () { return { value: all[index], done: index++ &gt;= all.length } } } } } Generator Generator函数是ES6提供的一种异步编程解决方案,来避免异步编程中回调嵌套过深。 基本使用 function * fn(){ console.log('1') yield 100 console.log('2') yield 200 console.log('3') yield 300 } const f=fn(); console.log(f.next()) console.log(f.next()) console.log(f.next()) console.log(f.next()) /* 1 { value: 100, done: false } 2 { value: 200, done: false } 3 { value: 300, done: false } { value: undefined, done: true } */ 使用 Generator 函数实现 iterator 方法 const todos = { life: ['吃饭', '睡觉', '打豆豆'], learn: ['语文', '数学', '外语'], work: ['喝茶'], [Symbol.iterator]: function * () { const all = [...this.life, ...this.learn, ...this.work] for (const item of all) { yield item } } } for (const item of todos) { console.log(item) } ","link":"https://lonjinup.github.io/es6-tx/"},{"title":"JavaScript-函数式编程","content":"函数式编程 为什么要学函数式编程？ 函数式表成是随着React的流行收到越来越多的关注（React的高阶组件使用了高阶函数来实现，高阶函数就是函数式编程的一个特性。Redux也使用了函数式编程的思想。） Vue3也开始拥抱函数式编程 函数式编程可以抛弃this 打包过程中可以更好的利用tree shaking过滤无用代码 方便测试、方便并行处理 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda 什么是函数式编程？ 函数式编程，缩写FP，是一种编程范式，也是一种编程风格，和面向对象是并列的关系。函数式编程我们可以认为是一种思维模式，加上实现方法。其思维方式就是把现实世界事物和事物之间的联系抽象到程序世界（是对运算过程进行抽象） 常听说的编程范式还有面向过程编程（按照步骤来实现）、面向对象编程（把现实中的事物抽象成类和对象，通过封装、继承和多态来演示不同事物之间的联系）。 函数式编程和面向对象编程的不同 从思维方式上来说,面向对象编程是对事物的抽象，而函数式编程是对运算过程的抽象 对于函数式编程思维方式的理解 程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数。 函数式编程中的函数指的不是程序中的函数Function，而是数学中的函数即映射关系，例如：y=sin(x)，是这种x和y的关系 相同的输入时钟要得到相同的输出（纯函数） 函数式编程用描述数据（函数）之间的映射 //非函数式 let num1=1, num2=2; let sum=num1+num2; console.log(sum); //函数式 function add(m,n){ return m+n; }; let sum2=add(3,4); console.log(sum2); 函数式编程的前置知识 函数是一等公民 在JS中函数就是一个普通的对象，我们可以把函数存储到变量/数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new Function('alert(1)')来构造一个新的函数。 函数可以存储在变量中: // 把函数赋值给变量 let fn = function () { console.log(&quot;hi&quot;) } fn() // 一个示例 const BlogController = { index (posts) { return Views.index(posts) }, show (post) { return Views.show(post) }, create (attrs) { return Db.create(attrs) }, update (post, attrs) { return Db.update(post, attrs) }, destroy (post) { return Db.destroy(post) } } // 优化 赋值的是Views的index方法，不是方法的调用 const BlogController = { index: Views.index, show: Views.show, create: Db.create, update: Db.update, destroy: Db.destroy } 函数可以作为参数 函数可以作为返回值 高阶函数 高阶函数英文叫Higher-order function。JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 1.接受一个或多个函数作为输入 2.输出一个函数 函数可以作为参数 //模拟数组中的某些操作 // forEach // 定义一个遍历数组的并对每一项做处理的函数，第一个函数是一个数组，第二个参数是一个函数。 function forEach(array,fn){ for(let i=0;i&lt;array.length;i++){ fn(array[i]) } }; let arr=[1,2,3,4,5]; forEach(arr,items=&gt;{ console.log(items) }) // filter // 遍历数组，并把满足条件的元素存储成数组，再进行返回 function filter(array,fn){ let newArr=[]; for(let i=0;i&lt;array.length;i++){ if(fn(array[i])){ newArr.push(array[i]) } }; return newArr } let a=filter(arr,item=&gt;item%2==0) console.log(a) 函数做为返回值 // test1:一个函数返回另一个函数 function todo(){ let text='hello world'; return function(){ console.log(text) } } //方式1 调用 const fn=todo() fn() //方式2 调用 todo()() //test2:让函数只执行一次 function once(fn){ let status=false; return function(){ if(!status){ status=true; return fn.apply(this,arguments) } } }; let pay = once(function(money){ console.log(`支付了 ${money}元`) }) pay(100) pay(200) 使用高阶函数的意义 抽象可以帮我们屏蔽细节，我们只需要知道我们的目标和解决这类问题的函数，我们不需要关心实现的细节 高阶函数是用来抽象通用的问题 用高阶函数模拟常用函数 map:便利数组中每一个元素，然后生成新的数组 const map=(array,fn)=&gt;{ let arr=[]; for(let i of array){ arr.push(fn(i)) } return arr } let arr=[1,2,3,4,5]; arr=map(arr,v=&gt;v*v); console.log(arr) every:数组中的每一个元素是否都匹配我们指定的一个条件，如果都满足返回true，如果不满足返回false const every=(array,fn)=&gt;{ let status=true; for(let i of array){ status=fn(i) if(!status){ break } } return status } let arr=[1,2,3,4,5]; let n=every(arr,v=&gt;v&gt;=1); console.log(n) some:判断数组中是否有一个元素满足我们指定的条件，满足是true，都不满足为false const some=(array,fn)=&gt;{ let status=false; for(let i of array){ status=fn(i); if(status){ break; } } return status } let arr=[4,5,6,7]; let n=some(arr,v=&gt;v&gt;7); console.log(n); 闭包 函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除。但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。闭包的核心作用就是把函数内部成员的作用范围延长。 function makeFn () { let msg = 'Hello function' } // 正常情况下，执行完makeFn，里面的变量msg会释放掉 // 但是下面的情况 function makeFn () { let msg = 'Hello function' return function () { console.log(msg) } } // 在上面函数中，返回了一个函数，而且在函数中还访问了原来函数内部的成员，就可以称为闭包 const fn = makeFn() fn() // fn为外部函数，当外部函数对内部成员有引用的时候，那么内部的成员msg就不能被释放。当我们调用fn的时候，我们就会访问到msg。 //注意的点： //1、我们可以在另一个作用域调用makeFn的内部函数 //2、当我们调用内部函数的时候我们可以访问到内部成员 闭包应用 计算数字的次方 function pow(power){ return function(number){ return Math.pow(number,power) } } //求平方 let pow2=pow(2); console.log(pow2(2)) //立方 let pow3=pow(3); console.log(pow3(2)) 计算不同级别的员工工资(不同员工基本工资相等，绩效不同) function peopleMoney(moeny){ return function(value){ return moeny+value } } let lv1=peopleMoney(1000); let lv2=peopleMoney(2000); console.log(lv1(200)) console.log(lv2(1300)) 纯函数 相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，如y = f(x) let numbers = [1, 2, 3, 4, 5] // 纯函数 // 对于相同的函数，输出是一样的 // slice方法，截取的时候返回截取的函数，不影响原数组 numbers.slice(0, 3) // =&gt; [1, 2, 3] numbers.slice(0, 3) // =&gt; [1, 2, 3] numbers.slice(0, 3) // =&gt; [1, 2, 3] // 不纯的函数 // 对于相同的输入，输出是不一样的 // splice方法，返回原数组，改变原数组 numbers.splice(0, 3) // =&gt; [1, 2, 3] numbers.splice(0, 3) // =&gt; [4, 5] numbers.splice(0, 3) // =&gt; [] // 下面函数也是纯函数 function getSum (n1, n2) { return n1 + n2 } console.log(getSum(1, 2)) // 3 console.log(getSum(1, 2)) // 3 console.log(getSum(1, 2)) // 3 函数式编程不会保留计算中间的结果，所以变量是不可变的(无状态的) 我们也可以把一个函数的执行结果交给另一个函数处理 Lodash——纯函数js库 Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。 安装： npm init -y npm i lodash 使用： var _ = require('lodash'); //数组合并 var arr=[1,2,3] var newArr=_.concat(arr,[4,5,6],[7,8,9]) console.log(newArr) //数组反转 let className=['tom','bob','nike']; console.log(_.reserve(className)) console.log(className) // 数组的翻转不是纯函数，因为会改变原数组。这里的reserve是使用了数组的reverse，所以也不是纯函数 纯函数的好处 可缓存 因为对于相同的输入始终有相同的结果，那么可以把纯函数的结果缓存起来，可以提高性能。 const _ = require('lodash'); /* _.memoize(func, [resolver]):创建一个会缓存 func 结果的函数。 如果提供了 resolver ，就用 resolver 的返回值作为 key 缓存函数的结果。 默认情况下用第一个参数作为缓存的 key。 func 在调用时 this 会绑定在缓存函数上。*/ //计算两个数字的和 function add(m,n){ console.log('once') return m+n } let fn=_.memoize(add); console.log(fn(4,5)); console.log(fn(4,5)); console.log(fn(4,5)); // 输出的once只执行了一次，因为其结果被缓存下来了 模拟_.memoize const _ = require('lodash'); function add(m,n){ console.log('once') return m+n } function memoize (f) { let cache = {} return function () { // arguments是一个伪数组，所以要进行字符串的转化 let key = JSON.stringify(arguments) console.log(key) // 如果缓存中有值就把值赋值，没有值就调用f函数并且把参数传递给它 cache[key] = cache[key] || f.apply(f,arguments) console.log(cache) return cache[key] } } let getAreaWithMemory1 = memoize(add) console.log(getAreaWithMemory1(4,5)) /* 输出 {&quot;0&quot;:4,&quot;1&quot;:5} once { '{&quot;0&quot;:4,&quot;1&quot;:5}': 9 } 9 */ 可测试 纯函数让测试更加的方便 并行处理 多线程环境下并行操作共享的内存数据很可能会出现意外情况。纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 虽然JS是单线程，但是ES6以后有一个Web Worker，可以开启一个新线程 柯里化 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 当函数有多个参数的时候，我们可以对函数进行改造。我们可以调用一个函数，只传递部分的参数（这部分参数以后永远不变），然后让这个函数返回一个新的函数。新的函数传递剩余的参数，并且返回相应的结果。 // 下面这段代码是解决了不纯的函数的问题，但是里面出现了硬编码 function checkAge (age) { let mini = 18 return age &gt;= mini } // 普通的纯函数 function checkAge (min, age) { return age &gt;= min } console.log(checkAge(18, 20)) //true console.log(checkAge(18, 24)) //true console.log(checkAge(20, 24)) //true // 经常使用18，这段代码是重复的。避免重复 function checkAge (min) { return function (age) { return age &gt;= min } } let checkAge18 = checkAge(18) let checkAge20 = checkAge(20) console.log(checkAge18(20)) //true console.log(checkAge18(24)) //true Lodash中的柯里化 —— curry() 功能：创建一个函数，该函数接收一个或多个 func的参数，如果 func 所需要的参数都被提供则执行 func 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。 参数：需要柯里化的函数 返回值：柯里化后的函数 //案例 const _ = require('lodash'); function getSum(a,b,c){ return a+b+c } const curried=_.curry(getSum) console.log(curried(1,2,3)) console.log(curried(1)(2)(3)) console.log(curried(1)(2,3)) 柯里化的实现 实现一个柯里化转换函数要进行分析 1.入参出参：调用传递一个纯函数的参数，完成之后返回一个柯里化函数 2.入参情况分析： 如果curried调用传递的参数和getSum函数参数个数相同，那么立即执行并返回调用结果 如果curried调用传递的参数是getSum函数的部分参数，那么需要返回一个新的函数，并且等待接收getSum的其他参数 3 重点关注： 获取调用的参数 判断个数是否相同 function getSum (a, b, c) { return a + b + c } // 模拟柯里化函数 function curry (func) { // 取名字是为了下面实参小于形参的时候用的 return function curriedFn(...args) { // 判断实参和形参的个数 if(args.length &lt; func.length) { return function() { // 等待传递的剩余参数，如果剩余函数的参数加上之前的参数等于形参，那么就返回func // 第一部分参数在args里面，第二部分参数在arguments里面，要将两个合并并且展开传递（使用...） // concat函数要合并两个数组，arguments为伪数组，所以用Array.from进行转换 return curriedFn(...args.concat(Array.from(arguments))) } } // 如果实参大于等于形参的个数 // args是剩余参数，是个数组形式，而返回的时候要展开（使用...） return func(...args) } } // test const curriedTest = curry(getSum) console.log(curriedTest(1, 2, 3)) // 6 console.log(curriedTest(1)(2, 3)) // 6 console.log(curriedTest(1, 2)(3)) // 6 总结 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数（比如match函数新生成了haveSpace函数，里面使用了闭包，记住了我们给传递的正则表达式的参数） 这是一种对函数参数的'缓存'（使用了闭包） 让函数变的更灵活，让函数的粒度更小 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能 函数组合 如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数。函数组合默认是从右到左执行 //例子：有一个数组，需要获取到数组最后一个元素 function reverse(array){ return array.reverse() } function first(array){ return array[0] } //es5 /* function getFirst(f,n){ return function(value){ return f(n(value)) } } */ //es6 const getFirst=(f,n)=&gt;value=&gt;f(n(value)); let compose=getFirst(first,reverse); console.log(compose([1,2,3,4,5])) //5 组合函数模拟 有一个数组，需要获取到数组中最后一个元素并换成大写 const reverse = arr =&gt; arr.reverse(); const first = arr =&gt; arr[0]; const toUpper = s =&gt; s.toUpperCase(); function compose (...args) { // 返回的函数，有一个传入的初始参数即value return function (value) { // ...args是执行的函数的数组，从右向左执行那么数组要进行reverse翻转 // reduce: 对数组中的每一个元素，去执行我们提供的一个函数，并将其汇总成一个单个结果 // reduce的第一个参数是一个回调函数，第二个参数是acc的初始值，这里acc的初始值就是value // reduce第一个参数的回调函数需要两个参数，第一个参数是汇总的一个结果，第二个参数是如果处理汇总的结果的函数并返回一个新的值 // fn指的是数组中的每一个元素（即函数），来处理参数acc，完成之后下一个数组元素处理的是上一个数组的结果acc return args.reverse().reduce(function (acc, fn) { return fn(acc) }, value) } } //test const fTest = compose(toUpper, first, reverse) console.log(fTest(['one', 'two', 'three'])) // THREE // ES6的写法（函数都变成箭头函数） const compose = (...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value) 函数组合-结合律 什么是函数组合结合律？ 下面三个情况结果一样，我们既可以把 g 和 h 组合，还可以把 f 和 g 组合 //伪代码 // 结合律（associativity） let f = compose(f, g, h) let associative = compose(compose(f, g), h) == compose(f, compose(g, h)) // true 实际案例 const _ = require('lodash'); // 方式一 const f = _.flowRight(_.toUpper, _.first, _.reverse) // 方式二 const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse) // 方式三 const f = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse)) // 无论上面那种写法，下面都输出THREE这个相同的结果 console.log(f(['one', 'two', 'three'])) // THREE 如何测试函数组合 如果我们运行的结果和我们的预期不一致，我们怎么调试呢？我们怎么能知道中间运行的结果呢？ 下面这个输入NEVER SAY DIE要对应输出nerver-say-die const _ = require('lodash') // 这里split函数需要传入两个参数，且我们最后调用的时候要传入字符串，所以字符串要在第二个位置传入，这里我们需要自己封装一个split函数 // _.split(string, separator) // 将多个参数转成一个参数，用到函数的柯里化 const split = _.curry((sep, str) =&gt; _.split(str, sep)) // 大写变小写，用到toLower()，因为这个函数只有一个参数，所以可以在函数组合中直接使用 // 这里join方法也需要两个参数，第一个参数是数组，第二个参数是分隔符，数组也是最后的时候才传递，也需要交换 const join = _.curry((sep, array) =&gt; _.join(array, sep)) const f = _.flowRight(join('-'), _.toLower, split(' ')) console.log(f('NEVER SAY DIE')) //n-e-v-e-r-,-s-a-y-,-d-i-e 但是最后的结果却不是我们想要的，那么我们怎么调试呢？ // NEVER SAY DIE --&gt; nerver-say-die const _ = require('lodash') const split = _.curry((sep, str) =&gt; _.split(str, sep)) const join = _.curry((sep, array) =&gt; _.join(array, sep)) // 我们需要对中间值进行打印，并且知道其位置，用柯里化输出一下 const log = _.curry((tag, v) =&gt; { console.log(tag, v) return v }) // 从右往左在每个函数后面加一个log，并且传入tag的值，就可以知道每次结果输出的是什么 const f = _.flowRight(join('-'), log('after toLower:'), _.toLower, log('after split:'), split(' ')) // 从右到左 //第一个log：after split: [ 'NEVER', 'SAY', 'DIE' ] 正确 //第二个log: after toLower: never,say,die 转化成小写字母的时候，同时转成了字符串，这里出了问题 console.log(f('NEVER SAY DIE')) //n-e-v-e-r-,-s-a-y-,-d-i-e // 修改方式，利用数组的map方法，遍历数组的每个元素让其变成小写 // 这里的map需要两个参数，第一个是数组，第二个是回调函数，需要柯里化 const map = _.curry((fn, array) =&gt; _.map(array, fn)) const f1 = _.flowRight(join('-'), map(_.toLower), split(' ')) console.log(f1('NEVER SAY DIE')) // never-say-die FP模块 函数组合的时候用到很多的函数需要柯里化处理，我们每次都处理那些函数有些麻烦，所以lodash中有一个FP模块 lodash 的 fp 模块提供了实用的对函数式编程友好的方法 提供了不可变 auto-curried iteratee-first data-last （函数之先，数据之后）的方法 const fp=require('lodash/fp'); // 函数置先，数据置后 console.log(fp.map(fp.toUpper,['a','b','c','d'])) //规则置前，数据置后 console.log(fp.split(' ')('hello word')) console.log(fp.split(' ','hello word')) Point Free Point Free是一种编程风格，具体的实现是函数的组合。Point Free： 我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。 不需要指明处理的数据 只需要合成运算过程 需要定义一些辅助的基本运算函数 例子1 /*将Hello World 转化为 hello_world */ const fp=require('lodash/fp'); const f=fp.flowRight(fp.replace(/\\s+/g,'_'),fp.toLower); console.log(f('Hello World')) //hello_world 例子2 //world wild web --&gt;W. W. W //思路： //把一个字符串中的额首字母提取并转换成大写，使用. 作为分隔符 const fp = require('lodash/fp') const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(' ')) console.log(firstLetterToUpper('world wild web')) //W. W. W // 上面的代码进行了两次的遍历，性能较低 // 优化 const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(' ')) console.log(firstLetterToUpper('world wild web')) //W. W. W Functor 为什么要学函子？ 函子(representative functor)是范畴论里的概念，指从任意范畴到集合范畴的一种特殊函子。 我们没有办法避免副作用，但是我们尽可能的将副作用控制在可控的范围内，我们可以通过函子去处理副作用，我们也可以通过函子去处理异常，异步操作等。 什么是Functor 容器：包含值和值的变形关系(这个变形关系就是函数) 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map方法可以运行一个函数对值进行处理(变形关系) class Container{ constructor(value){ // 这个函子的值是保存在内部的，不对外公布 // _下划线的成员都是私有成员，外部无法访问，值是初始化的传的参数 this._value=value } //有一个对外的方法map，接收一个函数（纯函数），来处理这个值 map(fn){ // 返回一个新的函子，把fn处理的值返回给函子，由新的函子来保存 return new Container(fn(this._value)) } } // 创建一个函子的对象 let r=new Container(5) .map(n=&gt;n+1) .map(n=&gt;n*n) // 返回了一个container函子对象，里面有值是36，不对外公布 console.log(r) //Container { _value: 36 } 上面还是面向对象的编程思想，要修改成函数式编程的思想，需要避免使用new class Container { //使用类的静态方法，of替代了new Container的作用 static of (value) { return new Container(value) } constructor (value) { this._value = value } map (fn) { return Container.of(fn(this._value)) } } const r = Container.of(5) .map(x=&gt;x+2) // 7 .map(x=&gt; x**2) // 49 console.log(r) // Container { _value: 49 } 总结 函数式编程的运算不直接操作值，而是由函子完成 函子就是一个实现了 map 契约的对象 我们可以把函子想象成一个盒子，这个盒子里封装了一个值 想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理 最终 map 方法返回一个包含新值的盒子（函子） 遗留问题：在上面说的函子中，如果value是null undefined，怎么办？ Container.of(null) .map(x=&gt;x.toUpper) // 报错，使得函数不纯 下面这些函子就是处理不同问题的函数 MyBe函子 MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围） class MayBe { static of (value) { return new MayBe(value) } constructor (value) { this._value = value } map(fn) { // 判断一下value的值是不是null和undefined，如果是就返回一个value为null的函子，如果不是就执行函数 return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value)) } // 定义一个判断是不是null或者undefined的函数，返回true/false isNothing() { return this._value === null || this._value === undefined } } const r = MayBe.of('hello world') .map(x =&gt; x.toUpperCase()) console.log(r) //MayBe { _value: 'HELLO WORLD' } // 如果输入的是null，是不会报错的 const rnull = MayBe.of(null) .map(x =&gt; x.toUpperCase()) console.log(rnull) //MayBe { _value: null } 但是这里有一个问题就是，如果map中间有好几步，最后返回是null，并不知道是哪一个步骤返回的。解决这个问题，需要看下一个函子。 Either函子 Either 两者中的任何一个，类似于 if...else...的处理 当出现问题的时候，Either函子会给出提示的有效信息， 异常会让函数变的不纯，Either 函子可以用来做异常处理 // 因为是二选一，所以要定义left和right两个函子 class Left { static of (value) { return new Left(value) } constructor (value) { this._value = value } map (fn) { return this } } class Right { static of (value) { return new Right(value) } constructor (value) { this._value = value } map (fn) { return Right.of(fn(this._value)) } } let r1 = Right.of(12).map(x =&gt; x + 2) let r2 = Left.of(12).map(x =&gt; x + 2) console.log(r1) // Right { _value: 14 } console.log(r2) // Left { _value: 12 } // 为什么结果会不一样？因为Left返回的是当前对象，并没有使用fn函数 // 那么这里如何处理异常呢？ // 我们定义一个字符串转换成对象的函数 function parseJSON(str) { // 对于可能出错的环节使用try-catch // 正常情况使用Right函子 try{ return Right.of(JSON.parse(str)) }catch (e) { // 错误之后使用Left函子，并返回错误信息 return Left.of({ error: e.message }) } } let rE = parseJSON('{name:xm}') console.log(rE) // Left { _value: { error: 'Unexpected token n in JSON at position 1' } } let rR = parseJSON('{&quot;name&quot;:&quot;xm&quot;}') console.log(rR) // Right { _value: { name: 'xm' } } console.log(rR.map(x =&gt; x.name.toUpperCase())) // Right { _value: 'XM' } ","link":"https://lonjinup.github.io/javascript01-hssbc/"},{"title":"小程序自定义TabBar以及keep-alive","content":"小程序自定义TabBar后如何实现keep-alive 前段时间写了小程序实现TabBar创意动画和小程序开发技巧后，有小伙伴提问到，自定义TabBar是可以做很多交互，但点击切换TabBar页面，都会伴随着组件的销毁和重建，这点确实会影响性能。这里就提供一个方案来实现“keep-alive”。如有更好的方案，欢迎评论区交流。欢迎点赞和收藏~ 自定义TabBar方案 虽然在之前文章提到过了，本次采用组件化实现 我们可以新建一个home文件夹，在home/index.wxml中写一个tabBar，然后把TabBar页面写成组件，然后点击TabBar切换相应的组件展示就可以。代码如下： wxml部分 &lt;!-- home页面 --&gt; &lt;view id='index'&gt; &lt;!-- 自定义头部 --&gt; &lt;head name='{{name}}' bgshow=&quot;{{bgshow}}&quot; backShow='false'&gt;&lt;/head&gt; &lt;!-- 首页 --&gt; &lt;index change='{{activeIndex==0}}'&gt;&lt;/index&gt; &lt;!-- 购物车 --&gt; &lt;cart change='{{activeIndex==1}}'&gt;&lt;/cart&gt; &lt;!-- 订单 --&gt; &lt;order change='{{activeIndex==2}}'&gt;&lt;/order&gt; &lt;!-- 我的 --&gt; &lt;my change='{{activeIndex==2}}'&gt;&lt;/my&gt; &lt;!-- tabbar --&gt; &lt;view class=&quot;tab ios&quot;&gt; &lt;view class=&quot;items {{activeIndex==index?'active':''}}&quot; wx:for=&quot;{{tab}}&quot; bindtap=&quot;choose&quot; data-index='{{index}}' wx:key='index' wx:for-item=&quot;items&quot;&gt; &lt;image wx:if=&quot;{{activeIndex==index}}&quot; src=&quot;{{items.activeImage}}&quot;&gt;&lt;/image&gt; &lt;image wx:else src=&quot;{{items.image}}&quot;&gt;&lt;/image&gt; &lt;text&gt;{{items.name}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; home页面的ts Page({ data: { activeIndex:0, tab:[ { name:'商品', image:'../../images/index.png', activeImage:'../../images/index-hover.png', }, { name:'购物车', image:'../../images/cart.png', activeImage:'../../images/cart-hover.png', }, { name:'订单', image:'../../images/order.png', activeImage:'../../images/order-hover.png', }, { name:'我的', image:'../../images/my.png', activeImage:'../../images/my-hover.png', } ] }, // 切换事件 choose(e:any){ const _this=this; const {activeIndex}=_this.data; if(e.currentTarget.dataset.index==activeIndex){ return }else{ _this.setData({ activeIndex:e.currentTarget.dataset.index }) } }, }) 上面代码不难理解，点击以后改变activeIndex从而控制每个组件的渲染和销毁，这样付出的代价还是比较大的，需要我们进一步的优化。 如何实现keep-alive 我们知道，这里主要是避免组件反复创建和渲染，有效提升系统性能。 实现思路 1.在tab每个选项增加两个值：status和show，show控制组件是否需要渲染，status控制组件display 2.初始化时候设置首页的status和show，其他都为false 3.当我们切换时:把上一个tab页面的status改为false,然后把当前要切换页面的tab数据中的status和show都改为true,最后再更新一下activeIndex的值。 wxml代码： &lt;!-- 首页 --&gt; &lt;view wx:if=&quot;{{tab[0].show}}&quot; hidden=&quot;{{!tab[0].status}}&quot;&gt; &lt;index&gt;&lt;/index&gt; &lt;/view&gt; &lt;!-- 购物车 --&gt; &lt;view wx:if=&quot;{{tab[1].show}}&quot; hidden=&quot;{{!tab[1].status}}&quot;&gt; &lt;cart&gt;&lt;/cart&gt; &lt;/view&gt; &lt;!-- 订单 --&gt; &lt;view wx:if=&quot;{{tab[2].show}}&quot; hidden=&quot;{{!tab[2].status}}&quot;&gt; &lt;order&gt;&lt;/order&gt; &lt;/view&gt; &lt;!-- 我的 --&gt; &lt;view wx:if=&quot;{{tab[3].show}}&quot; hidden=&quot;{{!tab[3].status}}&quot;&gt; &lt;my&gt;&lt;/my&gt; &lt;/view&gt; ts代码 Page({ data: { activeIndex:0, //当前选中的index tab:[ { name:'商品', image:'../../images/index.png', activeImage:'../../images/index-hover.png', status:true,//控制组件的display show:true, //控制组件是否被渲染 }, { name:'购物车', image:'../../images/cart.png', activeImage:'../../images/cart-hover.png', status:false, show:false, }, { name:'订单', image:'../../images/order.png', activeImage:'../../images/order-hover.png', status:false, show:false, }, { name:'我的', image:'../../images/my.png', activeImage:'../../images/my-hover.png', status:false, show:false, } ] }, choose(e:any){ const _this=this; const {activeIndex}=_this.data; //如果点击的选项是当前选中，就不执行 if(e.currentTarget.dataset.index==activeIndex){ return }else{ //修改上一个tab页面的status let prev='tab['+activeIndex+'].status', //修改当前选中元素的status status='tab['+e.currentTarget.dataset.index+'].status', //修改当前选中元素的show show='tab['+e.currentTarget.dataset.index+'].show'; _this.setData({ [prev]:false, [status]:true, [show]:true, activeIndex:e.currentTarget.dataset.index,//更新activeIndex }) } }, }) 这样基本就大功告成了，来看一下效果： 当我们点击切换时候，如果当前组件没有渲染就会进行渲染，如果渲染过后进行切换只是改变display，完美实现了需求，大功告成！ 实际业务场景分析 在实际使用中还有两种种情况： 情况1：比如某些数据并不希望他首次加载后就数据保持不变，当切换页面时候希望数据进行更新，比如笔者做的电商小程序，在首页点击商品加入购物车，然后切换到购物车，每次切换时候肯定需要再次进行请求。 情况2：像个人中心这种页面，数据基本请求一次就可以，没必要每次切换请求数据，这种我们不需要进行改进。 我们给组件传递一个值：status,然后在组件中监听这个值的变化，当值为true时候，去请求接口更新数据。具体代码如下： wxml代码(只列举关键部分)： &lt;!-- 首页 --&gt; &lt;view wx:if=&quot;{{tab[0].show}}&quot; hidden=&quot;{{!tab[0].status}}&quot;&gt; &lt;index change='{{tab[0].status}}'&gt;&lt;/index&gt; &lt;/view&gt; &lt;!-- 购物车 --&gt; &lt;view wx:if=&quot;{{tab[1].show}}&quot; hidden=&quot;{{!tab[1].status}}&quot;&gt; &lt;cart change='{{tab[0].status}}'&gt;&lt;/cart&gt; &lt;/view&gt; 首页组件/购物车组件ts代码: Component({ /** * 组件的属性列表 */ properties: { change: { type: String,//类型 value: ''//默认值 }, }, observers: { //监听数据改变进行某种操作 'change': function(change) { if(change=='true'){ console.log('更新首页数据'+change) } } }, }) 来看一下最终效果： 结尾 目前能想到的实现方法就是这样，如果你有更好的方法，欢迎评论区交流，文章如有错误问题欢迎指正。 👉关注前端365：分享前端小技巧以及开发过程中的一些问题，欢迎关注+收藏+点赞，感谢支持～ ","link":"https://lonjinup.github.io/xcx-keep-alive/"},{"title":"前端基础总结","content":"复习笔记 html 什么是重绘？什么是回流？ 重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而 不会影响布局的操作，比如 background color，我们将这样的操作称为重绘。 回流:当渲染树中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重 新构建的操作，会影响到布局的操作，这样的操作我们称为回流。 H5有哪些新特性 绘画 canvas; 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术 webworker, websocket; 新的文档属性 document.visibilityState css 说一下常见的盒子模型，如何切换两种盒子模型？ 标准(W3C)盒子模型：属性 width，height 只包含内容 content，不包含 border 和 padding IE盒子模型：属性 width，height 包含 content、border 和 padding，指的是 content +padding+border。 box-sizing:content-box; box-sizing:border-box; 如何解决margin塌陷/margin重叠？ 有时当我们设置子元素的margin-top，但是却发现子元素没有出现上外边距的效果，反而是父元素出现了上外边距的效果。第一个子元素设置margin-top父元素会跟着移动，这就是margin塌陷，解决方法： 为父元素设置padding。---要设置padding，设置margin不行 为父元素设置border。---设置border为0px不行，border要有值 为父元素设置 overflow: hidden 父级或子元素使用浮动或者绝对定位absolute 什么是BFC？BFC是如何触发的？ 容器里面的元素不会在布局上影响到外面的元素 只要元素满足下面任一条件即可触发BFC特性 body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll)【最常用】 如何实现垂直水平居中 flex布局 .box{ display: flex; align-items: center; justify-content: center; } 定位 .box{ position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; } JavaScript 数据类型都有哪几种，有什么区别？ 数据类型分为原始数据类型和对象数据类型。 原始数据类型：null、Boolean、Number、String、undefined、Symbol、BigInt 对象数据类型：Object 区别：原始数据类型存储在栈区，占用空间较小，存储的是值；对象类型同时存储在栈区和堆区，且大小不固定。 如何判断数据类型 typeOf:可以判断基本数据类型，除了null以外，因为null认为是空对象的引用。 instanceof:可以判断对象类型，内部机制是通过原型链来进行判断的。 constructor:利用原型上的prototype.constructor指向实例的构造函数来进行判断。如果中途改变类型，则判断不准确。 Object.prototype.toString.call:使用Object对象的原型方法toString,返回值是[object 类型]字符串。 说一下js类型转换规则 转换为布尔值：除了undefined、null、false、NaN、''、0、-0,剩下的都为true 转化为数字： null,返回0 undefined，返回NaN 布尔值， true 转换为1， false 转换为0 字符串： 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值 如果字符串包含有效的浮点值格式如 &quot;1.1&quot; ，则会转 换为相应的浮点值(同样，忽略前面的零) 如果字符串包含有效的十六进制格式如 &quot;0xf&quot; ，则会 转换为与该十六进制值对应的十进制整数值。 如果是空字符串(不包含字符)，则返回0。 如果字符串包含除上述情况之外的其他字符，则返回NaN。 如果是对象，调用valueof()方法，并按照字符串的规则转换返回的值。如果转换结果是NaN，则调用toString()方法，再按照转换字符串的规则转换。 转换为字符串，直接转化 如何正确判断this？箭头函数的this是什么？如何改变this指向 在浏览器中，全局环境下，this指向window对象。 在函数中，this指向最后调用它的那个对象。 箭头函数的this始终指向其包裹箭头函数的第一个函数。 有new操作符，指向new出来的那个对象。 call、apply、bind指向绑定的新对象上。 == 和 === 有什么区别？ ==如果类型不同，会进行隐式转化；再进行比较。 ===直接判断类型和值是否相等。 什么是闭包？ 函数A内部有函数B，函数B访问函数A的变量，函数B就是一个闭包。闭包就是为了我们能够间接访问内部变量,避免被垃圾机制回收。 function a(){ let a=0; function b(){ a++; console.log(a) } return b } let n=a(); n(); //1 n(); //2 什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？ 浅拷贝：拷贝所有的值到新对象中，如果属性值是对象，则拷贝对象的地址。 //通过Object.assign let a={ name:'tom', age:18 }; let b=Object.assign({},a) console.log(b); //通过展开运算符 let c={ name:'lonjin', age:18 }; let d={...c} console.log(d) 深拷贝：拷贝所有的值到新对象中，如果属性值是对象，则拷贝对象的地址。 // JSON.parse(JSON.stringify(object))实现 /* 缺点：会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 */ let a={ name:'tom', fnc:{ age:18 } } let b=JSON.parse(JSON.stringify(a)) a.fnc.age=19 console.log(b.fnc) 如何理解原型？如何理解原型链？ 举个例子：当我们写一个构造函数时候，构造函数身上会有一个prototype属性，这就是该构造函数的原型对象；它可以存一些该构造函数公告的属性和方法，同时该属性身上有constructor属性，它指向创建它的构造函数。 当我们访问一个对象的某个属性时候，如果在对象内部没有找到，就会通过**proto**沿着向上查找，这就是原型链。 var、let 及 const 区别 var声明的变量会变量提升 let、const声明的变量不会进行变量提升，且有块级作用域 const声明时必须赋值 如何实现继承 ES5组合继承法： function Parent(){ this.name='tom'; }; Parent.prototype.say=function(){ console.log(this.name) }; function Child(){ Parent.call(this) this.age=18; }; Child.prototype=Object.create(Parent.prototype); Child.prototype.constructor=Child; ES6使用class: class Parent{ constructor(name,age){ this.name=name; this.age=age; } } class Child extends Parent{ constructor(name,age,say){ super(name,age); this.say=say; } } let c=new Child('bob',17,'say hi') Proxy 可以实现什么功能？ Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。vue3中就是通过Proxy取代Object.defineProperty来实现数据响应式。 forEach、map、filter、find、reduce、every、some都适用于哪种场景？ forEach:进行遍历操作，可在当前遍历对象身上直接操作，不会产生新数组。 map:用于遍历操作，且需要返回值，如果没有返回值，则为undefined,map会返回一个新数组。 filter:进行一些筛选过滤，return符合条件的值产生新数组。 find:根据指定的条件找到数组中符合条件的值。 reduce:提取数组对象中某个值｜数组求和 Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？ Promise本译就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态： 进行中：pending 完成了：resolved 失败了：rejected 承诺状态一旦改变就不可更改，且在构造Promise时候，构造函数内部代码是立即执行的。 new Promise((resolve, reject) =&gt; { console.log('Promise') }) console.log('finifsh') //Promise -&gt; finifsh Promise可以进行链式调用，每次then()都是一个新Promise。如果在Promise中使用了return,也会被转化为Promise.resolve()。 async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？ 在普通函数前面加上async,该函数返回就成了一个Promise,如果要使用其返回值，我们就可以使用then(): async function fn(){ console.log('fn'); return 'i im fn' }; fn().then((val)=&gt;{ console.log(val) }) //fn ---&gt; i im fn await只能在async函数内使用 谈一谈js的执行机制 js是一种单线程、异步、非阻塞、解释型脚本语言，它最大的特点就是单线程。在js执行时候，从上往下，先吧同步任务放到执行栈中执行，当遇到异步任务时候，会把异步任务放到异步队列，当执行栈为空的时候，会从异步队列中取出一条压入执行栈，这样一直循环，这就是Event Loop。异步任务又分为宏任务和微任务，微任务优先于宏任务。 new操作符都干了什么？ 在内存中创建一个新对象 这个新对象内部的[[prototype]]特性被赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象(即this指向新对象) 如果构造函数返回非空 对象，则返回该对象；否则，返回刚创建的新对象 function _new(fn,...args){ const newObj = Object.create(fn.prototype); const value = fn.apply(newObj,args); return value instanceof Object ? value : newObj; } 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？ 因为精度问题导致的，解决方法如下： parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true 说一说浏览器垃圾回收机制 浏览器垃圾回收机制有好几种方案，之前大部分浏览器采用标记清理，还有一部分使用引用计数。V8新生代算法把内内存空间分为两部分：From和to空间，这两个空间必定有一个是空的，当一个空间满了以后，就会检查当前空间存活的对象放到另外一个空间。 什么是防抖？什么是节流？ 防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 function debounce(fn,wait){ let timer=null; return function(){ clearTimeout(timer); timer=setTimeout(function(){ fn.apply(this) },wait) } } document.getElementById('btn').onclick=debounce(function(){console.log('触发'+Date.now());},1000) 节流：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 function throttle(fn,wait){ // 记录上一次函数执行的时间 var lastTime=0; return function(){ // 现在时间 var nowTime=new Date(); if(nowTime-lastTime&gt;wait){ fn.call(this); lastTime=nowTime; } } }; document.onscroll=throttle(function(){console.log('触发'+Date.now());},1000) Vue 谈一谈Vue的生命周期，在哪个周期可以获取DOM？平时获取数据可以在哪个生命周期执行？ 简单来说，Vue的生命周期可以归为3类，创建阶段、运行阶段、销毁阶段。 创建阶段 beforeCreate：实例刚在内存中创建出来，还没有初始化 data和 methods，只包含一些自带额生命周期函数。 created：实例已经在内存中创建完成，此时data和methods已经创建完成。 beforeMount：此时已经编译模版，但没有渲染到页面中。 mounted：渲染模版，创建阶段到此结束。这时候可以操作dom。 运行阶段 beforeUpdate：界面中的数据还是旧的，但是data数据已经更新，页面中和data还没有同步。修改data数据就会触发这个函数。 updated：页面重新渲染完毕，页面中的数据和data保持一致。修改data数据就会触发这个函数。 销毁阶段 beforeDestroy：执行该方法的时候，Vue的生命周期已经进入销毁阶段，但是实例上的各种数据还出于可用状态。 destroyed：组件已经全部销毁，Vue实例已经被销毁，Vue中的任何数据都不可用 keep-alive activited：keep-alive 专属，组件被激活时调用 deactivated：keep-alive 专属，组件被销毁时调用 组件如何进行通信？ 父子组件 props/$emit:父组件通过props来给子组件传递数据，子组件可以通过$emit发送事件给父组件。但这种父子直接传递数据是单向数据流 $$parent/$children:通过$parent或$children就可以访问组件的实例 ref/refs:如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据 兄弟组件 this.$parent.$children:在$children 中可以通过组件name查询到需要的组件实例。 任意组件 Vuex Event Bus:eventBus又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难。 vue2双向绑定的原理是什么？vue3和vue2双向绑定有什么区别？ vue2是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。Object.defineProperty()只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持。vue3中则采用Proxy，它可以监听到数组内的数据变化。 为什么 Vue 组件中 data 必须是一个函数？ 如果 data 是一个对象，当复用组件时，因为 data 都会指向同一个引用类型地址，其中一个组件的 data 一旦发生修改，则其他重用的组件中的 data 也会被一并修改。 如果 data 是一个返回对象的函数，因为每次重用组件时返回的都是一个新对象，引用地址不同，便不会出现如上问题。 Vue 中 computed 和 watch 有什么区别? 计算属性computed： （1）支持缓存，只有依赖数据发生变化时，才会重新进行计算函数； （2）计算属性内不支持异步操作； （3）计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属性)方法； （4）计算属性是自动监听依赖值的变化，从而动态返回内容。 侦听属性 watch: (1) 不支持缓存，只要数据发生变化，就会执行侦听函数； (2) 侦听属性内支持异步操作； (3) 侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性； (3) 监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些其他事情。 vuex 都有哪些部分组成？ state:用来存储数据 Getter:用来获取state中的值 Mutation:唯一可以改变state中的值，且必须是同步函数 Action:用于提交mutation，而不是直接变更状态，可以包含任意异步操作 Module:许将单一的Store拆分为多个store且同时保存在单一的状态树中。 浏览器相关 输入URL到页面渲染中都发生了什么？ 1.URL 解析 2.DNS 查询 3.TCP 连接 4.处理请求 5.接受响应 6.渲染页面 ","link":"https://lonjinup.github.io/jsjczj/"},{"title":"如何快速掌握公众号开发","content":"手把手教你微信公众号开发 很多人肯定会疑惑，为什么人家有文档不看，非要看你这个？本来也不打算写这篇文章，那天在掘金上有个掘友发了个沸点，大体意思就说公众号开发也能算一门技术(因为公众号网页开发文档可读性比较差)。有时候见技术群好多人也提问；所以还是写一下微信授权登录和微信分享以及微信支付。 开发前的准备 工欲善其事，必先利其器，我们先准备一些必备东西，然后才可以正式进入开发环节。首先需要注册企业微信公众号账号，然后绑定开发人员，下载开发工具。 注册账号 注册微信公众号，一般选择服务号(具体看业务场景),输入相关信息提交即可，这个比较简单，就不展开叙述了。 绑定开发者账号 1.登录微信开发者平台，左侧菜单栏找到开发--&gt;开发者工具，点击进入。 2.点击web开发者工具，这个就是绑定我们的开发者微信账号，方便后面调试。 g71x81.png g71vCR.png 下载开发调试工具 点击进入微信开发调试工具下载页面，选择版本下载即可，到现在，我们的开发前准备工作就算完成了。 微信授权登录 准备工作做完以后，我们就可以开始着手开发了，一般公众号开发肯定要做微信网页授权、分享给好友、分享到朋友圈，部分会做微信支付功能。下面就分享一下微信网页授权开发流程。 安全域名设置 g73FVe.png 1.登录公众号后台，左侧菜单栏找到：设置--&gt;公众号设置，进入页面后选择功能设置，配置一下JS接口安全域名和网页授权域名，配置规则如下： 配置名 规则 用途 JS接口安全域名 域名须通过ICP备案的验证，需要下载MP_verify_jhf9FhUVRNDnBE96.txt放在所配置域名指向的根目录 在微信内访问该域名下页面时，不会被重新排版。用户在该域名上进行输入时，不出现安全提示 网页授权域名 需要吧MP_verify_jhf9FhUVRNDnBE96.txt放到域名的根目录下 微信网页授权时候必须配置 登录流程 微信登录流程： g73PbD.png 前端关键代码如下(为书写方便，这里请求使用jquery的$ajax): &lt;script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取地址栏参数&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;GetURL(name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;reg&nbsp;=&nbsp;new&nbsp;RegExp(\"(^|&amp;)\"&nbsp;+&nbsp;name&nbsp;+&nbsp;\"=([^&amp;]*)(&amp;|$)\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;r&nbsp;=&nbsp;window.location.search.substr(1).match(reg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;!=&nbsp;null)&nbsp;return&nbsp;unescape(r[2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;//获取url中code参数&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;code&nbsp;=&nbsp;GetURL('code');&nbsp;&nbsp;&nbsp;&nbsp;//如果没有code，转跳到授权页进行授权&nbsp;&nbsp;&nbsp;&nbsp;if(!code){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;url&nbsp;=&nbsp;window.location.href;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;appid&nbsp;=&nbsp;'abckdeh129292';&nbsp;//公众号appid，在微信公众号后台中可以查看&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.location.href&nbsp;=&nbsp;'https://open.weixin.qq.com/connect/oauth2/authorize?appid='+appid+'&amp;redirect_uri='&nbsp;+&nbsp;url&nbsp;+&nbsp;'&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirect';&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//如果有code&nbsp;&nbsp;&nbsp;&nbsp;$.ajax({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;\"https://test.abcd.com/api/WXUserInfo\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;{&nbsp;code,},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;\"get\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataType:&nbsp;\"json\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function&nbsp;(res)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//code可用，拿到用户信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(res.status)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userInfo&nbsp;=&nbsp;res.data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//code过期，需要重新授权&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.location.href&nbsp;=&nbsp;'http://test.abcd.com/juejin/index.html'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&lt;/script&gt; 参数说明：关于转跳到授权页时候拼接的参数，这里就不多说了，感兴趣的可以看一下👉官方文档 常见返回错误码： 10003 检测后台回调域名配置是不是正确 10005 公众号没有开通这个能力 10009 操作频繁，这个和前端关系不大，后端检查一下逻辑 用户信息 上面获取到微信返回的用户信息对应的描述如下，其中有几点需要注意一下，后端保存用户昵称时候需要进行转码，因为有些用户微信昵称为表情，其次是如果公众号网页想要与小程序网页用户信息互通，则需要拿unionid来当唯一id，同时小程序获取用户信息也需要保存unionid。 参数名称 描述 openid 用户的唯一标识 nickname 用户的昵称 sex 用户的性别，值为1时是男性，值为2时是女性，值为0时是未知 province 个人资料填写的省份 city 普通用户个人资料填写的城市 country 国家，如中国为CN headimgurl 用户头像 privilege 用户特权信息 unionid 用户标识 分享给好友，分享到朋友圈 大家肯定见过微信发给朋友的网页中有标题、介绍以及缩略图，这样有利于用户未进入页面时候大概了解页面的一些信息。这里就写一下分享给微信好友和分享到朋友圈，其他的可以看👉官方文档。js-sdk示例可以在微信内访问👉示例demo。 g73CDO.jpg 开发流程 1.配置js安全域名(在上面已经说明了具体配置方法) 2.引入js-sdk &nbsp;&nbsp;&nbsp;&nbsp;//页面中引入js-sdk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=\"http://res.wx.qq.com/open/js/jweixin-1.6.0.js\"&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;//vue或者react&nbsp;也可以插件安装&nbsp;&nbsp;&nbsp;&nbsp;npm&nbsp;install&nbsp;weixin-js-sdk&nbsp;或&nbsp;yarn&nbsp;add&nbsp;weixin-js-sdk 3.通过config接口注入权限验证配置，处理成功or失败 &nbsp;&nbsp;&nbsp;&nbsp;//拿到config接口注入权限验证参数，这些参数都由后端返回&nbsp;&nbsp;&nbsp;&nbsp;$.ajax({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;\"https://test.abcd.com/api/wxconfig\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;{&nbsp;url:window.location.href},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;\"get\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataType:&nbsp;\"json\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function&nbsp;(data)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.config({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug:&nbsp;true,&nbsp;//&nbsp;开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appId:&nbsp;data.appId,&nbsp;//&nbsp;必填，公众号的唯一标识&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp:&nbsp;data.timestamp,&nbsp;//&nbsp;必填，生成签名的时间戳&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonceStr:&nbsp;data.nonceStr,&nbsp;//&nbsp;必填，生成签名的随机串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signature:&nbsp;data.signature,//&nbsp;必填，签名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsApiList:&nbsp;['updateAppMessageShareData',&nbsp;'updateTimelineShareData',]&nbsp;//&nbsp;必填，需要使用的JS接口列表&nbsp;如果要做分享给好友和分享到朋友圈就写这两个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//配置验校成功处理函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.ready(function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;link&nbsp;=&nbsp;\"www.test.com/index.html\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;'掘金邀请你参加打卡活动',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc&nbsp;=&nbsp;'掘金邀请你参加打卡活动，奖品丰富，快来看看吧！',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgUrl&nbsp;=&nbsp;'http://www.test.com/images/share.jpg';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分享给好友&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.updateAppMessageShareData({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,&nbsp;//&nbsp;分享标题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc,&nbsp;//&nbsp;分享描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link,&nbsp;//&nbsp;分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgUrl,&nbsp;//&nbsp;分享图标&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;设置成功处理函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分享到朋友圈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.updateTimelineShareData({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,&nbsp;//&nbsp;分享标题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link,&nbsp;//&nbsp;分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgUrl,&nbsp;//&nbsp;分享图标&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;设置成功处理函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//配置失败函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.error(function(res){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); ⚠️注意事项 调试过程中要打开debug,不然失败后看不到返回信息，常见错误大部分是因为后端签名计算问题，如有问题直接把报错信息复制到搜索引擎看一下处理方式就行。 微信js-sdk与微信网页授权没任何关联，不授权也可以使用js-sdk。 微信分享成功处理函数仅代表用户点击了分享按钮，并不代表真正分享给了好友，只要点击了右上角分享，\bsuccess函数就会执行。一般做激励式分享都是分享后携带参数，当用户分享后好友进入后进行相关业务处理。 结尾 本来打算写一下微信支付，但文章会比较长，留着下次写吧。有问题可以评论区与我交流。欢迎关注👉关注前端365：分享前端小技巧以及开发过程中的一些问题。看完记得欢迎关注+收藏+点赞，马上就到LV3了，感谢支持～ ","link":"https://lonjinup.github.io/wxh5kf/"},{"title":"小程序TabBar创意动画(文末附完整源代码)","content":" 小程序实现TabBar创意动画(文末附完整源代码) 小程序日益增多的情况下，UI风格显得越来越重要，在页面中如果能让TabBar个性化一点，加一些小交互，用户体验会大大提升。由于小程序对svg不太友好，所以我们尽量使用css动画进行实现。之前文章小程序开发技巧中提到过TabBar自定义方案，感兴趣的可以了解一下。下面就分享一下今天写的几个交互效果，文末也会分享源代码。记得点赞+关注+收藏！ NO.1 这种效果主要使用了transform和opacity来实现。文字默认隐藏并缩小，点击后icon图标transform的y轴方向上移，同时控制文字的opacity。圆形块根据点击的index去动态计算x轴的偏移位置即可。 gRsjhj.gif 核心css代码(完整代码见文末)： &nbsp;&nbsp;&nbsp;&nbsp;.tabbar&nbsp;.item&nbsp;.text{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position:&nbsp;absolute;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;100%;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottom:&nbsp;10rpx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text-align:&nbsp;center;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font-size:&nbsp;22rpx;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opacity:&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition:&nbsp;all&nbsp;.8s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform:&nbsp;scale(0.8);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;100%;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;.tabbar&nbsp;.item.active&nbsp;.text{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opacity:&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform:&nbsp;scale(1);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;.tabbar&nbsp;.item.active&nbsp;.icon{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;#3561f5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform:&nbsp;translateY(-55rpx);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;.tabbar&nbsp;.item&nbsp;.icon{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font-size:&nbsp;50rpx!important;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text-align:&nbsp;center;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition:&nbsp;all&nbsp;.8s;&nbsp;&nbsp;&nbsp;&nbsp;} NO.2 这个效果用到一个css动画工具库：bouncejs，它可以在线生成css动画，然后复制到项目中使用即可。下方效果采用跳跃式切换，整体看上去非常有活力。使用了animation动画。由于css动画代码过多，想看完整代码见文末github地址。 gR2KRH.gif NO.3 下方这个效果还是用bouncejs在线编辑，编辑完成后只需要点击后给相应的元素添加类名即可。 gRRn00.gif 结尾 如需源代码可以移步github。 👉关注前端365：分享前端小技巧以及开发过程中的一些问题，欢迎关注+收藏+点赞，感谢支持～ ","link":"https://lonjinup.github.io/wxtabbar/"},{"title":"vue-cli自动补全css前缀","content":"vue自动补全前缀 需要安装postcss和autoprefixer两个npm包。 1.安装 &nbsp;&nbsp;&nbsp;&nbsp;npm&nbsp;install&nbsp;postcss&nbsp;&nbsp;&nbsp;&nbsp;npm&nbsp;install&nbsp;autoprefixer 2.在package.json文件修改 browserslist &nbsp;\"browserslist\":&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;\"&gt;&nbsp;1%\",&nbsp;&nbsp;&nbsp;&nbsp;\"last&nbsp;3&nbsp;versions\",&nbsp;&nbsp;&nbsp;&nbsp;\"not&nbsp;ie&nbsp;&lt;=&nbsp;8\",&nbsp;&nbsp;&nbsp;&nbsp;\"chrome&nbsp;&gt;=&nbsp;14\",&nbsp;&nbsp;&nbsp;&nbsp;\"safari&nbsp;&gt;=&nbsp;3\",&nbsp;&nbsp;&nbsp;&nbsp;\"ios&nbsp;&gt;=&nbsp;8\",&nbsp;&nbsp;&nbsp;&nbsp;\"android&nbsp;&gt;=&nbsp;4.0\"&nbsp;] 3.在根目录新建postcss.config.js文件 &nbsp;&nbsp;&nbsp;&nbsp;module.exports&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plugins:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoprefixer:&nbsp;{}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} 4.重新启动项目即可。 tips 安装后运行发现有报错：Error: PostCSS plugin autoprefixer requires PostCSS 8.Migration guide for end-users:。可能是版本问题导致不兼容，直接安装的是最新版本(10.2.5)，这时候我们需要降低一下版本即可。 &nbsp;&nbsp;&nbsp;&nbsp;npm&nbsp;i&nbsp;postcss-loader&nbsp;autoprefixer@8.0.0&nbsp;-D 安装完重新运行即可。 ","link":"https://lonjinup.github.io/vue-cli-css/"},{"title":"webpack4学习笔记 02","content":"Entry(入口) 在webpack.config.js中，当我们不配置入口文件的话，会默认找/src/index.js文件。 参数配置 如果只配置一个入口文件，则后面直接使用string形式： &nbsp;&nbsp;entry:'./src/index.js', 如果是多个入口文件，则用Array形式，默认会输出一个文件： &nbsp;&nbsp;entry:['./src/index.js','./src/index2.js'], 如果入口为多个文件，输出时候也为多个对象，则使用json形式，这时候要配合Output进行处理 &nbsp;&nbsp;entry:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page1:'./src/index.js',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page2:'./src/index2.js',&nbsp;&nbsp;}, Output(出口) 在webpack.config.js中，当我们不配置出口文件的话，默认输出为：/dist/main.js。 参数配置 如果入口文件为多个，输出时候也是多个，这时候就需要配置一下filename: &nbsp;&nbsp;&nbsp;//&nbsp;入口文件&nbsp;&nbsp;&nbsp;&nbsp;entry:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page1:'./src/index.js',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page2:'./src/index2.js'&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;出口&nbsp;&nbsp;&nbsp;&nbsp;output:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path:__dirname+'/dist',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename:'[name].js'&nbsp;&nbsp;&nbsp;&nbsp;}, 打包后输出为：/dist/page1.js和/dist/page2.js文件。 html打包-html-webpack-plugin webpack默认不会打包html，需要相应的插件去处理：html-webpack-plugin 插件的使用 1.下载插件 &nbsp;&nbsp;&nbsp;npm&nbsp;i&nbsp;html-webpack-plugin&nbsp;-D 2.引用插件 &nbsp;&nbsp;const&nbsp;HtmlWebpackPlugin=require('html-webpack-plugin'); 3.使用插件 在plugins中new一下 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//插件的配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plugins:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp;} 完整代码如下： &nbsp;&nbsp;const&nbsp;path=require('path');&nbsp;&nbsp;const&nbsp;HtmlWebpackPlugin=require('html-webpack-plugin');&nbsp;&nbsp;module.exports={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;入口文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page1:'./src/index.js',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;出口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path:__dirname+'/dist',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename:'[name].js'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;关于loader&nbsp;配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//插件的配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plugins:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;服务器的配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devServer:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 执行webpack，就会生成/dist/index.html和/dist/page1.js文件。 默认直接使用，会自己生成一个index.html文件，并在文件中生成script标签引入js文件。 html-webpack-plugin相关配置 template:用于配置模版 &nbsp;&nbsp;&nbsp;&nbsp;plugins:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template:'./src/index.html',&nbsp;//模版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;], title:动态配置网站标题 &nbsp;&nbsp;&nbsp;&nbsp;plugins:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template:'./src/index.html',&nbsp;//模版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:'测试标题'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;src/index.html中：&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;&nbsp;&lt;%=&nbsp;htmlWebpackPlugin.options.title&nbsp;%&gt;&lt;/title&gt; hash:用来生成hash值，避免缓存,默认为false &nbsp;&nbsp;&nbsp;&nbsp;plugins:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template:'./src/index.html',&nbsp;//模版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:'测试标题',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash:true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp; minify:用来压缩html文件 &nbsp;&nbsp;plugins:[&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template:'./src/index.html',&nbsp;//模版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:'测试标题',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash:true,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minify:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collapseWhitespace:true,&nbsp;//折叠空白区域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;], 如何多页配置方法 需求：在src目录下有index.html和index2.html，还有index.js和index2.js,想在页面中分别引入。 使用filename和chunks即可实现 &nbsp;&nbsp;&nbsp;&nbsp;//插件的配置&nbsp;&nbsp;&nbsp;&nbsp;plugins:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template:'./src/index.html',&nbsp;//模版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:'页面1',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash:true,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename:'index.html',&nbsp;//生成文件名字&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunks:['page1']&nbsp;//对应引入的js文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;HtmlWebpackPlugin({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename:'index2.html',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template:'./src/index2.html',&nbsp;//模版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:'页面2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash:true,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunks:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'page2'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;],","link":"https://lonjinup.github.io/webpack02/"},{"title":"webpack4 学习笔记01","content":"webpack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。 webpack五个核心概念 Entry 入口(Entry)指示webapck以哪个文件为入口起点开始打包，分析构建内部依赖图。 Output 输出(Output)指示webpack打包后的资源bundles输出到哪里去，以及如何命名。 Loader Loader让webpack能够处理哪些非JavaScript文件（webpack自身只理解JavaScript） Plugins 插件(Plugins)可以用于执行范围更广的任务。插件的范围包括：从优化和压缩、一直到重新定义环境中的变量。 Mode 模式指示webpack使用相应的模式配置。 选项 描述 特点 development 会将process.env.NODE_ENV的值设置为development。启用NamedChunksPlugin和NamedModulesPlugin 能让代码本地调试运行的环境 production 会将process.env.NODE_ENV 的值设置为production。启用FlagDependencyUsagePlugin、FlagIncludedChunksPlugin、ModuleConcatenationPlugin、NoEmitOnErrosPlugin、OccurrenceOrderPlugin、SideEffectsFlagPlugin、UglifyJsPlugin 能让代码优化上线的环境 安装 初始化 &nbsp;&nbsp;npm&nbsp;init&nbsp;-y 全局安装 使用版本webpack@4.29.5 webpack-cli@3.2.3 &nbsp;&nbsp;&nbsp;npm&nbsp;install&nbsp;webpack&nbsp;webpack-cli&nbsp;-g&nbsp;&nbsp;&nbsp;webpack&nbsp;-v&nbsp;//验证是否安装成功 本地安装 安装（-D表示开发依赖） &nbsp;&nbsp;npm&nbsp;add&nbsp;webpack&nbsp;webpack-cli&nbsp;-D 初始化项目 &nbsp;&nbsp;npm&nbsp;init&nbsp;-y&nbsp;或者&nbsp;npm&nbsp;init hello word 首先在新建立的demo文件夹中初始化项目，然后安装webpack和webpack-cli,建立一个src/index.js文件，然后再建立一个打包后的输出文件：dist/index.html，最后建立webpack.config.js。大致目录结构如下： &nbsp;&nbsp;demo&nbsp;&nbsp;&nbsp;&nbsp;--dist&nbsp;&nbsp;&nbsp;&nbsp;----index.html&nbsp;&nbsp;&nbsp;&nbsp;--src&nbsp;&nbsp;&nbsp;&nbsp;----index.js&nbsp;&nbsp;&nbsp;&nbsp;--webpack.config.js&nbsp;&nbsp;&nbsp;&nbsp;--package.json&nbsp;&nbsp;&nbsp;&nbsp;--package-lock.json 打开src/index.js,随便写点什么,然后在dist/index.html中引入一下： &nbsp;&nbsp;&nbsp;&nbsp;//src/index.js&nbsp;&nbsp;&nbsp;&nbsp;console.log('hello&nbsp;world');&nbsp;&nbsp;&nbsp;&nbsp;//dist/index.html&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;src=\"index.js\"&gt;&lt;/script&gt; 打开webpack.config.js文件，先写一些基本的配置： &nbsp;&nbsp;module.exports={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;入口文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry:'./src/index.js',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;出口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path:__dirname+'/dist',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename:'index.js'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;关于loader&nbsp;配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//插件的配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plugins:[],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;服务器的配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devServer:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 这时候在终端输入webpack即可打包，可以看到在dist文件夹下生成了一个index.js,打开dist/index.html,控制台也顺利输出hello world。 tips 关于输出路径，__dirname是node的一种方法，指的就是当前模块的目录，所以在输出路径中我们使用__dirname+'dist'。除此之外，还可以使用下面这种方法： &nbsp;&nbsp;const&nbsp;path=require('path');&nbsp;&nbsp;module.exports={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;入口文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry:'./src/index.js',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;出口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path:path.resolve(__dirname,'dist'),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename:'index.js'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;关于loader&nbsp;配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//插件的配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plugins:[],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;服务器的配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devServer:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 修改webpack.config.js文件名字 webpack.config.js文件名字也是可以进行修改的，只是执行时候命令有所改变,比如吧webpack.config.js改为demo.config.js,执行时候如下： &nbsp;&nbsp;&nbsp;&nbsp;webpack&nbsp;--config&nbsp;demo.config.js&nbsp;","link":"https://lonjinup.github.io/webpack4-01/"},{"title":"微信小程序开发总结","content":"微信小程序总结 近一年写了挺多小程序，一直没有系统化整理过小程序相关知识体系，最近面试时候也有被问到小程序相关的一些问题。这里大体整理一下，内容也会不断补充，感兴趣的可以先赞后看,顺便加个关注！ 开发技巧 自定义TabBar 目前很多业务场景下，都不会用小程序原生的TabBar，一方面是微信提供的TabBar样式太过单一，另一方面可能业务需要根据用户用户类别展示不同的TabBar。 小程序官方自定义TabBar 此方法适用于仅是修改TabBar样式使用。 在app.json中的 tabBar 项指定 custom 字段，同时其余 tabBar 相关配置也补充完整。 所有 tab 页的 json 里需声明 usingComponents 项，也可以在 app.json 全局开启。 { &quot;tabBar&quot;: { &quot;custom&quot;: true, &quot;color&quot;: &quot;#000000&quot;, &quot;selectedColor&quot;: &quot;#000000&quot;, &quot;backgroundColor&quot;: &quot;#000000&quot;, &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;page/index/index&quot;, &quot;text&quot;: &quot;首页&quot; }, { &quot;pagePath&quot;: &quot;page/my/index&quot;, &quot;text&quot;: &quot;我的&quot; }] }, &quot;usingComponents&quot;: {} } 同时在小程序项目文件根目录下创建custom-tab-bar文件夹：内容如图： 组件化实现TabBar 这种方式适合这样的业务场景：根据用户权限不同，展示相应的tabBar。之前做过一个小程序，普通用户登录的话进来是商城，tabBar对应的也是商城相关的页面，管理员登录的话展示的是管理端页面，tabBar对应也就是管理端相关页面。 我们可以新建一个home文件夹，在home/index.wxml中写一个tabBar，然后把TabBar页面写成组件，然后点击****切换相应的组件展示就可以。 1rpx问题 小程序中有时候需要定义border:1rpx,真机上有时候会显示不全，只需要改成border:1px即可 骨架屏 现在为了更好的用户体验，很多应用在loading时候会展示占位图，小程序中也提供了一键生成骨架屏代码。 下载并安装 1.03.2006032 或 1.04.2006032 以上版本的开发者工具，点击模拟器右下角生成骨架屏即可。 canvas图片下载后模糊 有时候我们用canvas绘制的图片预览时候看起来很清晰，但是下载到本地还是会很模糊，我们可以在下载时候canvas输出图片宽高*2，核心代码如下： wx.canvasToTempFilePath({ x: 0, //指定的画布区域的左上角横坐标 y: 0, //指定的画布区域的左上角纵坐标 width: 200, //指定的画布区域的宽度 height: 260, //指定的画布区域的高度 destWidth: 400, //输出的图片的宽度 指定的画布区域的宽度*2 destHeight: 520, //输出的图片的高度 指定的画布区域的高度*2 canvasId: 'posterCanvas', fileType: 'jpg', //图片的质量，目前仅对 jpg 有效。取值范围为 (0, 1]，不在范围内时当作 1.0 处理。 quality: 1, success: function (res) { ... } }) 小程序动画 写小程序肯定避免不了一些小动画，我们可以使用animate.css来完成。 (1) 首先下载animate.css,然后修改后缀为wxss (2) 在app.wxss中全局引入。 (3) 页面中加入对应类名即可使用。 &lt;!-- app.wxss --&gt; @import '/animate.wxss'; &lt;!-- 页面中 --&gt; &lt;view class=&quot;animated fadeInLeft&quot;&gt; &lt;/view&gt; 直播功能 目前很多小程序商城都带有直播功能，然而如果从0到1写个直播的话，工作量还是非常大的，小程序官方也提供了直播组件，优点是开发难度低，能大大降低开发周期。针对不太复杂的业务场景还是够用的。 查看官方文档 配置直播 直接在app.json中引入插件 &quot;plugins&quot;: { &quot;live-player-plugin&quot;: { &quot;version&quot;: &quot;1.0.4&quot;, // 注意填写该直播组件最新版本号，微信开发者工具调试时可获取最新版本号（复制时请去掉注释） &quot;provider&quot;: &quot;wx2b03c6e691cd7370&quot; // 必须填该直播组件appid，该示例值即为直播组件appid（复制时请去掉注释） } } 进入直播间 live:function(){ let roomId = [直播房间id] // 房间号 let customParams = { path: 'pages/index/index', pid: 1 } // 开发者在直播间页面路径上携带自定义参数（如示例中的path和pid参数），后续可以在分享卡片链接和跳转至商详页时获取，详见【获取自定义参数】、【直播间到商详页面携带参数】章节 this.setData({ roomId, customParams: encodeURIComponent(JSON.stringify(customParams)) }) } 创建直播 问题来了，在哪创建直播间啊？看图即可 首先登录微信小程序后台，找到直播。 创建直播 选择直播形式 填写基本信息 配置直播间样式 直播间样式 好了，一个直播就创建完成了，此时你会得到一个房间号，在自己搭建的小程序后台上传一下房间号，即可观看直播。这种对于单商户平台极其友好，开发也非常省事省力。 添加商品 后台建立商品库，填写相关参数即可。 推流直播 看这篇文章小程序推流配置 其他功能 直播间还可以创建抽奖，优惠券，以及拉黑用户等功能。也可以在后台设置管理员进行管理。 常用方法封装 开发过程中，我们可以把一些常用方法封装一下，这样在页面中调用会简洁很多。我们可以在根目录下建立utils/utils.js,封装常用方法，下面列举一一些常用方法： // utils.js //小程序提示语 function wxshowToast(title, icon, time, fn) { !icon?icon='none' !time?time=2000 wx.showToast({ title: String(title), icon: icon, duration: time, success: function() { fn?fn():'' }, fail:function(err){ console.log(err) } }) }; //request请求 // 接口地址 const baseUrl='https://xxxx.com'; function https(method,url,data){ //loading wx.showLoading({ title: '加载中...' }); //设置请求头 var header = { 'Content-Type':'application/json' }; //检查缓存中有没有token var token = wx.getStorageSync('token'); if (token != '') { header.Authorization = token } return new Promise((resolve,reject)=&gt;{ wx.request({ url:baseUrl+url, data: data, header: header, method: method, complete: (res) =&gt; { wx.hideLoading() if(res.statusCode==200){ if(res.data.status){ resolve(res.data.data) }else{ wxshowToast(res.data.msg) reject(res.data.data) } }else if (res.statusCode === 401) { //没有登录转跳到登录页面 wx.reLaunch({ url: '/pages/login/index' }) }else{ wxshowToast('请求失败,请稍后重试'); } } }) }) }; //导出方法 module.exports = { wxshowToast, _https:https, baseUrl, }; // 页面中使用 //引入util.js const util=require('../../utils/utils'); // 发送一个请求 util._https('get','/api/login') .then((res)=&gt;{ ... }) 性能优化 大家应该发现有的小程序打开速度特别快，而有的则非常慢，所以为了用户体验，性能优化还是非常有必要的。之前也看过大佬的文章，受益匪浅，感兴趣的可以看一看👉京喜小程序的高性能打造之路。 整体优化 （1）上传代码时候进行压缩(开发工具中右侧可以勾选)。 （2） 尽量把无用代码删除，避免代码冗余。 （3）非必要图片放在服务器，不要放到代码包中，不用的本地图片尽量删除。 （4）压缩css文件。 （5）分包预加载，具体使用文档 代码层面优化 接口合并 在小程序中wx.request最大并发是10个，如果超出10个就会阻塞后面的执行，所以把相似接口尽可能的合并。 setData优化 （1）在业务逻辑中，尽可能的合并setData调用 （2）页面渲染相关的数据放到data中 （3）避免更新重写setData中的值，比如我们在data中有一个list数组，修改数组某项我们可以进行局部修改，代码如下： // 接口返回list赋值 this.setData({ list }); //局部更新 this.setData({ 'list[0].name': list[0].name }); 首屏优化 目前大多数电商小程序采用的都是骨架屏+首屏分屏渲染。在刚进入页面时候展示骨架屏，然后展示首屏所需要的模块。比如一个电商小程序，首页可能会分为：banner+商品分类+特价优惠+推荐产品列表。我们第一屏看到的可能只有：banner+商品分类+特价优惠这些。当拿到数据以后，我们优先渲染首屏模块，等首屏模块全部渲染完成后再渲染非首屏模块。 小程序性能检测工具 小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 渲染表现、setData数据量、元素节点数和网络请求延时 这几个维度来给予定义,参考文档：小程序性能优化。 同时小程序也提供了体验评分工具：Audits面板，使用方法也非常简单，在调试区找到Audits,点击运行，然后依次打开每个页面，点击 “停止&quot; 则结束检测即可查看得分情况以及检测报告，可以快速定义到一些问题点，然后进行优化。 结尾 目前就总结这么多了，有新内容会随时进行补充，如果有其他内容也可以评论提出来我进行补充。最后希望大家能够点赞👍+关注支持一下。 ","link":"https://lonjinup.github.io/xiaochengxu/"},{"title":"快速入门TypeScript","content":"TypeScript基础知识梳理 之前一直打算看看ts，但一直沉迷摸🐟无法自拔，公司目前项目中也没有ts项目。今年手上正好有两个小程序项目，于是打算用ts写一下，感受一下ts的“魅力”。顺便整理了一下学习笔记，希望能帮到有需要的人。同时也用XMind做了知识图谱，有需要源文件的可以联系我。 安装与编译 安装 npm install -g typescript //mac下安装前面需要加sudo 编译 可以执行下面命令进行编译，会在当前目录下产生一个test.js文件 tsc test.ts 这样可能还是比较麻烦，我们可以借助插件方便我们提高效率： npm install -g ts-node 安装完后只需执行ts-node test.ts就可以在控制台查看输出结果。 原始数据类型 js中数据类型分两种，原始数据类型和对象类型，原始类型包括：布尔值、数字、字符串、null、undefined以及Symbol。 布尔值 在TypeScript中，使用boolean定义布尔值类型 let isStatus:boolean=true; 数字 使用number定义数值类型 let isNumber:number=1; //16进制(编译后显示10进制数字) let isNumber16:number:=0b1010; 字符串 使用string定义字符串类型： let isString:string='hello word'; let year:number=2020; let add:string=`${isString},${year}!`; 空值 JavaScript 没有空值（Void）的概念，在TypeScript中，可以用void表示没有任何返回值的函数. function alertName():void{ alert(&quot;my name is tom&quot;) } 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null。 let unusable: void = undefined; Null 和 Undefined 在TypeScript中可以使用null和undefined来定义这两个原始数据类型 let u:undefined=undefined; let n:null=null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说undefined类型的变量，可以赋值给number类型的变量，而void类型的变量不能赋值给number类型的变量： let num:number=undefined;//不会报错 let u:undefined; let num: number = u;//也不会报错 let u:void; let num:number=u;// Type 'void' is not assignable to type 'number'. 任意值 任意值（Any）用来表示允许赋值为任意类型。 什么是任意值类型 如果是一个普通类型，在赋值过程中改变类型是不被允许的： let renyiString:string='string'; renyiString=8; //Type 'number' is not assignable to type 'string'. 但如果类型是Any,类型，则允许被赋值为任意类型: let renyiString:any='string'; renyiString=8; 在任意值上访问任何属性都是允许的： let anyThis:any='hello'; console.log(anyThis.myName) console.log(anyThis.myName.firstName) 也允许调用任何方法： let anyThing: any = 'Tom'; anyThing.setName('Jerry'); anyThing.setName('Jerry').sayHello(); anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： let something; something = 'seven'; something = 7; something.setName('Tom'); 等于 let something: any; something = 'seven'; something = 7; something.setName('Tom'); 数组的类型 基础表示 「类型 + 方括号」表示法 let numbers:number[]=[1,2,3,4,5] 此时不允许出现其他类型，而且如果使用数组中push等方法，添加元素也得符合相应类型。 数组泛型 我们也可以使用数组泛型（Array Generic） Array&lt;elemType&gt; 来表示数组 let fibonacci:Array&lt;number&gt;=[1,2,3,4,] 如果数组中又有number类型又有string类型，则可以用｜符号来区别定义： let arr:(number|string)[]=['tom',1]; 数组中对象类型的定义 项目中经常遇到数组中有对象的存在，对于这种就比较麻烦了，比如： let arr:{name:string,age:number}[]=[ {name:'tom',age:18} ] 这样就比较麻烦了，我们可以使用ts中的类型别名来解决这个问题： type PeopleType={name:String,age:Number}; let arr:PeopleType[]=[ {name:'bob',age:19} ] 也可以用类型定义也可以解决： class PeopleType{ name:string; age:number } let arr:PeopleType[]=[ {name:'bob',age:19} ] 元组的使用和类型约束 在数组中如果里面又有string和number,可以使用｜来进行定义，但一定程度上并不严格。比如改成下面这种格式： let arr:(number|string)[]=[111,'222',111]; ts并没有报错，如果想要严格限制，则可以这样进行约束： let arr:[number,string,number]=[111,'222',111]; Interface接口 比如我们要做一个筛选，吧不符合条件的过滤出去，我们可能会这样写： const types=(name:string,age:number,height:number)=&gt;{ age&gt;=20 &amp;&amp; height&gt;=180 &amp;&amp; console.log('符合条件'); age&lt;=20 &amp;&amp; height &lt;180 &amp;&amp;console.log('不符合') }; types('tom',20,180) //符合条件 但如果又修改了一些需求，可能还会去大量变更代码，在开发中，代码能复用肯定是最好的，所以可以把一些重复的代码抽离出来： interface People{ name:string; age:number; height:number; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const choose=(people:People)=&gt;{ console.log(people.name+'----'+people.age+'---'+people.height) } const people={ name:'tom', age:18, height:178 } types(people); choose(people); 接口与类型别名的区别 看起来两者没有什么区别，但有个小细节：类型别名可以直接给类型，接口必须代表对象 type People=string; interface People{ name:string; age:number; height:number; } 如果传入的参数中有不确定项，我们可以使用 ?: 来进行处理： interface People{ name:string; age:number; height:number; say?:string }; const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178 } const people2={ name:'tom', age:18, height:178, say:'hello' } types(people); types(people2); 这时候又有新需求了，如何在后面加入任意多的字段？这时候我们就可以这么写： interface People{ name:string; age:number; height:number; say?:string; [propname:string]:any; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123 } types(people); 接口里的方法 接口不仅仅可以存属性，也可以存方法： interface People{ name:string; age:number; height:number; goto():string; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, goto(){ return 'hello' } } types(people) 接口和类的约束 在ES6中是有类的概念，类可以和接口相结合： interface People{ name:string; age:number; height:number; goto():string; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123, goto(){ return 'hello' } }; class newPeople implements People{ name='bob'; age=19; height:190; say:'hello'; add:'new add2'; addNumber:123; goto(){ return 'hi' } }; let a=new newPeople(); console.log(a.goto()) types(people) 接口的继承 接口与接口也是可以继承的： interface People{ name:string; age:number; height:number; say?:string; [propname:string]:any; goto():string; } const types=(people:newPeople)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123, goto(){ return 'hello' }, back(){ console.log(1) } } interface newPeople extends People{ back():void } types(people) 类的基本使用 首先，我们先创建一个类： class Test{ name='say' say(){ return this.name } }; 这就是平时所写的类，在ts中的继承和ES6的继承是一样的，关键字也是extends，比如我们这里新建个类，继承Text; class Test{ name='say' say(){ return this.name } }; class NewTest extends Test{ back(){ return 'hello' } } const tom=new NewTest(); console.log(tom.say()); console.log(tom.back()); super关键字的使用 如果想在say方法中后面加点东西，可以这么操作： class Test{ name='say' say(){ return this.name } }; class NewTest extends Test{ back(){ return 'hello' } say(){ return super.say()+'----hello' } } const tom=new NewTest(); console.log(tom.say()); console.log(tom.back()); ts中类的访问类型 ts中的访问类型就是基于三个关键字：private、protected以及pubilc这三种访问类型。看例子，先定义一个类，然后用这个类的对象，进行赋值： class Person{ name:string } const person=new Person(); person.name='tom'; console.log(person.name) pubilc 运行可以看到正常的输出内容，这是因为如果不对name的访问属性进行定义，那么他的默认属性就是pubilc,从字面意思来看，它的意思就是公用的，允许在类的内部和外部被调用。 class Person{ public name:string } const person=new Person(); person.name='tom'; console.log(person.name) private private的属性意思就是只允许在类的内部调用，不能在外部调用 class Person{ private name:string; public say(){ console.log(this.name+'-----hello'); } } const person=new Person(); person.name='tom';//报错 console.log(person.name)//报错 protected protected允许在类内以及继承的子类中使用，把刚刚的name改成protected属性，这时候在外部就会报错，这时候再写一个继承，代码如下： class Person{ protected name:string; public say(){ console.log(this.name+'-----hello'); } } const person=new Person(); person.name='tom';//报错 console.log(person.name)//报错 class NewPerson extends Person{ public back(){ console.log(this.name) } } const newperson=new NewPerson(); newperson.back()//正常 类的构造函数 首先新建一个类：Person,定义一个name，并在new的时候进行参数传递，然后打印出来，这时候我们就可以使用构造函数constructor : class Person{ pubilc name:string; constructor(name){ this.name=name } }; const person=new Person('tom'); console.log(person.name); 可以看到可以打印出来，但是上面写法有点麻烦，还可以再进行简化： class Person{ constructor(pubilc name:string){} }; const person=new Person('tom'); console.log(person.name); 类继承中的构造器写法 普通的书写方法上面已经演示了，在子类中使用构造函数需要用**super()**调用父类的构造函数，直接看代码： class Person{ constructor(pubilc name:string){} }; class Teacher extends Person{ constructor(pubilc age:number){ super() } }; const teacher=new Teacher(18); console.log(teacher.age+'---'+teacher.name); ts中类的Getter、Setter、static以及readonly 在上面中提到了访问类型private,它的最大用处就是封装一个书写，然后通过Getter和Setter去访问和修改： class Person{ constructor(private _age:number){ } } 如果想让别人知道，就可以使用Getter来实现，他并不是一个方法，只是一个属性： class Person{ constructor(private _age:number){ }; get age(){ return this._age } }; const person=new Person(30); console.log(person.age) 这时候你可能会觉得这不是多此一举吗？但在Getter中可以对 _age进行处理： class Person{ constructor(private _age:number){ }; get age(){ return this._age-10 } }; const person=new Person(30); console.log(person.age) 既然 _age是私有的，我们无法进行改变，这时候就可以用Setter进行改变： class Person{ constructor(private _age:number){ }; get age(){ return this._age } set age(age:number){ this._age=age } }; const person=new Person(30); person.age=20; console.log(person.age) 在类中，如果想用这个类的实例，就必须先进行new操作，但有没有一种方法不需要new就可以？ //常规方法 class Person{ say(){ return 'say hello' } }; const person=new Person(); console.log(person.say()); 在ts中，我们不想new的话可以这么写： class Person{ static say(){ return 'say hello' } }; console.log(Person.say()) readonly在初始化后赋值，以后就不能进行修改 class Person{ constructor(readonly name:string){} } let p=new Person('tom'); p.name='bob'//报错 console.log(p.name); 类的抽象类 abstract 用于定义抽象类和其中的抽象方法。它有几个特点： 抽象类是不允许实例化的 //错误演示 abstract class Person { public abstract say() } const tom=new Person()//无法创建抽象类的实例 抽象类中的抽象方法必须被子类实现： //错误演示 abstract class Person { abstract say(){ console.log('hello') } } class Tom extends Person{ say(){ console.log('say hello') } }; //正确方法 abstract class Person { abstract say() } class Tom extends Person{ say(){ console.log('say hello') } }; tsconfig.json配置 生成 我们可以通过tsc --init去生成ts配置文件: tsc --init //终端执行 编译 会生成一个tsconfig.json文件，我们在ts文件中可以随便写点什么： //测试tsconfig.json const test:string='tsconfig.json'; 然后打开tsconfig.json文件，找到complilerOptions属性下的removeComments:true（这个配置是编译后不输出注释），取消掉注释，然后执行命令： tsc 这时候打开生成的js文件，发现没有注释，说明成功。 include 、exclude 和 files 如果有多个ts文件，只想编译一个可以在ts配置项中加入include： &quot;include&quot;:[&quot;text.ts&quot;], 如果想除了某个文件不编译，剩下的都编译，可以使用exclude： &quot;exclude&quot;:[&quot;text.ts&quot;], files和include没有什么区别： &quot;files&quot;:[&quot;text.ts&quot;], compilerOptions配置 removeComments 这个配置意思就是编译后不输出注释 strict 这个设置为true,就代表严格执行ts语法，要严格按照ts语法来编写。 noImplicitAny 允许你的注解类型 any 不用特意表明，如果此时设置了true,看例子： //这时候编译会报错 function test(name) { return name; } //正确 function test(name:any) { return name; } strictNullChecks 意思就是，不强制检查null类型,此时如果配置为true看例子: //此时就不会报错 const test: string = null; outDir和rootDir 此项配置是来指定文件目录和打包后存放目录，rootDir为文件目录，outDir为打包后保存的目录 { &quot;outDir&quot;: &quot;./build&quot; , &quot;rootDir&quot;: &quot;./src&quot; , } 编译ES6语法 可以使用target和allowJs，target默认为true &quot;target&quot;:'es5' , // 这一项默认是开启的，你必须要保证它的开启，才能转换成功 &quot;allowJs&quot;:true, // 这个配置项的意思是联通 sourceMap sourceMap 简单说，Source map 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 noUnusedLocals 设置noUnusedLocals为true，编译代码： const name:tring='111'; export const age = &quot;text&quot;; 这时候就会报错，因为有name变量没有使用。 更多 更多可以查看 配置查询网站 联合类型和类型保护 联合类型 联合类型的意思就是允许一个类型有两种或者两种以上的类型: interface Test{ name:string; say:()=&gt;{ } } interface Test2{ name:string; call:()=&gt;{}; } function Tom(fun: Test | Test2){ console.log(fun.name) } 如果此时修改一下方法： function Tom(fun: Test | Test2){ fun.say() } //报错 这是因为只能访问两个类型的共有方法。 类型保护-类型断言 上面的方法，如果修改完报错，这时候我们可以用as来判断： interface Test { text: boolean; say(): void } interface Test2 { text: boolean; skill():string } function judgeWho(val: Waiter | Teacher) { if (val.text) { (val as Teacher).skill(); }else{ (val as Waiter).say(); } } const a={ text:true, skill:function():void{ console.log(1) }, say:function():void{ console.log(2) } } judgeWho(a) //1 类型保护-in语法 in方法与断言比较类似，使用方法如下： interface Person{ name:string; say:()=&gt;{ } } interface Person2{ name:string; todo:()=&gt;{ } }; function tom(val:Person|Person2){ if('todo' in val){ val.todo() }else{ val.say() } } 类型保护-typeof语法 可以用typeof方法来判断： function add(name:string|number,name2:string|number){ if(typeof name==='string'||typeof name2=='string'){ return name+'---'+name2 }else{ return name+name2 } } add(1,2) 类型保护-instanecof语法 如果要保护类型是一个对象，就可以使用instanceof： class NumObject{ num:number } function numbers(num1:object|NumObject,num2:object|NumObject){ if(num1 instanceof NumObject &amp;&amp; num2 instanceof NumObject){ return num1.num+num2.num } } Enum枚举类型 我们平时会有这种写法： function getName(status:any){ if(status===0){ return 'one' }else if(status===1){ return 'two' }else{ return 'three' } } console.log(getName(0)) 这么写可能有点麻烦，阅读起来还是有点麻烦，这时候可以这么写： const Status={ ONE:0, TWO:1, THREE:3 } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(getName(0)); 这时候我们的枚举就要上场了： enum Status{ ONE, TWO, THREE } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(getName(1)); 一样也可以输出，因为枚举是有对应数字值的，默认从0开始，当然也可以改变： enum Status{ ONE=1, TWO,//2 THREE//3 } 也可以进行返查操作： enum Status{ ONE, TWO, THREE } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(Status.ONE,Status[1]); 泛型 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 在函数中使用 我们先编写一个函数： function add(one:string,two:string){ return `${one}${two}` } console.log(add('a','b')) 这时候我们希望参数更加灵活一些，两个参数为number或者string： function add(one:string|number,two:string|number){ return `${one}${two}` } console.log(add('a','b')) 这么书写有些麻烦，这时候就可以使用泛型： function add&lt;T&gt;(one:T,two:T){ return `${one}${two}` } console.log(add&lt;string&gt;('a','b')) 在使用中，泛型通常用 &lt;T&gt; 来进行表示。泛型可以有多个吗？当然可以： function add&lt;T,P&gt;(one:T,two:P){ return `${one}${two}` } console.log(add&lt;string,number&gt;('a',2)) 同时泛型也支持类型推断： function add&lt;T,P&gt;(one:T,two:P){ return `${one}${two}` } console.log(add&lt;string,number&gt;('a',2)) 在类中使用 首先先写一个类,且接受参数为一个数组，数组里面存放string类型的数据： class List { constructor(private list:string[]) {}; getItem(index:number):string{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 这时候如果我们传递数组时候里面又想放数字怎么办： class List { constructor(private list:string[]|number[]) {}; getItem(index:number):string|number{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 这么写就比较复杂了,这时候就可以使用泛型来简化我们的代码： class List&lt;T&gt;{ constructor(private list:T[]) {}; getItem(index:number):T{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 发现上面的代码没有报错？因为类型推论，所以不会报错，严格意义上应该new的时候加上类型： const list=new List&lt;string&gt;(['girl','boy','wom']); 还有一种场景，传递过来是一个数组对象，这时候可以通过继承来解决： interface People{ name:string } class List&lt;T extends People&gt;{ constructor(private list:T[]) {}; getItem(index:number):string{ return this.list[index].name } }; const list=new List( [ {name:'boy'}, {name:'girl'} ] ); console.log(list.getItem(1)) 泛型约束 上面例子中，泛型可以为任意值，但有时候我们希望还是能稍微约束一下： function list&lt;T extends number|string&gt;(name:T){ return `${name}` } console.log(list&lt;number&gt;(1)) class List&lt;T extends number|string&gt; { constructor(private list:T[]) { }; getItem(index:number):T{ return this.list[index] } } const list=new List([1,2]) console.log(list.getItem(0)) Namespace命名空间 新建一个ts项目 首先，我们建立一个项目文件，然后npm init -y生成package.json文件，然后再tsc -init生成ts配置文件。 在根目录下新建index.html文件，再建立一个src和bulid目录，在src目录下新建一个index.js。 配置tsconfig.json文件，设置入口和输出目录（outDir和rootDir）。 打开index.html,引入js文件： &lt;script src=&quot;./build/index.js&quot;&gt;&lt;/script&gt; 在新建的ts文件中随便写点什么： console.log('hello'); 然后tsc编译一下，打开控制台，我们就可以看到了 编写一个小组件 在我们刚刚建立的index.ts文件，写一个header、content和footer组件： class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } class Page { constructor() { new Header(); new Content(); new Footer(); } } 然后在index.html中加一行js代码： &lt;script&gt;new Page();&lt;/script&gt; 这时候我们可以看到内容正常输出，但有一个问题，我们的Header、content和footer都暴露了出来，并不是只暴露一个page，这时候我们的命名空间就派上了用场： 命名空间 命名空间声明的关键词是namespace 比如声明一个namespace Home,需要暴露出去的类，可以使用export关键词，这样只有暴漏出去的类是全局的，其他的不会再生成全局污染了。 namespace Home { class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } export class Page { constructor() { new Header(); new Content(); new Footer(); } } } 这么写也是比较麻烦，因为我们需要引入两个文件，我们可以通过配置来让他成为一个文件，打开tsconfig.json,找到这一行： &quot;module&quot;:&quot;commonjs&quot; //修改为： &quot;module&quot;:&quot;amd 然后找到这一行： { &quot;outFile&quot;: &quot;./build/index.js&quot; } 子命名空间 如果在刚刚的组件中再写一个会怎么样？ namespace Components { export namespace SubComponents { export class Test {} } //someting ... } //读取 // Components.SubComponents.Test ts中使用import 首先建立一个文件compontent.ts,随便写点东西，然后使用export导出： export class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } export class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } export class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } 然后在index.ts中导入一下： import { Header, Content, Footer } from &quot;./compontent&quot;; export class Page{ constructor(){ new Header(); new Content(); new Footer(); } } 运行tsc编译，打开build中的index.js,可以看到代码是define开头的，这是 amd 规范的代码，不能直接在浏览器中运行，可以在 Node 中直接运行，所以我们还需要借助require.js的支持： &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js&quot;&gt;&lt;/script&gt; 然后在index.html中使用require.js写法： &lt;script&gt; require([&quot;page&quot;], function (page) { new page.default(); }); &lt;/script&gt; ```# TypeScript基础知识梳理 &gt; 之前一直打算看看ts，但一直沉迷摸🐟无法自拔，公司目前项目中也没有ts项目。今年手上正好有两个小程序项目，于是打算用ts写一下，感受一下ts的“魅力”。顺便整理了一下学习笔记，希望能帮到有需要的人。同时也用**XMind**做了知识图谱，有需要源文件的可以联系我。 ## 安装与编译 ### 安装 ```js npm install -g typescript //mac下安装前面需要加sudo 编译 可以执行下面命令进行编译，会在当前目录下产生一个test.js文件 tsc test.ts 这样可能还是比较麻烦，我们可以借助插件方便我们提高效率： npm install -g ts-node 安装完后只需执行ts-node test.ts就可以在控制台查看输出结果。 原始数据类型 js中数据类型分两种，原始数据类型和对象类型，原始类型包括：布尔值、数字、字符串、null、undefined以及Symbol。 布尔值 在TypeScript中，使用boolean定义布尔值类型 let isStatus:boolean=true; 数字 使用number定义数值类型 let isNumber:number=1; //16进制(编译后显示10进制数字) let isNumber16:number:=0b1010; 字符串 使用string定义字符串类型： let isString:string='hello word'; let year:number=2020; let add:string=`${isString},${year}!`; 空值 JavaScript 没有空值（Void）的概念，在TypeScript中，可以用void表示没有任何返回值的函数. function alertName():void{ alert(&quot;my name is tom&quot;) } 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null。 let unusable: void = undefined; Null 和 Undefined 在TypeScript中可以使用null和undefined来定义这两个原始数据类型 let u:undefined=undefined; let n:null=null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说undefined类型的变量，可以赋值给number类型的变量，而void类型的变量不能赋值给number类型的变量： let num:number=undefined;//不会报错 let u:undefined; let num: number = u;//也不会报错 let u:void; let num:number=u;// Type 'void' is not assignable to type 'number'. 任意值 任意值（Any）用来表示允许赋值为任意类型。 什么是任意值类型 如果是一个普通类型，在赋值过程中改变类型是不被允许的： let renyiString:string='string'; renyiString=8; //Type 'number' is not assignable to type 'string'. 但如果类型是Any,类型，则允许被赋值为任意类型: let renyiString:any='string'; renyiString=8; 在任意值上访问任何属性都是允许的： let anyThis:any='hello'; console.log(anyThis.myName) console.log(anyThis.myName.firstName) 也允许调用任何方法： let anyThing: any = 'Tom'; anyThing.setName('Jerry'); anyThing.setName('Jerry').sayHello(); anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： let something; something = 'seven'; something = 7; something.setName('Tom'); 等于 let something: any; something = 'seven'; something = 7; something.setName('Tom'); 数组的类型 基础表示 「类型 + 方括号」表示法 let numbers:number[]=[1,2,3,4,5] 此时不允许出现其他类型，而且如果使用数组中push等方法，添加元素也得符合相应类型。 数组泛型 我们也可以使用数组泛型（Array Generic） Array&lt;elemType&gt; 来表示数组 let fibonacci:Array&lt;number&gt;=[1,2,3,4,] 如果数组中又有number类型又有string类型，则可以用｜符号来区别定义： let arr:(number|string)[]=['tom',1]; 数组中对象类型的定义 项目中经常遇到数组中有对象的存在，对于这种就比较麻烦了，比如： let arr:{name:string,age:number}[]=[ {name:'tom',age:18} ] 这样就比较麻烦了，我们可以使用ts中的类型别名来解决这个问题： type PeopleType={name:String,age:Number}; let arr:PeopleType[]=[ {name:'bob',age:19} ] 也可以用类型定义也可以解决： class PeopleType{ name:string; age:number } let arr:PeopleType[]=[ {name:'bob',age:19} ] 元组的使用和类型约束 在数组中如果里面又有string和number,可以使用｜来进行定义，但一定程度上并不严格。比如改成下面这种格式： let arr:(number|string)[]=[111,'222',111]; ts并没有报错，如果想要严格限制，则可以这样进行约束： let arr:[number,string,number]=[111,'222',111]; Interface接口 比如我们要做一个筛选，吧不符合条件的过滤出去，我们可能会这样写： const types=(name:string,age:number,height:number)=&gt;{ age&gt;=20 &amp;&amp; height&gt;=180 &amp;&amp; console.log('符合条件'); age&lt;=20 &amp;&amp; height &lt;180 &amp;&amp;console.log('不符合') }; types('tom',20,180) //符合条件 但如果又修改了一些需求，可能还会去大量变更代码，在开发中，代码能复用肯定是最好的，所以可以把一些重复的代码抽离出来： interface People{ name:string; age:number; height:number; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const choose=(people:People)=&gt;{ console.log(people.name+'----'+people.age+'---'+people.height) } const people={ name:'tom', age:18, height:178 } types(people); choose(people); 接口与类型别名的区别 看起来两者没有什么区别，但有个小细节：类型别名可以直接给类型，接口必须代表对象 type People=string; interface People{ name:string; age:number; height:number; } 如果传入的参数中有不确定项，我们可以使用 ?: 来进行处理： interface People{ name:string; age:number; height:number; say?:string }; const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178 } const people2={ name:'tom', age:18, height:178, say:'hello' } types(people); types(people2); 这时候又有新需求了，如何在后面加入任意多的字段？这时候我们就可以这么写： interface People{ name:string; age:number; height:number; say?:string; [propname:string]:any; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123 } types(people); 接口里的方法 接口不仅仅可以存属性，也可以存方法： interface People{ name:string; age:number; height:number; goto():string; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, goto(){ return 'hello' } } types(people) 接口和类的约束 在ES6中是有类的概念，类可以和接口相结合： interface People{ name:string; age:number; height:number; goto():string; } const types=(people:People)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123, goto(){ return 'hello' } }; class newPeople implements People{ name='bob'; age=19; height:190; say:'hello'; add:'new add2'; addNumber:123; goto(){ return 'hi' } }; let a=new newPeople(); console.log(a.goto()) types(people) 接口的继承 接口与接口也是可以继承的： interface People{ name:string; age:number; height:number; say?:string; [propname:string]:any; goto():string; } const types=(people:newPeople)=&gt;{ people.age&gt;=20 &amp;&amp; people.height&gt;=180 &amp;&amp; console.log('符合条件'); people.age&lt;=20 &amp;&amp; people.height &lt;180 &amp;&amp;console.log('不符合') }; const people={ name:'tom', age:18, height:178, say:'hello', add:'new add', addNumber:123, goto(){ return 'hello' }, back(){ console.log(1) } } interface newPeople extends People{ back():void } types(people) 类的基本使用 首先，我们先创建一个类： class Test{ name='say' say(){ return this.name } }; 这就是平时所写的类，在ts中的继承和ES6的继承是一样的，关键字也是extends，比如我们这里新建个类，继承Text; class Test{ name='say' say(){ return this.name } }; class NewTest extends Test{ back(){ return 'hello' } } const tom=new NewTest(); console.log(tom.say()); console.log(tom.back()); super关键字的使用 如果想在say方法中后面加点东西，可以这么操作： class Test{ name='say' say(){ return this.name } }; class NewTest extends Test{ back(){ return 'hello' } say(){ return super.say()+'----hello' } } const tom=new NewTest(); console.log(tom.say()); console.log(tom.back()); ts中类的访问类型 ts中的访问类型就是基于三个关键字：private、protected以及pubilc这三种访问类型。看例子，先定义一个类，然后用这个类的对象，进行赋值： class Person{ name:string } const person=new Person(); person.name='tom'; console.log(person.name) pubilc 运行可以看到正常的输出内容，这是因为如果不对name的访问属性进行定义，那么他的默认属性就是pubilc,从字面意思来看，它的意思就是公用的，允许在类的内部和外部被调用。 class Person{ public name:string } const person=new Person(); person.name='tom'; console.log(person.name) private private的属性意思就是只允许在类的内部调用，不能在外部调用 class Person{ private name:string; public say(){ console.log(this.name+'-----hello'); } } const person=new Person(); person.name='tom';//报错 console.log(person.name)//报错 protected protected允许在类内以及继承的子类中使用，把刚刚的name改成protected属性，这时候在外部就会报错，这时候再写一个继承，代码如下： class Person{ protected name:string; public say(){ console.log(this.name+'-----hello'); } } const person=new Person(); person.name='tom';//报错 console.log(person.name)//报错 class NewPerson extends Person{ public back(){ console.log(this.name) } } const newperson=new NewPerson(); newperson.back()//正常 类的构造函数 首先新建一个类：Person,定义一个name，并在new的时候进行参数传递，然后打印出来，这时候我们就可以使用构造函数constructor : class Person{ pubilc name:string; constructor(name){ this.name=name } }; const person=new Person('tom'); console.log(person.name); 可以看到可以打印出来，但是上面写法有点麻烦，还可以再进行简化： class Person{ constructor(pubilc name:string){} }; const person=new Person('tom'); console.log(person.name); 类继承中的构造器写法 普通的书写方法上面已经演示了，在子类中使用构造函数需要用**super()**调用父类的构造函数，直接看代码： class Person{ constructor(pubilc name:string){} }; class Teacher extends Person{ constructor(pubilc age:number){ super() } }; const teacher=new Teacher(18); console.log(teacher.age+'---'+teacher.name); ts中类的Getter、Setter、static以及readonly 在上面中提到了访问类型private,它的最大用处就是封装一个书写，然后通过Getter和Setter去访问和修改： class Person{ constructor(private _age:number){ } } 如果想让别人知道，就可以使用Getter来实现，他并不是一个方法，只是一个属性： class Person{ constructor(private _age:number){ }; get age(){ return this._age } }; const person=new Person(30); console.log(person.age) 这时候你可能会觉得这不是多此一举吗？但在Getter中可以对 _age进行处理： class Person{ constructor(private _age:number){ }; get age(){ return this._age-10 } }; const person=new Person(30); console.log(person.age) 既然 _age是私有的，我们无法进行改变，这时候就可以用Setter进行改变： class Person{ constructor(private _age:number){ }; get age(){ return this._age } set age(age:number){ this._age=age } }; const person=new Person(30); person.age=20; console.log(person.age) 在类中，如果想用这个类的实例，就必须先进行new操作，但有没有一种方法不需要new就可以？ //常规方法 class Person{ say(){ return 'say hello' } }; const person=new Person(); console.log(person.say()); 在ts中，我们不想new的话可以这么写： class Person{ static say(){ return 'say hello' } }; console.log(Person.say()) readonly在初始化后赋值，以后就不能进行修改 class Person{ constructor(readonly name:string){} } let p=new Person('tom'); p.name='bob'//报错 console.log(p.name); 类的抽象类 abstract 用于定义抽象类和其中的抽象方法。它有几个特点： 抽象类是不允许实例化的 //错误演示 abstract class Person { public abstract say() } const tom=new Person()//无法创建抽象类的实例 抽象类中的抽象方法必须被子类实现： //错误演示 abstract class Person { abstract say(){ console.log('hello') } } class Tom extends Person{ say(){ console.log('say hello') } }; //正确方法 abstract class Person { abstract say() } class Tom extends Person{ say(){ console.log('say hello') } }; tsconfig.json配置 生成 我们可以通过tsc --init去生成ts配置文件: tsc --init //终端执行 编译 会生成一个tsconfig.json文件，我们在ts文件中可以随便写点什么： //测试tsconfig.json const test:string='tsconfig.json'; 然后打开tsconfig.json文件，找到complilerOptions属性下的removeComments:true（这个配置是编译后不输出注释），取消掉注释，然后执行命令： tsc 这时候打开生成的js文件，发现没有注释，说明成功。 include 、exclude 和 files 如果有多个ts文件，只想编译一个可以在ts配置项中加入include： &quot;include&quot;:[&quot;text.ts&quot;], 如果想除了某个文件不编译，剩下的都编译，可以使用exclude： &quot;exclude&quot;:[&quot;text.ts&quot;], files和include没有什么区别： &quot;files&quot;:[&quot;text.ts&quot;], compilerOptions配置 removeComments 这个配置意思就是编译后不输出注释 strict 这个设置为true,就代表严格执行ts语法，要严格按照ts语法来编写。 noImplicitAny 允许你的注解类型 any 不用特意表明，如果此时设置了true,看例子： //这时候编译会报错 function test(name) { return name; } //正确 function test(name:any) { return name; } strictNullChecks 意思就是，不强制检查null类型,此时如果配置为true看例子: //此时就不会报错 const test: string = null; outDir和rootDir 此项配置是来指定文件目录和打包后存放目录，rootDir为文件目录，outDir为打包后保存的目录 { &quot;outDir&quot;: &quot;./build&quot; , &quot;rootDir&quot;: &quot;./src&quot; , } 编译ES6语法 可以使用target和allowJs，target默认为true &quot;target&quot;:'es5' , // 这一项默认是开启的，你必须要保证它的开启，才能转换成功 &quot;allowJs&quot;:true, // 这个配置项的意思是联通 sourceMap sourceMap 简单说，Source map 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 noUnusedLocals 设置noUnusedLocals为true，编译代码： const name:tring='111'; export const age = &quot;text&quot;; 这时候就会报错，因为有name变量没有使用。 更多 更多可以查看 配置查询网站 联合类型和类型保护 联合类型 联合类型的意思就是允许一个类型有两种或者两种以上的类型: interface Test{ name:string; say:()=&gt;{ } } interface Test2{ name:string; call:()=&gt;{}; } function Tom(fun: Test | Test2){ console.log(fun.name) } 如果此时修改一下方法： function Tom(fun: Test | Test2){ fun.say() } //报错 这是因为只能访问两个类型的共有方法。 类型保护-类型断言 上面的方法，如果修改完报错，这时候我们可以用as来判断： interface Test { text: boolean; say(): void } interface Test2 { text: boolean; skill():string } function judgeWho(val: Waiter | Teacher) { if (val.text) { (val as Teacher).skill(); }else{ (val as Waiter).say(); } } const a={ text:true, skill:function():void{ console.log(1) }, say:function():void{ console.log(2) } } judgeWho(a) //1 类型保护-in语法 in方法与断言比较类似，使用方法如下： interface Person{ name:string; say:()=&gt;{ } } interface Person2{ name:string; todo:()=&gt;{ } }; function tom(val:Person|Person2){ if('todo' in val){ val.todo() }else{ val.say() } } 类型保护-typeof语法 可以用typeof方法来判断： function add(name:string|number,name2:string|number){ if(typeof name==='string'||typeof name2=='string'){ return name+'---'+name2 }else{ return name+name2 } } add(1,2) 类型保护-instanecof语法 如果要保护类型是一个对象，就可以使用instanceof： class NumObject{ num:number } function numbers(num1:object|NumObject,num2:object|NumObject){ if(num1 instanceof NumObject &amp;&amp; num2 instanceof NumObject){ return num1.num+num2.num } } Enum枚举类型 我们平时会有这种写法： function getName(status:any){ if(status===0){ return 'one' }else if(status===1){ return 'two' }else{ return 'three' } } console.log(getName(0)) 这么写可能有点麻烦，阅读起来还是有点麻烦，这时候可以这么写： const Status={ ONE:0, TWO:1, THREE:3 } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(getName(0)); 这时候我们的枚举就要上场了： enum Status{ ONE, TWO, THREE } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(getName(1)); 一样也可以输出，因为枚举是有对应数字值的，默认从0开始，当然也可以改变： enum Status{ ONE=1, TWO,//2 THREE//3 } 也可以进行返查操作： enum Status{ ONE, TWO, THREE } function getName(status:any){ if(status===Status.ONE){ return 'one' }else if(status===Status.TWO){ return 'two' }else{ return 'three' } } console.log(Status.ONE,Status[1]); 泛型 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 在函数中使用 我们先编写一个函数： function add(one:string,two:string){ return `${one}${two}` } console.log(add('a','b')) 这时候我们希望参数更加灵活一些，两个参数为number或者string： function add(one:string|number,two:string|number){ return `${one}${two}` } console.log(add('a','b')) 这么书写有些麻烦，这时候就可以使用泛型： function add&lt;T&gt;(one:T,two:T){ return `${one}${two}` } console.log(add&lt;string&gt;('a','b')) 在使用中，泛型通常用 &lt;T&gt; 来进行表示。泛型可以有多个吗？当然可以： function add&lt;T,P&gt;(one:T,two:P){ return `${one}${two}` } console.log(add&lt;string,number&gt;('a',2)) 同时泛型也支持类型推断： function add&lt;T,P&gt;(one:T,two:P){ return `${one}${two}` } console.log(add&lt;string,number&gt;('a',2)) 在类中使用 首先先写一个类,且接受参数为一个数组，数组里面存放string类型的数据： class List { constructor(private list:string[]) {}; getItem(index:number):string{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 这时候如果我们传递数组时候里面又想放数字怎么办： class List { constructor(private list:string[]|number[]) {}; getItem(index:number):string|number{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 这么写就比较复杂了,这时候就可以使用泛型来简化我们的代码： class List&lt;T&gt;{ constructor(private list:T[]) {}; getItem(index:number):T{ return this.list[index] } }; const list=new List(['girl','boy','wom']); console.log(list.getItem(1)) 发现上面的代码没有报错？因为类型推论，所以不会报错，严格意义上应该new的时候加上类型： const list=new List&lt;string&gt;(['girl','boy','wom']); 还有一种场景，传递过来是一个数组对象，这时候可以通过继承来解决： interface People{ name:string } class List&lt;T extends People&gt;{ constructor(private list:T[]) {}; getItem(index:number):string{ return this.list[index].name } }; const list=new List( [ {name:'boy'}, {name:'girl'} ] ); console.log(list.getItem(1)) 泛型约束 上面例子中，泛型可以为任意值，但有时候我们希望还是能稍微约束一下： function list&lt;T extends number|string&gt;(name:T){ return `${name}` } console.log(list&lt;number&gt;(1)) class List&lt;T extends number|string&gt; { constructor(private list:T[]) { }; getItem(index:number):T{ return this.list[index] } } const list=new List([1,2]) console.log(list.getItem(0)) Namespace命名空间 新建一个ts项目 首先，我们建立一个项目文件，然后npm init -y生成package.json文件，然后再tsc -init生成ts配置文件。 在根目录下新建index.html文件，再建立一个src和bulid目录，在src目录下新建一个index.js。 配置tsconfig.json文件，设置入口和输出目录（outDir和rootDir）。 打开index.html,引入js文件： &lt;script src=&quot;./build/index.js&quot;&gt;&lt;/script&gt; 在新建的ts文件中随便写点什么： console.log('hello'); 然后tsc编译一下，打开控制台，我们就可以看到了 编写一个小组件 在我们刚刚建立的index.ts文件，写一个header、content和footer组件： class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } class Page { constructor() { new Header(); new Content(); new Footer(); } } 然后在index.html中加一行js代码： &lt;script&gt;new Page();&lt;/script&gt; 这时候我们可以看到内容正常输出，但有一个问题，我们的Header、content和footer都暴露了出来，并不是只暴露一个page，这时候我们的命名空间就派上了用场： 命名空间 命名空间声明的关键词是namespace 比如声明一个namespace Home,需要暴露出去的类，可以使用export关键词，这样只有暴漏出去的类是全局的，其他的不会再生成全局污染了。 namespace Home { class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } export class Page { constructor() { new Header(); new Content(); new Footer(); } } } 这么写也是比较麻烦，因为我们需要引入两个文件，我们可以通过配置来让他成为一个文件，打开tsconfig.json,找到这一行： &quot;module&quot;:&quot;commonjs&quot; //修改为： &quot;module&quot;:&quot;amd 然后找到这一行： { &quot;outFile&quot;: &quot;./build/index.js&quot; } 子命名空间 如果在刚刚的组件中再写一个会怎么样？ namespace Components { export namespace SubComponents { export class Test {} } //someting ... } //读取 // Components.SubComponents.Test ts中使用import 首先建立一个文件compontent.ts,随便写点东西，然后使用export导出： export class Header { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); } } export class Content { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); } } export class Footer { constructor() { const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); } } 然后在index.ts中导入一下： import { Header, Content, Footer } from &quot;./compontent&quot;; export class Page{ constructor(){ new Header(); new Content(); new Footer(); } } 运行tsc编译，打开build中的index.js,可以看到代码是define开头的，这是 amd 规范的代码，不能直接在浏览器中运行，可以在 Node 中直接运行，所以我们还需要借助require.js的支持： &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js&quot;&gt;&lt;/script&gt; 然后在index.html中使用require.js写法： &lt;script&gt; require([&quot;page&quot;], function (page) { new page.default(); }); &lt;/script&gt; ","link":"https://lonjinup.github.io/kstypescript/"},{"title":"前端复习笔记","content":"金三银四 2021年前端面试笔记 又到了找工作的黄金时间，3-4月份，跳槽是每个人的职业生涯中都要经历的过程，笔者最近也是复习了一波，整理了一下面试中关于javascript和vue的一些问题。看到本文的你如果感觉对你有帮助，不如素质三连，码字不易，感谢您的支持！ JavaScript 数据类型 介绍一下js中的数据类型以及值是如何存储的 JavaScript中一共有8种数据类型，其中基本数据类型有：Null、Undefined、Boolean、String、Number、Bigint、Symbol。 还有一种数据类型object：里面包含function、Array、Date等。 基本数据类型保存在栈区中，占据空间小、大小固定。 引用数据类型保存在栈区和堆区，占据空间大，且大小不固定。引用数据类型在栈区中存放了指针，指针指向堆区的实际地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 js中数据类型判断 说一说在js中判断数据类型的方法 typeof typeof可以判断原始数据类型，除了null之外： console.log(typeof 2) //number console.log(typeof 'hello') //string console.log(typeof null) //object console.log(typeof true)//boolean console.log(typeof undefined) //undefined console.log(typeof []) //object 因为因为特殊值null被认为是一个对空对象的引用 instanceof instanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype: console.log([] instanceof Array) //true console.log({} instanceof Object)//true console.log(function(){} instanceof Function)//true console.log(1 instanceof Number)//false constructor constructor主要是利用原型上的prototype.constructor指向实例的构造函数来进行判断的 console.log((1).constructor === Number) //true console.log('1'.constructor===String)//true console.log((function(){}).constructor===Function) //true console.log([].constructor===Array) //true console.log(({}).constructor===Object) //true 但constructor有个特点就是：如果我创建了一个对象，我们再去修改它的原型，就变得不那么可靠： function Func(){} Func.prototype=new Array(); const f=new Func() console.log(f.constructor===Function)//false Object.prototype.toString.call 使用 Object 对象的原型方法toString,返回值是[object 类型]字符串,该方法基本上能判断所有的数据类型. var toString = Object.prototype.toString; console.log(toString.call(2)) //[object Number] console.log(toString.call(true)) //[object Boolean] console.log(toString.call(function(){})) //[object Function] 作用域和作用域链 谈一谈你对作用域、作用域链的理解。 作用域：作用域就是定义变量的区域，它有一套访问变量的规则，根据这套规则来管理浏览器引擎如何在当前作用域和嵌套作用域中中根据变量（标识符）进行变量查找。 作用域链：作用域链保证对执行环境有权访问所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境中的变量和函数。 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找 this 谈一谈你对this的理解，以及在各种环境下的this 在浏览器里，在全局范围内this指向window对象 在函数中，this永远指向最后调用他的那个对象(箭头函数除外)。 在构造函数中，this指向new出来的新对象。 call、apply、bind中的this被强绑定在指定的那个对象上。 箭头函数this为父作用域的this，不是调用时的this。 原型，原型链 谈一谈JavaScript中原型，原型链，有什么特点 在js中，我们可以通过构造函数来创建一个对象，每个构造函数都会有个prototype属性，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是Object.prototype。 function Func(name){ this.name=name }; let tom=new Func('TOM'); console.log(tom) console.log(tom.__proto__===Func.prototype) //true console.log(tom.__proto__.constructor==Func) //true 再上一张图，更好理解 原型对象的作用： function Func(name){ this.name=name; this.say=function(){ console.log(this.name) } } let m=new Func('tom'); let n=new Func('tom') console.log(m) console.log(n) console.log(m.say===n.say) //false 每次进行new，都会开辟新的区域，这样很显然不好，所以我们可以吧共有的方法放在原型对象上，这样就避免了内存浪费： function Func(name){ this.name=name; } Func.prototype.say=function(){ console.log(this.name) } let m=new Func('tom'); let n=new Func('tom') console.log(m) console.log(n) console.log(m.say===n.say) //true 闭包 谈一谈对闭包的理解，以及使用场景 闭包是指有权访问另一个函数作用域内的变量的函数。闭包最常见的就是在函数中创建函数，创建的函数就可以访问到当前函数的局部变量。 过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。 function func(){ let n=0; function add(){ n++; console.log(n) } return add } let a=func(); a() //1 a()//2 事件模型 什么是事件？都有哪几种事件？ 事件是指用户操作页面时候发生的交互或者网页本身的一些操作，浏览器一共有三种事件模型： DOM0级模型：这种模型不会传播，没有事件流的概念，但现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过js属性来指定监听函数。 IE事件模型：在这种事件模型中，一次事件一共有两个过程，事件处理阶段和事件冒泡阶段，事件处理阶段首先会执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从冒泡到document，一次检查经过的节点是否绑定了事件监听函数，会按顺序依次进行。 DOM2级事件模型：在该事件模型中，一次事件一共有三个过程，第一个过程就是事件捕获阶段，捕获指的是事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面的两个阶段和IE事件模型基本一样。这样的事件模型，事件绑定的函数就是addEventListener,其中第三个参数可以指定事件是否在捕获阶段执行。 //DMO0 element.onclick=function(){} //DOM2 element.addEventListener('click',function(){},false) //DOM3 增加了鼠标事件，键盘事件 element.addEventListener('keyup',function(){},false) DOM事件的捕获流程:window---&gt;document---&gt;html---&gt;body---&gt;逐渐传递 DOM事件冒泡过程：目标元素---&gt;父元素---&gt;body---&gt;html---&gt;document---&gt;window Event对象的常见应用 event.preventDefault() //阻止默认行为 比阻止点击a标签转跳 event.stopPropagation() //阻止事件冒泡 event.stoplmmediatePropagation() //同时注册两个事件，决定事件优先级 event.currentTarget() //事件代理，把子元素的事件委托给父元素 event.target() //当前被点击的元素 异步编程 谈一谈js中的异步编程方案，它为了解决什么？ 我们之前写代码，可能会出现函数嵌套函数，如果多个嵌套，结构就会很乱，也不容易维护，于是便有了异步编程的概念。 Promise Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象的状态不受外界影响，它有三种状态，pending(进行中)、fulfilled(已成功)、rejected(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。它的状态可以从pending变为fulfilled，或者从pending变为rejected。 then方法 Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。 const testPormise=new Promise((resovle,reject)=&gt;{ console.log(&quot;hi,Pormise&quot;); let test=true; if(test){ resovle('成功～') }else{ reject(&quot;失败了&quot;) } }); testPormise.then((res)=&gt;{ console.log(res) }).catch((erro)=&gt;{ console.log(erro) }) rejected 只有执行了rejected这样就可以在then中捕获到，然后执行失败情况下的回调： let p = new Promise((resolve, reject) =&gt; { //做一些异步操作 setTimeout(function(){ var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=3){ resolve(num); } else{ reject('数字太大了'); } }, 2000); }); p.then((data) =&gt; { console.log('resolved',data); },(err) =&gt; { console.log('rejected',err); } ); catch catch和then用法一样，用来指定reject的回调： p.then((data) =&gt; { console.log('resolved',data); }).catch((err) =&gt; { console.log('rejected',err); }); all all接收一个数组参数，里面的值最终都算返回Promise对象,谁执行的慢，以谁为准执行回调： let Promise1 = new Promise(function(resolve, reject){}) let Promise2 = new Promise(function(resolve, reject){}) let Promise3 = new Promise(function(resolve, reject){}) let p = Promise.all([Promise1, Promise2, Promise3]) p.then(funciton(){ // 三个都成功则成功 }, function(){ // 只要有失败，则失败 }) race 谁跑的快，以谁为准执行回调,常见应用场景为设置请求超时时间，在请求超时后执行相应的回调。 Event Loop 说一说js中事件执行机制是怎么样的？ “JavaScript 是单线程、异步、非阻塞、解释型脚本语言”。JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。 在js中，任务进入执行栈，先判断任务类型，如果是同步任务，直接进入到主线程执行。如果是异步任务，会把任务放到异步队列，等同步任务执行完以后，事件触发线程会从消息队列中取出刚才加入队列的函数，如果有，就一条一条的去执行。 console.log(1) setTimeout(() =&gt; { console.log(2) }, 1000); console.log(3) //1 3 2 微任务 js中，setTimeout属于宏任务，像Promise为微任务， console.log(1) setTimeout(() =&gt; { console.log(2) }, 1000); let test=new Pormise((resolve)=&gt;{ console.log(3); resolve(); }) .then(=&gt;console.log(4)) console.log(5) 1.3 5 4.2 首先会输出1，然后遇到setTimeout，注册任务接着又遇到Pormise，首先先输出3，然后注册任务，接着会输出5，这时候执行栈没有可执行的，然后会从队列中取，这时候会先取出微任务进行执行，进入到then，输出4，这时候执行栈又为空，这时候继续从队列中取出一条任务，这时候会输出2。 继承 如何实现继承？怎么样能完美继承？ 构造函数继承,借助构造函数通过call apply改变指向实现继承，但这种继承方式有一个缺点：继承不了父类原型对象上的属性，只能继承构造函数内的属性。 function Parent1(){ this.name='Parent1' }; Parent1.prototype.say=function(){ console.log(this.name) } function Child1(){ Parent1.call(this);//apply this.type='Child1' } let n=new Child1(); console.log(n.say)//undefined 原型链实现继承,缺点：实例出来的是共用的。 function Parent(){ this.name='Parent1'; this.arr=[1,2,3,4,5] }; Parent.prototype.say=function(){ console.log(this.name) } function Child(){ this.type='Child1' } Child.prototype=new Parent(); var s1=new Child(); var s2=new Child(); s1.arr.push(6) console.log(s1.arr) //[1,2,3,4,5,6] console.log(s2.arr) //[1,2,3,4,5,6] //他们俩是公用的 console.log(s1.__proto__===s2.__proto__) //true 组合继承(借鉴上面两个的优点) function Parent(){ this.name='tom'; }; Parent.prototype.say=function(){ console.log(this.name) }; function Child(){ Parent.call(this) this.age=18; }; Child.prototype=Object.create(Parent.prototype); Child.prototype.constructor=Child; 移动端常见问题 如何禁止点击穿透 在移动端中经常会做弹窗，但是弹窗出来后滑动页面，底部元素也会滑动。这时候可以给body加一个样式： body.active{ position: fixed; left: 0; width: 100%; } 同时通过scrollingElement获得滚动偏移量，赋值给body一个top。 input高度塌陷 当页面同时出现以下三个条件时，键盘占位会把页面高度压缩一部分。当输入完成键盘占位消失后，页面高度有可能回不到原来高度，产生坍塌导致Webview底色露脸，简单概括就是输入框失焦后页面未回弹。 解决方法：input聚焦时候获取滚动偏移量，失去焦点以后重新赋值偏移量 const input =document.getElementById('input'); let scrollTop=0; input.addEventListener(&quot;focus&quot;,()=&gt;{ scrollTop=document.scollingElement.srollTop; }) input.addEventListener(&quot;blur&quot;,()=&gt;{ document.scollingElement.scrollTo(0,scrollTop) }) Vue vue生命周期 Vue有几个生命周期？哪个生命周期可以获取到真实DOM？修改data里面的数据，会触发什么生命周期？组件data为什么是一个函数？ 简单来说，vue的生命周期可以归为3类，创建阶段、运行阶段、销毁阶段。 创建阶段 beforeCreate：实例刚在内存中创建出来，还没有初始化 data和 methods，只包含一些自带额生命周期函数。 created：实例已经在内存中创建完成，此时data和methods已经创建完成。 beforeMount：此时已经编译模版，但没有渲染到页面中。 mounted：渲染模版，创建阶段到此结束。这时候可以操作dom。 运行阶段 beforeUpdate：界面中的数据还是旧的，但是data数据已经更新，页面中和data还没有同步。修改data数据就会触发这个函数。 updated：页面重新渲染完毕，页面中的数据和data保持一致。修改data数据就会触发这个函数。 销毁阶段 beforeDestroy：执行该方法的时候，Vue的生命周期已经进入销毁阶段，但是实例上的各种数据还出于可用状态。 destroyed：组件已经全部销毁，Vue实例已经被销毁，Vue中的任何数据都不可用 keep-alive activited：keep-alive 专属，组件被激活时调用 deactivated：keep-alive 专属，组件被销毁时调用 vue父组件和子组件的执行顺序 加载过程 父beforeCreate--&gt;父created--&gt;父beforeMount--&gt;子beforeCreate--&gt;子created--&gt;子beforeMpunt--&gt;子mounted--&gt;父mounted 子组件更新过程 父beforeUpdate--&gt;子beforUpdate--&gt;子updated--&gt;父updated 父组件更新过程 父beforeUpdate--&gt;父updated 销毁过程 父beforeDestroy--&gt;子beforeDestroy--&gt;子destroyed--&gt;父destroyed Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 (1)Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 (2)改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 组成部分 State:定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter:允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation:是唯一更改 store 中状态的方法，且必须是同步函数。 Action:用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module:许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 vue组件通信 vue组件如何通信？有几种方式？ 在vue中组件通讯可以分为父子组件通讯和非父子组件通信。 父子组件通信: props/ $emit/ $parent / $children; provide / inject ; ref ; $attrs / listeners兄弟组件通信:eventBus;vuex跨级通信:eventBus；Vuex；provide/inject、listeners 兄弟组件通信: eventBus ;vuex 跨级通信: eventBus；Vuex；provide / inject 、listeners兄弟组件通信:eventBus;vuex跨级通信:eventBus；Vuex；provide/inject、attrs / $listeners 下面演示几种常用的使用方法： props / $emit 父组件通过props的方式向子组件传递数据，而通过$emit子组件可以向父组件通信。 父组件向子组件传值(props) prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。 &lt;!-- section父组件 --&gt; &lt;template&gt; &lt;div class=&quot;section&quot;&gt; &lt;com-article :articles=&quot;articleList&quot;&gt;&lt;/com-article&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import comArticle from './test/article.vue' export default { name: 'HelloWorld', components: { comArticle }, data() { return { articleList: ['红楼梦', '西游记', '三国演义'] } } } &lt;/script&gt; // 子组件 article.vue &lt;template&gt; &lt;div&gt; &lt;span v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['articles'] } &lt;/script&gt; 子组件向父组件传值($emit) $emit绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数。 &lt;!-- 子组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;div v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot; @click=&quot;emitIndex(index)&quot;&gt;{{item}}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['articles'], methods: { emitIndex(index) { this.$emit('onEmitIndex', index) } } } &lt;/script&gt; &lt;!-- // 父组件中 --&gt; &lt;template&gt; &lt;div class=&quot;section&quot;&gt; &lt;com-article :articles=&quot;articleList&quot; @onEmitIndex=&quot;onEmitIndex&quot;&gt;&lt;/com-article&gt; &lt;p&gt;{{currentIndex}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import comArticle from './test/article.vue' export default { name: 'HelloWorld', components: { comArticle }, data() { return { currentIndex: -1, articleList: ['红楼梦', '西游记', '三国演义'] } }, methods: { onEmitIndex(idx) { this.currentIndex = idx } } } &lt;/script&gt; $children / $parent 通过parent和parent和parent和children就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和data。如在#app上拿parent得到的是newVue()的实例，在这实例上再拿parent得到的是new Vue()的实例，在这实例上再拿parent得到的是newVue()的实例，在这实例上再拿parent得到的是undefined，而在最底层的子组件拿children是个空数组。也要注意得到children是个空数组。也要注意得到children是个空数组。也要注意得到parent和children的值不一样，children的值不一样，children的值不一样，children 的值是数组，而parent是个对象。在∗∗vue3.0∗∗中，∗∗parent是个对象。在**vue3.0**中，**parent是个对象。在∗∗vue3.0∗∗中，∗∗children**已经被移除。 &lt;template&gt; &lt;div class=&quot;hello_world&quot;&gt; &lt;div&gt;{{msg}}&lt;/div&gt; &lt;!-- child --&gt; child &lt;com-a&gt;&lt;/com-a&gt; &lt;button @click=&quot;changeA&quot;&gt;点击改变子组件值&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ComA from './child' export default { name: 'HelloWorld', components: { ComA }, data() { return { msg: 'Welcome' } }, methods: { changeA() { // 获取到子组件A console.log(this.$children) this.$children[0].messageA = 'this is new value' } } } &lt;/script&gt; &lt;!-- 子组件中 --&gt; &lt;template&gt; &lt;div class=&quot;com_a&quot;&gt; &lt;span&gt;{{messageA}}&lt;/span&gt; &lt;p&gt;获取父组件的值为: {{parentVal}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { messageA: 'this is old' } }, computed:{ parentVal(){ return this.$parent.msg; } } } &lt;/script&gt; ref/refs ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据 &lt;!-- //子组件 --&gt; &lt;template&gt; &lt;div &gt;child&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { name: 'this is child' } }, methods: { sayHello(){ return 'say hello' } }, } &lt;/script&gt; &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div &gt; &lt;com-a ref=&quot;child&quot;&gt;&lt;/com-a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ComA from './child' export default { components: { ComA }, data() { return { msg: 'Welcome' } }, mounted() { const child = this.$refs.child; console.log(child.name) //this is child console.log(child.sayHello()) //say hello }, } &lt;/script&gt; eventBus eventBus 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难。 双向绑定的原理 vue2是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。Object.defineProperty()只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持。vue3中则采用Proxy，它可以监听到数组内的数据变化。 为什么 Vue 组件中 data 必须是一个函数？ 如果 data 是一个对象，当复用组件时，因为 data 都会指向同一个引用类型地址，其中一个组件的 data 一旦发生修改，则其他重用的组件中的 data 也会被一并修改。 如果 data 是一个返回对象的函数，因为每次重用组件时返回的都是一个新对象，引用地址不同，便不会出现如上问题。 Vue 中 computed 和 watch 有什么区别 计算属性 computed： （1）支持缓存，只有依赖数据发生变化时，才会重新进行计算函数； （2）计算属性内不支持异步操作； （3）计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属性)方法； （4）计算属性是自动监听依赖值的变化，从而动态返回内容。 侦听属性 watch: (1) 不支持缓存，只要数据发生变化，就会执行侦听函数； (2) 侦听属性内支持异步操作； (3) 侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性； (3) 监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些其他事情。 其他知识 在浏览器中输入url后都会发生什么 大致流程 1.URL 解析 2.DNS 查询 3.TCP 连接 4.处理请求 5.接受响应 6.渲染页面 结尾 更多前端学习文章，请点击前端进阶班，欢迎关注！记得素质三连！ ","link":"https://lonjinup.github.io/20213-yue-fu-xi-bi-ji/"},{"title":"面向对象中的继承","content":"面向对象中的继承 在js中常常提到面向对象，面试时候也会经常问到继承，也常常听到一句话：面向对象编程。 本篇文章主要讲解的是继承。认真话10分钟看完，自己画一画关系图，相信可以轻松掌握，再也不怕面试中被问到。 面向对象的特点 封装(Encapsulation): 把相关的信息（无论数据或方法）存储在对象中的能力 继承(Inheritance): 由另一个类（或多个类）得来类的属性和方法的能力 多态(Polymorphism): 编写能以多种方法运行的函数或方法的能力 继承 如果你对原型、原型链理解不是特别深刻的话，可以先看一下原型、原型链相关文章，只有理解了原型和原型链相关知识，你才可以很好的理解继承。 原型和原型链可以看我之前的文章：《彻底理解原型和原型链》 继承的几种实现方式 这里主要用es5去实现继承，因为es6有继承相关的语法糖，这里就不展示了。 借助构造函数实现继承 先上代码： function Parent1(){ this.name='Parent1' }; function Child1(){ Parent1.call(this);//apply this.type='Child1' } console.log(new Child1) 打印结果 上面我们借助构造函数通过call apply改变指向实现继承，但这种继承方式有一个缺点：继承不了父类原型对象上的属性，只能继承构造函数内的属性。 验证一下我们的结论： function Parent1(){ this.name='Parent1' }; Parent1.prototype.say=function(){ console.log(111) } function Child1(){ Parent1.call(this);//apply this.type='Child1' } console.log(new Child1) 打印结果 可以看出，原型对象上say方法并没有被继承过来，只能继承构造函数内的一些属性。 借助原型链实现继承 还是先上代码： function parent2(){ this.name='parent2', this.play=[1,2,3,4] } function Child2(){ this.type='Child2' } Child2.prototype=new parent2() console.log(new Child2) //验证关系 console.log(new Child2().__proto__==Child2.prototype) 输出结果： 但它还是有缺点，实例出来的是共用的，直接上代码演示一下： //接上面代码～ var s1=new Child2() var s2=new Child2() s1.play.push(5) console.log(s1.play,s2.play) //他们俩是公用的 console.log(s1.__proto__===s2.__proto__) 打印结果： 组合继承(借鉴上面两个的优点) 上面两个方法虽说可以实现，但是还是有很大缺点的，下面看一下组合继承实现，先上代码： function Parent3(){ this.name='Parent3', this.play=[1,2,3] } function Child3(){ Parent3.call(this) this.type='Child3' } Child3.prototype=new Parent3() let s3=new Child3() let s4=new Child3() s3.play.push(4) console.log(s3.play) console.log(s4.play) 打印一下结果： 可以看到，这种实例出来的原型是不会共用的，但它还是有个缺点，在继承时候执行了多次父类（ Parent3.call(this)和Child3.prototype=new Parent3()），显然还不够优秀，我们可以改造一下： function Parent4(){ this.name='Parent4', this.play=[1,2,3] } function Child4(){ Parent3.call(this) this.type='Child3' } Child4.prototype=Parent4.prototype let s5=new Child4() let s6=new Child4() s5.play.push(5) console.log(s5.play) console.log(s6.play) console.log(s5 instanceof Child4,s5 instanceof Parent4) console.log(s5.constructor) 输出结果： 我们虽然解决了父类构造函数执行两次的问题，但我们又迎来了新的问题：s5.constructor输出结果为Parent4，这显然是不行的，因为constructor指向应该是Child4。instanceof也判断不了是来自于谁。那我们还得进行一番改造： function Parent5(){ this.name='parent2', this.play=[1,2,3,4] } function Child5(){ Parent3.call(this) this.type='Child5' } Child5.prototype=Object.create(Parent5.prototype) //__proto__ Child5.prototype.constructor=Child5 console.log(new Child5) var s7=new Child5(); console.log(s7 instanceof Child5,s7 instanceof Parent5) console.log(s7.constructor) 执行结果： 上面通过手动给Child5的constructor赋值，这样就可以通过constructor来看是由哪个函数实例出来的。 结尾 理解继承，还是需要去理解原型和原型链的知识，这块知识在JavaScript中是非常难理解的，学习过程中，可以画一下他们的关系图，以及看一下console.log信息中的**proto**来辅助理解。如果对你有帮助，记得 关注 + 点赞+收藏。 ","link":"https://lonjinup.github.io/jsjc/"},{"title":" 异步编程方案之Promise","content":" Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 为什么需要Promise 我们之前写代码，可能会出现函数嵌套函数，如果多个嵌套，结构就会很乱，也不容易维护，于是Promise就出现了。 什么是Promise 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise的特点 对象的状态不受外界影响，它有三种状态，pending(进行中)、fulfilled(已成功)、rejected(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。它的状态可以从pending变为fulfilled，或者从pending变为rejected。 Promise的基本用法 首先，我们创建一个Promise const testPormise=new Promise((resovle,reject)=&gt;{ console.log(&quot;hi,Pormise&quot;); }); //输出hi,Pormise 上面代码，我们创建了一个Promise，它会立即执行，输出hi,Pormise。下面我们改变一下它的状态: const testPormise=new Promise((resovle,reject)=&gt;{ console.log(&quot;hi,Pormise&quot;); let test=true; if(test){ resovle('成功～') }else{ reject(&quot;失败了&quot;) } }); testPormise.then((res)=&gt;{ console.log(res) }).catch((erro)=&gt;{ console.log(erro) }) //输出：成功～ 我们在内部加了一个判断，当test为true时候，即改变当前状态为成功，此时会走进then方法，且会也会把参数接收过来，此时就会打印出成功。如果改变test，则调用reject，这时候就可以用catch捕获到失败状态。 Promise中finally方法 下面再看一下Promise中的finally方法，这个方法代表无论成功和失败都会执行： const testPormise = new Promise((resovle, reject) =&gt; { console.log(&quot;hi,Pormise&quot;); let test = true; if (test) { resovle('成功～') } else { reject(&quot;失败了&quot;) } }); testPormise.then((res) =&gt; { console.log(res) }).catch((erro) =&gt; { console.log(erro) }).finally(() =&gt; { console.log('执行了finally') }) //输出 成功～ //输出 执行了finally finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 Promise中all方法 all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const test1=new Promise((resovle,reject)=&gt;{ resovle() }); const test2=new Promise((resovle,reject)=&gt;{ resovle() }) const test3=new Promise((resovle,reject)=&gt;{ resovle() }) const promiseAll=Promise.all([test1,test2,test3]) .then(()=&gt;{ console.log('都成功') }) .catch(()=&gt;{ console.log('有失败') }) //输出 都成功 上面代码创建了3个Promise,他们三个的状态都为fufilled,才会返回fulfilled，否则返回rejected。上面代码如果有一个调用了reject，就会进入catch，输出：有失败 Promise中race方法 race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 const test1=new Promise((resovle,reject)=&gt;{ setTimeout(()=&gt;{ resovle('test1') },500) }); const test2=new Promise((resovle,reject)=&gt;{ setTimeout(()=&gt;{ resovle('test2') },1000) }) const test3=new Promise((resovle,reject)=&gt;{ setTimeout(()=&gt;{ resovle('test3') },400) }) const promiseAll=Promise.race([test1,test2,test3],()=&gt;{ }) .then((res)=&gt;{ console.log(res) }) .catch((res)=&gt;{ console.log(res) }) //输出:test3 与all方法不同的是，如果其中有一个实例率先改变了状态，promiseAll的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数，所以上面代码会输出test3。 ","link":"https://lonjinup.github.io/promise/"},{"title":"彻底理解原型 原型链","content":" 原型和原型链也是经常被面试问到的问题，其实原型，原型链涉及问题较多，本文也延展了几个面试中常问的知识点，文章不长，耐心看完肯定会有收获。 创建对象的几种方法 字面量创建 var n={name:1}; var n2=new Object({name:1}); 构造函数创建 var M=function(){ this.name=1 }; var n=new M() Object.create创建 var P={name:1}; var n=Object.create(P) 打印一下结果 其他创建对象的方法就不一一列举了，有兴趣的可参考《创建对象的几种方式》 原型、构造函数、实例、原型链 先看图 再上代码： //字面量创建 var o1={name:'tom'} var o2=new Object({name:'bob'}); //构造函数 var M=function(name){ this.name=name } var o3=new M('tom'); //object.create var p={name:'tom'}; var o4=Object.create(p) 任何一个函数，只要被new了以后，就是构造函数，而new出来的被称之为实例。任何函数都可以当作构造函数。 函数中都有一个prototype属性，申明一个函数时候就会有个prototype属性，这个属性会初始化一个空对象，也就是原型对象。 原型对象中会有一个构造器:constructor，它默认会指向你申明的那个函数。结合上面写的创建对象的例子以及结合关系图验证一下： 可以看到结果：M.prototype.constructor==M结果为true,也就验证了上面关系图。 再次验证一下实例与他们的关系： 原型对象存在的作用 先上例子 function Person(name,age){ this.name=name; this.age=age; this.eat=function(){ console.log(age+&quot;岁的&quot;+name+&quot;在吃饭&quot;) } }; let Tom=new Person(&quot;Tom&quot;,24); let Bob=new Person(&quot;Tom&quot;,24); console.log(Tom.eat===Bob.eat); //flase 可以看到对于同一个函数，new出来的实例，都会开出新的一块堆区,所以例子中Tom和Bob的eat是不同的。 虽然拥有自己的的东西(比如房子，车子)是很好的，但它也有不好的地方，毕竟一共就那么大的地方(内存)，你要 一直建立房子，会导致地方不足(内存不足)。 所以要想个方法，建立共享库的的对象(例如把楼房建高),这样就可以在需要的时候调用一个类似共享库的对象(社区)，让实例能沿着某个线索找到它的归处。 function Person(name,age){ this.name=name; this.age=age; }; // 通过构造函数的 Person 的 prototype 属性找到 Person 的原型对象 Person.prototype.eat=function(){ console.log(&quot;吃饭&quot;) }; let Tom=new Person(&quot;Tom&quot;,24); let Bob=new Person(&quot;Tom&quot;,24); console.log(Tom.eat===Bob.eat); //true 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的镜头就是Object.prototype instanceof的原理 instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype console.log([] instanceof Array); // true console.log(function(){} instanceof Function); // true console.log({} instanceof Object); // true new运算符中都干了什么 创建一个简单空对象 链接该对象到另一个对象（原型链） 将步骤1新创建的对象作为this的上下文 如果该函数没有返回对象，则返回this 如果return则返回return的值 var new2=function(func){ var o=Object.create(func.prototype); var k=func.call(o); if(typeof k =='object'){ return k }else{ return o } } 总结 如有错误，欢迎指正，如果对你有帮助，记得点赞收藏！ ","link":"https://lonjinup.github.io/yxl/"},{"title":"JavaScript中的event loop和宏任务、微任务","content":"背景 “JavaScript 是单线程、异步、非阻塞、解释型脚本语言” 之前看到这句话会觉得很懵，不太懂是什么意思，抽空复习时候看了一下js的执行机制，这时候对这句话有了一些了解。JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。 js遇到异步是如何执行的 大家都知道js中setTimeout是异步的，看下面代码执行顺序： //1 console.log(1) //2 setTimeout(() =&gt; { console.log(2) }, 1000); //3 console.log(3) 首先js会输出1，然后遇到setTimeout，这时候js不会立即执行，而是发起一个异步，然后接着走到第三步，输出3，这时候执行栈为空，然后会将setTimeout的回调函数压入执行栈进行执行。所以结果为1-&gt;3-&gt;2 继续看代码： console.log(1) setTimeout(() =&gt; { console.log(2) }, 0); console.log(3) setTimeout(() =&gt; { console.log(4) }, 1000); 还是之前的代码，首先肯定会输出1，然后遇到setTimeout，注册函数，接着会输出3，然后又遇到一个setTimeout，注册函数，这时候执行栈已经没有任务，事件触发线程会从消息队列中取出刚才加入队列的函数进行执行，此时会输出2，然后执行栈又为空，这时候事件触发线程又会去消息队列中取出一个函数进行执行，此时会输出4。这就是Event-Loop。 微任务 都知道Pormise是微任务，下面就拿Pormise举例子： console.log(1) setTimeout(() =&gt; { console.log(2) }, 1000); let test=new Pormise((resolve)=&gt;{ console.log(3); resolve(); }) .then(=&gt;console.log(4)) console.log(5) 首先会输出1，然后遇到setTimeout，注册任务接着又遇到Pormise，首先先输出3，然后注册任务，接着会输出5，这时候执行栈没有可执行的，然后会从队列中取，这时候会先取出微任务进行执行，进入到then，输出4，这时候执行栈又为空，这时候继续从队列中取出一条任务，这时候会输出2。 练习 检测一下自己到底有木有掌握 console.log(1) //同步任务A setTimeout( //同步任务B () =&gt; { console.log(2) } //任务B产生的异步宏任务 , 300) new Promise( //同步任务C (resolve) =&gt; { console.log(3); resolve(4); } ) .then( //任务C执行过程中resolve(4)语句产生的异步微任务 (num) =&gt; { console.log(num) } ) setTimeout( //同步任务D ()=&gt; { console.log(5) } //任务D产生的异步宏任务 , 800) //1-3-4-2-5 ","link":"https://lonjinup.github.io/enentloop/"},{"title":"js中防抖与节流","content":" 平时很多应用场景需要用到防抖和节流，面试时候也基本会问到，这里总结一下。 防抖 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 直接上代码 &lt;body&gt; &lt;div id='app'&gt; &lt;button class=&quot;button&quot; @click='clickMe'&gt;clickMe&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //封装防抖 function debounce(fn, wait) { let timer = null; let args = arguments; return function () { if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { fn.apply(this, args) }, wait) } }; var vue = new Vue({ el: &quot;#app&quot;, data: { num: 0 }, methods: { clickMe: debounce(function (e) { var myDate = new Date(); console.log(myDate.toLocaleTimeString()) }, 2000) }, }) &lt;/script&gt; 节流 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 还是直接看代码 &lt;body&gt; &lt;div id='app'&gt; &lt;button class=&quot;button&quot; @click='clickThis'&gt;节流&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //节流 function throttle(fn, wait) { let timer = null return function () { let args = arguments if (!timer) { timer = setTimeout(() =&gt; { timer = null fn.apply(this, args) }, wait) } } } var vue = new Vue({ el: &quot;#app&quot;, data: { num: 0 }, methods: { clickThis: throttle(function () { console.log(&quot;节流&quot;); var myDate = new Date(); console.log(myDate.toLocaleTimeString()) }, 2000) }, }) &lt;/script&gt; 总结 防抖就像游戏中的buff，你吃了bull，开始倒计时，这时候你又吃了一个buff，则重新记时。 节流就是游戏中的技能CD，你按下技能以后，再规定的时间内，你再按也没用，只能能冷却好了再按。 ","link":"https://lonjinup.github.io/jsfdoujieliu/"},{"title":"【ES6】class类","content":"class ES5中创建对象以及继承 function Car(options){ this.title=options.title; }; Car.prototype.drive=function(){ return 'run' }; const car =new Car({title:'BMW'}); console.log(car); console.log(car.drive()); 继承 function Toyota(options){ this.color=options.color; }; const toyota=new Toyota({color:'RED',title:'hello'}); console.log(toyota.title)//undefined 因为title没有定义，所以拿不到,需要借助Call function Toyota(options){ Car.call(this,options) this.color=options.color; }; const toyota=new Toyota({color:'RED',title:'hello'}); console.log(toyota)； 如果想继承上面中drive方法 function Toyota(options){ Car.call(this,options) this.color=options.color; }; Toyota.prototype=Object.create(Car.prototype); Toyota.prototype.constructor=Toyota; const toyota=new Toyota({color:'RED',title:'hello'}); console.log(toyota.drive()); ES6中创建对象以及继承 class Car{ //构造函数 constructor({title}){ this.title=title } drive(){ return 'runing' } }; const car=new Car({title:'bmw'}); console.log(car) 继承 class Toyota{ constructor(e){ this.color=e.color }; }; const toyota=new Toyota({color:&quot;red&quot;,title:'hello'}); console.log(toyota); 但接收不到title class Toyota{ constructor(e){ super(e);//接收器 this.color=e.color }; } const toyota=new Toyota({color:&quot;red&quot;,title:'hello'}); console.log(toyota);//Uncaught SyntaxError: 'super' keyword unexpected here 上面因为因为没有父级，没有告诉它继承于谁 class Toyota extends Car{ constructor(e){ super(e);//接收器 this.color=e.color }; }； const toyota=new Toyota({color:&quot;red&quot;,title:'hello'}); console.log(toyota) ","link":"https://lonjinup.github.io/es6-class-lei/"},{"title":"小程序官方直播插件","content":" 关于直播，可谓是2020年很火爆的话题了，正好赶上肺炎，不能出门，娱乐方式极少，大大推动了直播。 同时最近直播也新闻不断：罗永浩抖音直播带货，直播一姐卖火箭.... 可见今年直播行业的火爆。好多公司都有需求开发小程序直播。 小程序直播 如今直播平台很多，抖音直播，快手直播，虎牙直播，b站直播，各大平台竞争也是很激烈。 短视频也是，今年微信推出了视频号，不过还在内测阶段，小程序也推出了新的直播方案。可见马爸爸也想在直播和短视频行业分一杯羹。毋庸置疑，微信几乎成为了人们必不可少的通讯工具， 有微信的用户基础，小程序直播的优势就展现出来了。 如果公司需求不是特别大，而且工期有限，时间有限，就可以尝试一下微信小程序直播组件，开箱即用，开通要求为接入微信支付，且90天内有一笔交易。这个门槛还是非常低的。 为什么要用小程序直播组件 开发难度低，成本少，见效快：相对于之前推出的小程序直播开发，这次的直播从文档中可以看出，可以说是傻瓜式开发，因为微信已经帮忙处理的绝大部分东西。所以开发和升级周期是非常短的。 裂变快：虽然说现在抖音快手占据了短视频直播半边天，但是微信的流量也不是盖的，毕竟日活跃摆在那里。商家可以策划活动，在朋友圈中展开推广裂变，效果不比其他直播平台差。 我们可以想一下， xx商户，在小程序开启了直播--&gt;直播间抽奖聚集人气（通过转发，分享快速裂变）--&gt;讲解商品，提高成交量。这样下来，流量以及成交量自然会提高。且在自己小程序直播。 直播组件的使用 先放官网文档地址 官方文档 配置直播 直接在app.json中引入插件 &quot;plugins&quot;: { &quot;live-player-plugin&quot;: { &quot;version&quot;: &quot;1.0.4&quot;, // 注意填写该直播组件最新版本号，微信开发者工具调试时可获取最新版本号（复制时请去掉注释） &quot;provider&quot;: &quot;wx2b03c6e691cd7370&quot; // 必须填该直播组件appid，该示例值即为直播组件appid（复制时请去掉注释） } } 进入直播间 live:function(){ let roomId = [直播房间id] // 房间号 let customParams = { path: 'pages/index/index', pid: 1 } // 开发者在直播间页面路径上携带自定义参数（如示例中的path和pid参数），后续可以在分享卡片链接和跳转至商详页时获取，详见【获取自定义参数】、【直播间到商详页面携带参数】章节 this.setData({ roomId, customParams: encodeURIComponent(JSON.stringify(customParams)) }) } 创建直播 问题来了，在哪创建直播间啊？看图即可 首先登录微信小程序后台，找到直播。 创建直播 选择直播形式 填写基本信息 配置直播间样式 直播间样式 好了，一个直播就创建完成了，此时你会得到一个房间号，在自己搭建的小程序后台上传一下房间号，即可观看直播。这种对于单商户平台极其友好，开发也非常省事省力。 添加商品 后台建立商品库，填写相关参数即可。 推流直播 看这篇文章小程序推流配置 其他功能 直播间还可以创建抽奖，优惠券，以及拉黑用户等功能。也可以在后台设置管理员进行管理。 结尾 体验了一下小程序直播组件，还是很不错的，无论推流直播还是用手机进行直播，效果还是很不错的，但是没有办法测试同时在线多少人会造成卡顿，这个微信也好像没有相关文档说明，期待微信后期的说明补充。 ","link":"https://lonjinup.github.io/xcxzb/"},{"title":"【01】React环境搭建以及文件目录介绍","content":" 打算学习一下React，记录一下学习遇到的问题。 搭建环境 环境 安装Node 到 Node官网下载，下载完直接根据提示完成安装。window电脑打开CMD，Mac 电脑打开终端，输入node -v可以查看版本号，说明安装成功了。 node -v React脚手架 打开终端，输入下面命令就开始安装了。 npm install -g create-react-app 如果你是Mac，需要在前面加sudo，然后按提示输入密码进行安装。不然会提示你没有权限。 sudo npm install -g create-react-app 创建我的第一个项目 进入到你想创建项目的文件夹 create-react-app demo01 //用脚手架创建React项目,后面是项目名字 cd demo01 //等创建完成后，进入项目目录 npm start //预览项目，如果能正常打开，说明项目创建成功 创建成功会自动打开浏览器，能正常显示React图标，就说明创建成功了！ 目录讲解 --- README.md (项目说明文件，工作中可以写项目描述，项目说明等) --- package.json (这个文件是webpack配置和项目包管理文件，项目中依赖的第三方包和一些常用命令配置都在这个里边进行配置目前位置，我们不需要改动。) --- package-lock.json (锁定安装时的版本号，并且需要上传到git，以保证其他人再npm install 时大家的依赖能保证一致。) --- gitignore (这个是git的选择性上传的配置文件，比如一会要介绍的node_modules文件夹，就需要配置不上传。) --- node_modules (这个文件夹就是我们项目的依赖包，到目前位置，脚手架已经都给我们下载好了，你不需要单独安装什么。) --- public (公共文件) ------- favicon.ico （网站标签小图标） ------- index.html (模版文件,其中&lt;noscript&gt;&lt;/noscript&gt;标签是容错处理，如果当前JavaScript没有跑通的情况下就会显示里面的内容) ------- manifest.json （移动端配置文件） --- src (开放的源代码，我们平时操作做最多的目录) ------- index.js (项目入口文件) ------- ndex.css （这个是index.js里的CSS文件。） ------- app.js （这个文件相当于一个方法模块，也是一个简单的模块化编程。） ------- serviceWorker.js （这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。） ","link":"https://lonjinup.github.io/01-react/"},{"title":"【ES6】解构(数组-对象)","content":"解构 主要应用于两种类型，一种是数组，一种是对象。 对象解构 看一个例子,如果要取到对象中的某个值，我们需要这样操作 var expense={ type:'es6', amount:'45' }; var type=expense.type; var amount=expense.amount; console.log(type,amount); //es6,45 使用解构的话，我们可以这么写 var expense={ type:'es6', amount:'45' }; const {type,amount}=expense; console.log(type,amount);//es6,45 如果对象中没有该属性，则会返回 var expense={ type:'es6', amount:'45' }; const {type,amount,abc}=expense; console.log(type,amount,abc);//es6 45 undefined 小案例 获取对象中定义的某些值 ES5实现 var saveFiled={ extension:'jpg', name:'es6', size:'1024' }; function fileSammary(file) { return `${file.name}.${file.extension}的大小是${file.size}` }; console.log(fileSammary(saveFiled));//es6.jpg的大小是1024 ES6实现 var saveFiled={ extension:'jpg', name:'es6', size:'1024' }; function fileSammary({name,extension,size}){ return `${name}.${extension}的大小是${size}` }; console.log(fileSammary(saveFiled));//es6.jpg的大小是1024 数组的解构 直接上例子，获取数组的值 const names=['tom','bob','nike']; const [name1,name2,name3]=names; console.log(name1,name2,name3)//tom bob nike 如果想要获取数组中的长度，直接在花括号中输入 length； const names=['tom','bob','nike']; const {length}=names; console.log(length)//3 展开运算符进行解构 const names=['tom','bob','nike']; const [name,...rest]=names; console.log(name) //tom; console.log(rest) // [&quot;bob&quot;, &quot;nike&quot;] 还可以这么操作 let a,b; [a,b]=[100,200]; console.log(a,b); 对象数组解构 获取对象数组中的某个属性 ES5 const people=[ {names:&quot;tom&quot;,age:20}, {names:&quot;bob&quot;,age:10}, {names:&quot;nike&quot;,age:24}, ]; var age=people[0].age; console.log(age);//20 ES6 const people=[ {names:&quot;tom&quot;,age:20}, {names:&quot;bob&quot;,age:10}, {names:&quot;nike&quot;,age:24}, ]; //二次解构 const [{age}]=people; console.log(age)//20 使用场景 将数组转化为对象 const point=[ [4,5], [10,1], [0,10] ]; //期望数据格式 // [ // {x:4,y:5}, // {x:10,y:1}, // {x:0,y:10} // ] let newPoint=point.map(pair=&gt;{ const x=pair[0]; const y=pair[1]; return {x,y} }) console.log(newPoint) 还可以进行优化一下 let newPoint=point.map(pair=&gt;{ const [x,y]=pair; return {x,y} }); console.log(newPoint) 再一步优化 let newPoint=point.map(([x,y])=&gt;{ return {x:x,y:y} }) console.log(newPoint); ","link":"https://lonjinup.github.io/es6-jie-gou-shu-zu-dui-xiang/"},{"title":"【ES6】展开运算符","content":"展开运算符 普通写法与展开运算符 普通数组相加 function addNumbers(numbers) { return numbers.reduce((sum,number)=&gt;{ return sum+number },0) }; const numbers=[1,2,3,4,5]; console.log(addNumbers(numbers)) //15 如果传入的是单个数字 function addNumbers(a,b,c,d,e) { let numbers=[a,b,c,d,e]; return numbers.reduce((sum,number)=&gt;{ return sum+number },0) }; console.log(addNumbers(1,2,3,4,5)) //15 展开运算符 function addNumbers(...numbers) { return numbers.reduce((sum,number)=&gt;{ return sum+number },0) }; console.log(addNumbers(1,2,3,4,5)) //15 展开运算符的应用 可替代数组push等操作 var defaultColor=['red','green']; var favoriteColor=['orange','yellow']; defaultColor=defaultColor.concat(favoriteColor); console.log(defaultColor); //[&quot;red&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;yellow&quot;] //同理也可以直接传两个数组 console.log([...defaultColor,...favoriteColor]) //之前的数组也可以合并 var fallcolors=['fire red','fall orange']; console.log(['blue',...fallcolors,...defaultColor,...favoriteColor]) 小案例 判断某个值是否在某个数组中，如果没有，就添加进去 function shopList(...items) { if(items.indexOf('milk')&lt;0){ return ['milk',...items] } }; console.log(shopList('orange','bread','eggs')) ","link":"https://lonjinup.github.io/es6-zhan-kai-yun-suan-fu/"},{"title":"【ES6系列】函数参数默认值","content":"函数参数默认值 优点：优化代码 案例1 比如要写一个ajax方法，此时我定义了两个参数，一个url，一个methods，如果我只传递了url，此时是会报错的。 function ajaxRequest(url,methods) { }; console.log(ajaxRequest(&quot;google.com&quot;)) //undefined 如果不想有报错，此时就得做一些处理。 function ajaxRequest(url,methods) { if(!methods){ methods='GET' } return methods }; console.log(ajaxRequest(&quot;google.com&quot;)) console.log(ajaxRequest(&quot;google.com&quot;,'post')) 而在ES6中，则可以定义函数默认值,如果没有传，直接会使用默认值。 function ajaxRequest(url,methods='GET') { return methods }; console.log(ajaxRequest(&quot;google.com&quot;)) console.log(ajaxRequest(&quot;google.com&quot;,'post')) ","link":"https://lonjinup.github.io/es6-xi-lie-han-shu-can-shu-mo-ren-zhi/"},{"title":"【ES6系列】增强对象字面量","content":"增强对象字面量 解决的问题：缩减代码，使代码具有可读性。 直接看代码便可理解。 ES5 //创建对象 new Object(); //{} //创建数组 new Array(); //[] function createBookSop(inventory) { return{ inventory:inventory, inventoryValue:function () { return this.inventory.reduce((total,book)=&gt;total+book.price,0) }, priceForName:function (title) { return this.inventory.find(book=&gt;book.title===title).price } } }; const inventory=[ {title:'vue',price:12}, {title:'node',price:15}, ]; const bookSop=createBookSop(inventory) console.log(bookSop.inventoryValue()) console.log(bookSop.priceForName('node')) ES6 //创建对象 new Object(); //{} //创建数组 new Array(); //[] function createBookSop(inventory) { return{ inventory, inventoryValue() { return this.inventory.reduce((total,book)=&gt;total+book.price,0) }, priceForName(title) { return this.inventory.find(book=&gt;book.title===title).price } } }; const inventory=[ {title:'vue',price:12}, {title:'node',price:15}, ]; const bookSop=createBookSop(inventory); console.log(bookSop.inventoryValue()); console.log(bookSop.priceForName('node')); 使用案例 const url='https://www.baidu.com'; const data={color:'red'}; //es5书写 function saveFile(url,data) { $.ajax({ method:&quot;post&quot;, url:url, data:data }) }; //es6书写 function saveFile(url,data) { $.ajax({ url, data, method:&quot;post&quot;, }) }; ","link":"https://lonjinup.github.io/es6-xi-lie-zeng-qiang-dui-xiang-zi-mian-liang/"},{"title":"【ES6系列】箭头函数","content":"箭头函数 解决问题： 1.缩减代码 2.改变 this 指向 普通写法vs箭头函数vs //普通写法 const number=function(number){ return number*2 }; //箭头函数 const number2=(number)=&gt;{ return number*2 }; console.log(number2(2)) //--&gt;4 箭头函数升级版本 升级版本:必须写到一行，return 可以省略。 const number3=(number)=&gt; number*2; console.log(number2(2)) //--&gt;4 还可以继续简化(单个参数量) const number3=number=&gt; number*2; console.log(number2(2)) //--&gt;4 //或者可以这样 const number3=(number=&gt; number*2); 多个参数：参数必须加括号 const number5=(number,number2)=&gt; number+number2 console.log(number5(2,1)) //--&gt; 3 多条语句：后面必须加括号 const number5=(number,number2)=&gt;{ sum=number+number2; return sum } console.log(number5(2,1)) //--&gt; 3 改变this指向 // 改变this指向 const team={ name:['tom','bob'], teamName:'ES6', teamSummary:function(){ return this.name.map(function (items) { //当前this已经没有明确指向了 return `${items}属于${this.teamName}分类下` }) } }; console.log(team.teamSummary())//this.teamName显示undefined; 如果想显示teamName //方法1(提前声明一个this) const team={ name:['tom','bob'], teamName:'ES6', teamSummary:function(){ let that=this;//声明一个this return this.name.map(function (items) { return `${items}属于${that.teamName}分类下` }) } }; console.log(team.teamSummary())//正常显示 //方法2（bind()方法） const team2={ name:['tom','bob'], teamName:'ES6', teamSummary:function(){ return this.name.map(function (items) { return `${items}属于${that.teamName}分类下` }.bind(this))//把this绑定给函数 } }; //方法3（箭头函数） const team={ name:['tom','bob'], teamName:'ES6', teamSummary:function(){ return this.name.map((items)=&gt; { //当前this已经没有明确指向了,如果要明确，就得在上一个return之前先声明一个this； return `${items}属于${this.teamName}分类下` }) } }; ","link":"https://lonjinup.github.io/es6-zhong-jian-tou-han-shu/"},{"title":"【ES6系列】模板字符串","content":"ES6中模板字符串 ES5中模板字符串拼接 如果有换行就需要通过 + 号拼接，非常不利于书写。 let template='&lt;h1&gt;hellow world&lt;/h1&gt;'+ '&lt;p&gt;这是es5语法&lt;/p&gt;' document.getElementById(&quot;app&quot;).innerHTML = template; ES6中模板字符串 首尾使用 ` ` 符号，中间内容可随意换行，书写方便。 let template=`&lt;h1&gt;hellow world&lt;/h1&gt; &lt;p&gt;这是es6语法&lt;/p&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; ` document.getElementById(&quot;app&quot;).innerHTML = template; 传递变量：${} let name='LonJin'; let template=`&lt;h1&gt;hellow ${name}&lt;/h1&gt; &lt;p&gt;这是es6语法&lt;/p&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; ` document.getElementById(&quot;app&quot;).innerHTML = template; 执行方法：${} function makeUppercase(word){ return word.toUpperCase() } let name='LonJin'; let template=`&lt;h1&gt;${makeUppercase(&quot;hello&quot;)} ${name}&lt;/h1&gt; &lt;p&gt;这是es6语法&lt;/p&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; ` document.getElementById(&quot;app&quot;).innerHTML = template; ","link":"https://lonjinup.github.io/es6-zhong-mo-ban-zi-fu-chuan/"},{"title":"【ES6系列】let,const与var的区别","content":"var,let ,const的区别 var 全局变量 function textVar(){ var a=30; if(true){ var a=50; console.log(a);//50 }; console.log(a);//50 找离他最近的a }; let 有作用域的概念 function textLet(){ let a=30; if(true){ let a=50;//有作用域的概念 console.log(a);//50 }; console.log(a);//30 }; textLet(); const 一但申明，不可修改,他是一个常量。 const x=10; x=100; console.log(x);//Uncaught TypeError: Assignment to constant variable. 定义数组 const colors=[]; colors.push('red'); colors.push('green'); console.log(colors) ","link":"https://lonjinup.github.io/letconst-yu-var-de-qu-bie/"},{"title":"js中常用数组方法","content":"数组方法 数组方法 数组方法有 forEach, map , filter, find, every, some, reduce. forEach //ES5遍历 var colors=['red','green','yellow']; for(var i=0;i&lt;colors.length;i++){ console.log(colors[i]) } //ES6遍历 colors.forEach(function(color){ console.log(color) }) 迭代器函数首先把数组每个值依次循环，直到最后一个。forEach是通过回调函数来提供参数的。回调函数也是一种闭包，所以每个回调函数都有自己的私有作用域，互不影响，内部变量不会及时释放。如果在闭包中return的话，也只是在当前函数中返回，而且在forEach中其他闭包函数中还是存在的，所以会出现return中是没办法结束循环的。 let arr=[1,2,3]; arr.forEach(function(value,key,arr){ console.log(value); //--&gt;1,2,3 //console.log(key); //--&gt;0,1,2 //console.log(arr); //--&gt;arr }); 可以看出他在函数中有三个参数，value , key, arr. 其中函数也可以写在外部 let arr=[1,2,3]; function arr(value,key,arr){ console.log(value); //--&gt;1,2,3 //console.log(key); //--&gt;0,1,2 //console.log(arr); //--&gt;arr } arr.forEach(arr) map 场景1 假定有一个数值数组(A),将A数组中的值以双倍的形式放到B数组中 var numbers=[1,2,3]; var numbersA=[]; // ES5 for (var i=0; i&lt;numbers.length; i++){ numbersA.push(numbers[i]*2) }; console.log(numbersA); //ES6 map var numbersA=numbers.map(function(number){ return number*2 }); console.log(numbersA); //forEach numbersA.forEach(function(number){ console.log(number) }) 场景2 假定有一个对象数组（A），将A数组中对像某个属性的值存储到B数组中 var cars=[ {model:&quot;buick&quot;,price:&quot;cheap&quot;}, {model:&quot;bmw&quot;,price:&quot;expensive&quot;}, ]; var prices=cars.map(function(car){ return cars.price }); console.log(prices) 原理：把数组中的值放入迭代器函数中，然后return结果出来，map需要返回值，如果不给return，默认返回的是undefined。map返回的是新数组。 filter 场景1 假定有一个对象数组（A），获取数组中指定类型的对象放到B数组中 let products=[ {name:'cucumber',type:'vegetable'}, {name:'banana',type:'fruit'}, {name:'celery',type:'vegetable'}, {name:'orange',type:'fruit'}, ]; //ES5 let filteredProducts=[]; for (var i=0;i&lt;products.length;i++){ if(products[i].type==&quot;fruit&quot;){ filteredProducts.push(products[i]) } }; console.log(filteredProducts); //ES6 let filter2=products.filter(function(product){ return product.type==&quot;vegetable&quot; }); 原理：把数组中的值放入迭代器函数中，如果与匹配的内容相等，returntrue,把不匹配的过滤出去。 场景2 假定有一个对象数组A，过滤多个满足条件对象 let product2=[ {name:'cucumber',type:'vegetable',price:5}, {name:'banana',type:'fruit',price:5}, {name:'celery',type:'vegetable',price:12}, {name:'orange',type:'fruit',price:5}, ]; let newProduct=product2.filter(function(product){ return product.type===&quot;vegetable&quot; &amp;&amp; product.price &gt; 0 &amp;&amp; product.price &lt; 10 }); console.log(newProduct); 场景3 假定有两个数组AB，根据A中id值，过滤掉B数组中不符合的数据。 let post={id:4,title:&quot;javascript&quot;}; let comments=[ {postId:4,content:&quot;vue&quot;}, {postId:3,content:&quot;vue2.0&quot;}, {postId:2,content:&quot;vue3.0&quot;}, {postId:2,content:&quot;Node.js&quot;} ]; function commentForPost(post,comments){ return comments.filter(function(comment){ return comment.postId==post.id }); }; console.log(commentForPost(post,comments)); find 场景1 假定有一个对象数组A，找到符合条件的对象 let users=[ {name:&quot;jill&quot;}, {name:&quot;tome&quot;}, {name:&quot;bill&quot;} ]; let user; //ES5 for(var i=0;i&lt;users.length;i++){ if(users[i].name==&quot;tome&quot;){ user=users[i]; break;//找到不会执行后面的 } }; //ES6 user=users.find(function(user){ return user.name==&quot;tome&quot;; }) 场景2 假定有一个对象数组A，根据指定对象的条件找到数组中符合条件的对象 let posts=[ {id:3,title:&quot;node.js&quot;}, {id:4,title:&quot;vue.js&quot;} ]; let comment={id:3,content:&quot;hello word&quot;}; function postForComment(posts,comment){ return posts.find(function(post){ return post.id==comment.id; }) }; every (一假即假 ) some (一真即真) 场景1 计算对象数组中每个电脑的操作系统是否可用，大于16位操作系统表示可用，否则不可用 let computers=[ {name:&quot;Apple&quot;,ram:16}, {name:&quot;IBM&quot;,ram:4}, {name:&quot;Acer&quot;,ram:32}, ]; var everyComputers=true; var someComputers=false; //ES5 for(var i=0;i&lt;computers.length;i++){ var computer=computers[i]; console.log(computer.ram) if(computer.ram &lt; 16){ everyComputers=false }else{ someComputers=true } }; //ES6 var every=computers.every(function(computer){ return computer.ram&gt;16 }); console.log(every); var some=computers.some(function(computer){ return computer.ram&gt;16 }); console.log(some); 场景2 假定有一个注册页面，判断所有input内容长度是否大于0 function Filed(value){ this.value=value; }; Filed.prototype.validate=function(){ return this.value.length&gt;0; } var username=new Filed(&quot;&quot;); var telephone=new Filed(&quot;18282828282828&quot;); var email=new Filed(&quot;LonJin_up@163.com&quot;); console.log(username.validate()); console.log(telephone.validate()); var fields=[username,telephone,email]; var formIsValid=fields.every(function(field){ return field.validate() }); if(formIsValid){ console.log(&quot;注册成功&quot;) }else{ console.log(&quot;注册失败&quot;) } reduce 场景1，计算数组中所有值的总和 //ES5 var numbers=[10,20,30]; var sum=0; for (var i=0; i &lt; numbers.length; i++){ sum+=numbers[i]; } console.log(sum); //ES6 var sumValue=numbers.reduce(function(sum2,number2){ console.log(sum2);//第一个参数需要初始化，所以打印出来第一个是0 return sum2+number2 },0); console.log(sumValue); 场景2 将数组中对象的某个属性抽离到另外一个数组中 var primaryColor=[ {color:'red'}, {color:'yellow'}, {color:'blue'}, ]; var color=primaryColor.reduce(function(previous,primaryColor){ previous.push(primaryColor.color); return previous },[]); console.log(color) 场景3 判断字符串中括号是否对称 function balanceParens(string){ return !string.split(&quot;&quot;).reduce(function(previous,char){ if(previous&lt;0){ return previous } if (char==&quot;(&quot;){ return ++previous } if (char==&quot;)&quot;){ return --previous } return previous },0); } console.log(balanceParens(&quot;(((())))&quot;)) ","link":"https://lonjinup.github.io/es6-shu-zu-zhong-de-fang-fa/"},{"title":"搭建shadowsocks服务","content":"shadowsocks 之前一直是公司后端用公司服务器搭建的，网速慢的要死，准备买个星域的，但是网站老打不开，还是自己搭一个吧，价格也不贵，一个月折合人民币￥25，网速也不慢。 一、购买服务器 国外的服务器比较多，像我们常见的就有搬瓦工，vultr，linode 亚马逊等，这里我选择cloudcone。 注册 这里选择cloudcone进行账号注册。 充值 这里支持支付宝充值，最低充值金额为 $5，找到充值入口 输入金额支付宝支付 购买 首页点击新建 按图上配置即可，只需$3.71。 这时候购买完毕就可以开始搭建啦，服务器IP地址和密码等信息会下发到邮箱。 二、搭建 准备工具 Xshell6，百度网盘下载。提取码y4tq shadowsocks客户端 Windows客户端 Mac客户端 Android客户端 iOS可以用美区ID下载Potatso Lite，美国账号可以去万能的tb购买。 服务器 连接服务器 安装好Xshell，通过ip地址和密码连接服务器。这里就不截图了。 安装python-pip 安装 python-pip yum -y install python-pip 如果提示No package python-pip available.Error: Nothing to do因为没有此rpm包，此包包含在pel源里面,执行如下代码: rpm -ivh http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm 安装成功后会提示Complete! 之后清除一下缓存 yum clean al 安装shadowsocks pip install shadowsocks 配置信息 新建文件 vim /etc/shadowsocks.json 输入配置信息 { &quot;server&quot;: &quot;服务器IP&quot;, &quot;port_password&quot;: { &quot;端口&quot;: &quot;密码&quot; }, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;: 1080, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot; } 编辑好后esc退出输入:wq!保存。 运行 要在前台运行: ssserver -c /etc/shadowsocks.json 要在后台运行： ssserver -c /etc/shadowsocks.json -d start ssserver -c /etc/shadowsocks.json -d stop 三.客户端连接 打开客户端，输入ip、端口、选择加盟方式、点击确定即可连接，快试试能不能打开Google吧！ 结尾 如果你觉得太麻烦，还可以直接使用付费的，每月12块钱，速度还可以。点击注册👉新界 ","link":"https://lonjinup.github.io/shadowsocks/"},{"title":"JavaScript中this指向以及改变this指向","content":"关于this指向 首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象（这句话有些问题，后面会解释为什么会有问题，虽然网上大部分的文章都是这样说的，虽然在很多情况下那样去理解不会出什么问题，但是实际上那样理解是不准确的，所以在你理解this的时候会有种琢磨不透的感觉） 例子1 function name(){ var a=&quot;A&quot;; console.log(this.a);//undefined console.log(this);//Window }; name(); 按照上面所说的this始终指向的是调用它的对象，这里的函数name实际上是被Window对象所调出来的。所以this.a=undefined; function name(){ var a=&quot;A&quot;; alert(this.a);//undefined alert(this);//Window }; name(); 和上面代码一样，alert 也是Window一个属性，也是Window调出来的。 例子2 var n={ name:&quot;LonJin&quot;, fn:function(){ console.log(this.name)//LonJin } }; n.fn(); 这里的this指向的是对象n，因为你调用这个fn是通过n.fn()执行的，那自然指向就是对象n，这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁，一定要搞清楚这个。 其实例子1和例子2说的并不够准确，下面这个例子就可以推翻上面的理论。 例子3 var n={ name:&quot;LonJin&quot;, fn:function(){ console.log(this.name)//LonJin } }; window.n.fn(); 这段代码和上面的那段代码几乎是一样的，但是这里的this为什么不是指向window，如果按照上面的理论，最终this指向的是调用它的对象，这里先说个而外话，window是js中的全局对象，我们创建的变量实际上是给window添加属性，所以这里可以用window.n.fn()。 再来看一段代码 var n={ a:10, b:{ a:12, fn:function(){ console.log(this.a)//12 } } }; n.b.fn(); 这里同样也是对象n点出来的，但是同样this并没有执行它，那你肯定会说我一开始说的那些不就都是错误的吗？其实也不是，只是一开始说的不准确，接下来我将补充一句话，我相信你就可以彻底的理解this的指向的问题。 彻底理解this指向 情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。 情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，例子3可以证明，如果不相信，那么接下来我们继续看几个例子。 var n={ a:10, b:{ // a:12, fn:function(){ console.log(this.a)//undefined } } }; n.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。还有一种特殊的情况，请看例子4。 例子4 var n={ a:10, b:{ a:12, fn:function(){ console.log(this.a)//undefined console.log(this);//window } } }; var j=n.b.fn; j(); 在这里this指向window，这里就又不明白了，其实还是不理解this永远指向最后调用它的对象，也就是看它执行的时候是谁调用的它，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这里和例子3是不一样的，例子3是直接执行了fn。 当this遇到retrun时候 function fn(){ this.user=&quot;LonJin&quot;; return {} }; var a=new fn; console.log(a.user);//underfind 再看一个 function fn(){ this.user=&quot;LonJin&quot;; return function(){ } }; var a=new fn; console.log(a.user);//undefined 继续看 function fn(){ this.user=&quot;LonJin&quot;; return 1 }; var a=new fn; console.log(a.user);//LonJin function fn(){ this.user=&quot;LonJin&quot;; return undefined }; var a=new fn; console.log(a.user);//LonJin 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 function fn(){ this.user=&quot;LonJin&quot;; return null }; var a=new fn; console.log(a.user);//LonJin 补充 在严格版中的默认的this不再是window，而是undefined。 结尾 如果对你有帮助，就赞赏一下吧！ WeChat：ljsw8686 一起学习，一起进步！ ","link":"https://lonjinup.github.io/javascript-zhong-this-zhi-xiang-yi-ji-gai-bian-this-zhi-xiang/"},{"title":"两行代码为网页添加暗黑模式","content":" 自从微信支持暗黑模式以后，很多网站也加了暗黑模式，这个可以利用css的filter即可做到。直接看代码吧！ 实现代码 html{ filter: invert(1) hue-rotate(180deg); } &lt;!-- 逆转图片颜色 --&gt; html img{ filter: invert(1) hue-rotate(180deg); } 如果想深入了解的，可以看一下相关文档 filter详解 基本代码就这么两条，大家可以试一下效果。 ","link":"https://lonjinup.github.io/heiaimoshi/"}]}