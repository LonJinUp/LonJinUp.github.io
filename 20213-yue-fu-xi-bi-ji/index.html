<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>前端复习笔记 | 陇锦</title>

<link rel="shortcut icon" href="https://lonjinup.github.io/favicon.ico?v=1751543015276">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://lonjinup.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            陇锦
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://lonjinup.github.io/aboutme" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1751543015276" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    前端复习笔记
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-03-25 ·
                    </time>
                    
                        <a href="https://lonjinup.github.io/su-x11Ukj/" class="post-tags">
                            # JavaScript
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="金三银四-2021年前端面试笔记">金三银四 2021年前端面试笔记</h1>
<blockquote>
<p>又到了找工作的黄金时间，3-4月份，跳槽是每个人的职业生涯中都要经历的过程，笔者最近也是复习了一波，整理了一下面试中关于<strong>javascript</strong>和<strong>vue</strong>的一些问题。看到本文的你如果感觉对你有帮助，不如素质三连，码字不易，感谢您的支持！</p>
</blockquote>
<h2 id="javascript">JavaScript</h2>
<h3 id="数据类型">数据类型</h3>
<blockquote>
<p>介绍一下js中的数据类型以及值是如何存储的</p>
</blockquote>
<ul>
<li>
<p>JavaScript中一共有8种数据类型，其中基本数据类型有：Null、Undefined、Boolean、String、Number、Bigint、Symbol。<br>
还有一种数据类型<strong>object</strong>：里面包含<strong>function</strong>、<strong>Array</strong>、<strong>Date</strong>等。</p>
</li>
<li>
<p>基本数据类型保存在栈区中，占据空间小、大小固定。<br>
引用数据类型保存在栈区和堆区，占据空间大，且大小不固定。引用数据类型在栈区中存放了指针，指针指向堆区的实际地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
</li>
</ul>
<h3 id="js中数据类型判断">js中数据类型判断</h3>
<blockquote>
<p>说一说在js中判断数据类型的方法</p>
</blockquote>
<h4 id="typeof">typeof</h4>
<ul>
<li>typeof可以判断原始数据类型，除了null之外：</li>
</ul>
<pre><code class="language-js">    console.log(typeof 2) //number
    console.log(typeof 'hello') //string
    console.log(typeof null) //object
    console.log(typeof true)//boolean
    console.log(typeof undefined) //undefined
    console.log(typeof []) //object
</code></pre>
<ul>
<li>因为因为特殊值null被认为是一个对空对象的引用</li>
</ul>
<h2 id="instanceof">instanceof</h2>
<ul>
<li><strong>instanceof</strong>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的<strong>prototype</strong>:</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/09/17/wWAKt1.png" alt="wWAKt1.png" loading="lazy"></figure>
<pre><code class="language-js">    console.log([] instanceof Array) //true
    console.log({} instanceof Object)//true
    console.log(function(){} instanceof Function)//true
    console.log(1 instanceof Number)//false
</code></pre>
<h3 id="constructor">constructor</h3>
<ul>
<li><strong>constructor</strong>主要是利用原型上的<strong>prototype.constructor</strong>指向实例的构造函数来进行判断的</li>
</ul>
<pre><code class="language-ts">    console.log((1).constructor === Number) //true
    console.log('1'.constructor===String)//true
    console.log((function(){}).constructor===Function) //true
    console.log([].constructor===Array) //true
    console.log(({}).constructor===Object) //true
</code></pre>
<ul>
<li>但constructor有个特点就是：如果我创建了一个对象，我们再去修改它的原型，就变得不那么可靠：</li>
</ul>
<pre><code class="language-ts">    function Func(){}

    Func.prototype=new Array();

    const f=new Func()

    console.log(f.constructor===Function)//false
</code></pre>
<h3 id="objectprototypetostringcall">Object.prototype.toString.call</h3>
<ul>
<li>使用 Object 对象的原型方法<strong>toString</strong>,返回值是[object 类型]字符串,该方法基本上能判断所有的数据类型.</li>
</ul>
<pre><code class="language-js">    var toString = Object.prototype.toString;
    console.log(toString.call(2)) //[object Number]
    console.log(toString.call(true)) //[object Boolean]
    console.log(toString.call(function(){})) //[object Function]
</code></pre>
<h3 id="作用域和作用域链">作用域和作用域链</h3>
<blockquote>
<p>谈一谈你对作用域、作用域链的理解。</p>
</blockquote>
<ul>
<li>
<p>作用域：作用域就是定义变量的区域，它有一套访问变量的规则，根据这套规则来管理浏览器引擎如何在当前作用域和嵌套作用域中中根据变量（标识符）进行变量查找。</p>
</li>
<li>
<p>作用域链：作用域链保证对执行环境有权访问所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境中的变量和函数。</p>
</li>
<li>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找</p>
</li>
</ul>
<h3 id="this">this</h3>
<blockquote>
<p>谈一谈你对this的理解，以及在各种环境下的this</p>
</blockquote>
<ul>
<li>
<p>在浏览器里，在全局范围内this指向window对象</p>
</li>
<li>
<p>在函数中，this永远指向最后调用他的那个对象(箭头函数除外)。</p>
</li>
<li>
<p>在构造函数中，this指向<strong>new</strong>出来的新对象。</p>
</li>
<li>
<p>call、apply、bind中的this被强绑定在指定的那个对象上。</p>
</li>
<li>
<p>箭头函数this为父作用域的this，不是调用时的this。</p>
</li>
</ul>
<h3 id="原型原型链">原型，原型链</h3>
<blockquote>
<p>谈一谈JavaScript中原型，原型链，有什么特点</p>
</blockquote>
<ul>
<li>在js中，我们可以通过构造函数来创建一个对象，每个构造函数都会有个<strong>prototype</strong>属性，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是<strong>Object.prototype</strong>。</li>
</ul>
<pre><code class="language-js">    function Func(name){
        this.name=name
    };

    let tom=new Func('TOM');

    console.log(tom)


    console.log(tom.__proto__===Func.prototype) //true
    console.log(tom.__proto__.constructor==Func) //true

</code></pre>
<ul>
<li>再上一张图，更好理解</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/09/17/w2zC4g.png" alt="w2zC4g.png" loading="lazy"></figure>
<ul>
<li>原型对象的作用：</li>
</ul>
<pre><code class="language-js">    function Func(name){
        this.name=name;
        this.say=function(){
            console.log(this.name)
        }
    }

    let m=new Func('tom');
    let n=new Func('tom')

    console.log(m)
    console.log(n)

    console.log(m.say===n.say) //false 
</code></pre>
<ul>
<li>每次进行<strong>new</strong>，都会开辟新的区域，这样很显然不好，所以我们可以吧共有的方法放在原型对象上，这样就避免了内存浪费：</li>
</ul>
<pre><code class="language-js">    function Func(name){
        this.name=name;
    }
    Func.prototype.say=function(){
        console.log(this.name)
    }
    let m=new Func('tom');
    let n=new Func('tom')

    console.log(m)
    console.log(n)

    console.log(m.say===n.say) //true
</code></pre>
<h3 id="闭包">闭包</h3>
<blockquote>
<p>谈一谈对闭包的理解，以及使用场景</p>
</blockquote>
<ul>
<li>
<p>闭包是指有权访问另一个函数作用域内的变量的函数。闭包最常见的就是在函数中创建函数，创建的函数就可以访问到当前函数的局部变量。</p>
</li>
<li>
<p>过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p>
</li>
<li>
<p>另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p>
</li>
</ul>
<pre><code class="language-js">    function func(){
        let n=0;
        function add(){
            n++;
            console.log(n)
        }
        return add
    }

    let a=func();
    a() //1
    a()//2
</code></pre>
<h3 id="事件模型">事件模型</h3>
<blockquote>
<p>什么是事件？都有哪几种事件？</p>
</blockquote>
<ul>
<li>
<p>事件是指用户操作页面时候发生的交互或者网页本身的一些操作，浏览器一共有三种事件模型：</p>
</li>
<li>
<p><strong>DOM0级模型</strong>：这种模型不会传播，没有事件流的概念，但现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过js属性来指定监听函数。</p>
</li>
<li>
<p><strong>IE事件模型</strong>：在这种事件模型中，一次事件一共有两个过程，<strong>事件处理阶段</strong>和<strong>事件冒泡阶段</strong>，事件处理阶段首先会执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从冒泡到<strong>document</strong>，一次检查经过的节点是否绑定了事件监听函数，会按顺序依次进行。</p>
</li>
<li>
<p><strong>DOM2级事件模型</strong>：在该事件模型中，一次事件一共有三个过程，第一个过程就是<strong>事件捕获阶段</strong>，捕获指的是事件从<strong>document</strong>一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面的两个阶段和IE事件模型基本一样。这样的事件模型，事件绑定的函数就是<strong>addEventListener</strong>,其中第三个参数可以指定事件是否在捕获阶段执行。</p>
</li>
</ul>
<pre><code class="language-js">    //DMO0
     element.onclick=function(){}

    //DOM2
    element.addEventListener('click',function(){},false)

    //DOM3 增加了鼠标事件，键盘事件
    element.addEventListener('keyup',function(){},false)

</code></pre>
<ul>
<li>
<p>DOM事件的捕获流程:window---&gt;document---&gt;html---&gt;body---&gt;逐渐传递</p>
</li>
<li>
<p>DOM事件冒泡过程：目标元素---&gt;父元素---&gt;body---&gt;html---&gt;document---&gt;window</p>
</li>
</ul>
<h4 id="event对象的常见应用">Event对象的常见应用</h4>
<ul>
<li>
<p>event.preventDefault() //阻止默认行为 比阻止点击a标签转跳</p>
</li>
<li>
<p>event.stopPropagation() //阻止事件冒泡</p>
</li>
<li>
<p>event.stoplmmediatePropagation() //同时注册两个事件，决定事件优先级</p>
</li>
<li>
<p>event.currentTarget() //事件代理，把子元素的事件委托给父元素</p>
</li>
<li>
<p>event.target() //当前被点击的元素</p>
</li>
</ul>
<h3 id="异步编程">异步编程</h3>
<blockquote>
<p>谈一谈js中的异步编程方案，它为了解决什么？</p>
</blockquote>
<ul>
<li>我们之前写代码，可能会出现函数嵌套函数，如果多个嵌套，结构就会很乱，也不容易维护，于是便有了异步编程的概念。</li>
</ul>
<h4 id="promise">Promise</h4>
<ul>
<li>
<p><strong>Promise</strong>是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
</li>
<li>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
</li>
<li>
<p>Promise对象的状态不受外界影响，它有三种状态，<code>pending</code>(进行中)、<code>fulfilled</code>(已成功)、<code>rejected</code>(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。它的状态可以从<strong>pending</strong>变为<strong>fulfilled</strong>，或者从<strong>pending</strong>变为<strong>rejected</strong>。</p>
</li>
</ul>
<h5 id="then方法">then方法</h5>
<ul>
<li>Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。</li>
</ul>
<pre><code class="language-js">    const testPormise=new Promise((resovle,reject)=&gt;{
       console.log(&quot;hi,Pormise&quot;);
       let test=true;
       if(test){
            resovle('成功～')
       }else{
           reject(&quot;失败了&quot;)
       }
    });
    testPormise.then((res)=&gt;{
        console.log(res)
    }).catch((erro)=&gt;{
        console.log(erro)
    })
</code></pre>
<h4 id="rejected">rejected</h4>
<ul>
<li>只有执行了<strong>rejected</strong>这样就可以在then中捕获到，然后执行失败情况下的回调：</li>
</ul>
<pre><code class="language-js"> let p = new Promise((resolve, reject) =&gt; {
        //做一些异步操作
      setTimeout(function(){
            var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num&lt;=3){
                resolve(num);
            }
            else{
                reject('数字太大了');
            }
      }, 2000);
    });
    p.then((data) =&gt; {
            console.log('resolved',data);
        },(err) =&gt; {
            console.log('rejected',err);
        }
    ); 
</code></pre>
<h4 id="catch">catch</h4>
<ul>
<li>catch和then用法一样，用来指定<strong>reject</strong>的回调：</li>
</ul>
<pre><code class="language-js">    p.then((data) =&gt; {
        console.log('resolved',data);
    }).catch((err) =&gt; {
        console.log('rejected',err);
    });
</code></pre>
<h4 id="all">all</h4>
<ul>
<li>all接收一个数组参数，里面的值最终都算返回Promise对象,谁执行的慢，以谁为准执行回调：</li>
</ul>
<pre><code class="language-js">    let Promise1 = new Promise(function(resolve, reject){})
    let Promise2 = new Promise(function(resolve, reject){})
    let Promise3 = new Promise(function(resolve, reject){})

    let p = Promise.all([Promise1, Promise2, Promise3])

    p.then(funciton(){
    // 三个都成功则成功  
    }, function(){
    // 只要有失败，则失败 
    })
</code></pre>
<h4 id="race">race</h4>
<ul>
<li>谁跑的快，以谁为准执行回调,常见应用场景为设置请求超时时间，在请求超时后执行相应的回调。</li>
</ul>
<h3 id="event-loop">Event Loop</h3>
<blockquote>
<p>说一说js中事件执行机制是怎么样的？</p>
</blockquote>
<ul>
<li>
<p>“<strong>JavaScript 是单线程、异步、非阻塞、解释型脚本语言</strong>”。JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。</p>
</li>
<li>
<p>在js中，任务进入执行栈，先判断任务类型，如果是同步任务，直接进入到主线程执行。如果是异步任务，会把任务放到异步队列，等同步任务执行完以后，事件触发线程会从消息队列中取出刚才加入队列的函数，如果有，就一条一条的去执行。</p>
</li>
</ul>
<pre><code class="language-js">    console.log(1)

    setTimeout(() =&gt; {
        console.log(2)
    }, 1000);
    
    console.log(3)

    //1 3 2
</code></pre>
<h4 id="微任务">微任务</h4>
<ul>
<li>js中，setTimeout属于宏任务，像<strong>Promise</strong>为微任务，</li>
</ul>
<pre><code class="language-js">    console.log(1)

    setTimeout(() =&gt; {
        console.log(2)
    }, 1000);

    let test=new Pormise((resolve)=&gt;{
        console.log(3);
        resolve();
    })
    .then(=&gt;console.log(4))


    console.log(5)
    1.3 5 4.2
</code></pre>
<ul>
<li>首先会输出1，然后遇到<strong>setTimeout</strong>，注册任务接着又遇到<strong>Pormise</strong>，首先先输出3，然后注册任务，接着会输出5，这时候执行栈没有可执行的，然后会从队列中取，这时候会先取出微任务进行执行，进入到then，输出4，这时候执行栈又为空，这时候继续从队列中取出一条任务，这时候会输出2。</li>
</ul>
<h3 id="继承">继承</h3>
<blockquote>
<p>如何实现继承？怎么样能完美继承？</p>
</blockquote>
<ul>
<li>构造函数继承,借助构造函数通过<strong>call</strong> <strong>apply</strong>改变指向实现继承，但这种继承方式有一个缺点：<strong>继承不了父类原型对象上的属性，只能继承构造函数内的属性</strong>。</li>
</ul>
<pre><code class="language-js">    function Parent1(){
        this.name='Parent1'
    };

    Parent1.prototype.say=function(){
        console.log(this.name)
    }

    function Child1(){
        Parent1.call(this);//apply
        this.type='Child1'
    }

    let n=new Child1();
    console.log(n.say)//undefined
</code></pre>
<ul>
<li>原型链实现继承,缺点：<strong>实例出来的是共用的</strong>。</li>
</ul>
<pre><code class="language-js">   function Parent(){
        this.name='Parent1';
        this.arr=[1,2,3,4,5]
    };

    Parent.prototype.say=function(){
        console.log(this.name)
    }

    function Child(){
        this.type='Child1'
    }

    Child.prototype=new Parent();

    var s1=new Child();
    var s2=new Child();
    s1.arr.push(6)
    console.log(s1.arr) //[1,2,3,4,5,6]
    console.log(s2.arr) //[1,2,3,4,5,6]
    //他们俩是公用的
    console.log(s1.__proto__===s2.__proto__) //true
</code></pre>
<ul>
<li>组合继承(借鉴上面两个的优点)</li>
</ul>
<pre><code class="language-js">    function Parent(){
        this.name='tom';
    };

    Parent.prototype.say=function(){
        console.log(this.name)
    };

    function Child(){
        Parent.call(this)
        this.age=18;
    };

    Child.prototype=Object.create(Parent.prototype);

    Child.prototype.constructor=Child;
</code></pre>
<h3 id="移动端常见问题">移动端常见问题</h3>
<h4 id="如何禁止点击穿透">如何禁止点击穿透</h4>
<ul>
<li>在移动端中经常会做弹窗，但是弹窗出来后滑动页面，底部元素也会滑动。这时候可以给body加一个样式：</li>
</ul>
<pre><code class="language-css">body.active{
    position: fixed;
    left: 0;
    width: 100%;
}
</code></pre>
<ul>
<li>同时通过<strong>scrollingElement</strong>获得滚动偏移量，赋值给<strong>body</strong>一个<strong>top</strong>。</li>
</ul>
<h4 id="input高度塌陷">input高度塌陷</h4>
<blockquote>
<p>当页面同时出现以下三个条件时，键盘占位会把页面高度压缩一部分。当输入完成键盘占位消失后，页面高度有可能回不到原来高度，产生坍塌导致Webview底色露脸，简单概括就是输入框失焦后页面未回弹。</p>
</blockquote>
<ul>
<li>解决方法：input聚焦时候获取滚动偏移量，失去焦点以后重新赋值偏移量</li>
</ul>
<pre><code class="language-js">    const input =document.getElementById('input');
    let scrollTop=0;
    input.addEventListener(&quot;focus&quot;,()=&gt;{
        scrollTop=document.scollingElement.srollTop;
    })
    input.addEventListener(&quot;blur&quot;,()=&gt;{
        document.scollingElement.scrollTo(0,scrollTop)
    })
</code></pre>
<h2 id="vue">Vue</h2>
<h3 id="vue生命周期">vue生命周期</h3>
<blockquote>
<p>Vue有几个生命周期？哪个生命周期可以获取到真实DOM？修改data里面的数据，会触发什么生命周期？组件data为什么是一个函数？</p>
</blockquote>
<ul>
<li>简单来说，vue的生命周期可以归为3类，创建阶段、运行阶段、销毁阶段。</li>
</ul>
<h4 id="创建阶段">创建阶段</h4>
<ul>
<li>
<p><strong>beforeCreate</strong>：实例刚在内存中创建出来，还没有初始化 data和 methods，只包含一些自带额生命周期函数。</p>
</li>
<li>
<p><strong>created</strong>：实例已经在内存中创建完成，此时data和methods已经创建完成。</p>
</li>
<li>
<p><strong>beforeMount</strong>：此时已经编译模版，但没有渲染到页面中。</p>
</li>
<li>
<p><strong>mounted</strong>：渲染模版，创建阶段到此结束。这时候可以操作dom。</p>
</li>
</ul>
<h4 id="运行阶段">运行阶段</h4>
<ul>
<li>
<p><strong>beforeUpdate</strong>：界面中的数据还是旧的，但是data数据已经更新，页面中和data还没有同步。修改data数据就会触发这个函数。</p>
</li>
<li>
<p><strong>updated</strong>：页面重新渲染完毕，页面中的数据和data保持一致。修改data数据就会触发这个函数。</p>
</li>
</ul>
<h4 id="销毁阶段">销毁阶段</h4>
<ul>
<li>
<p><strong>beforeDestroy</strong>：执行该方法的时候，Vue的生命周期已经进入销毁阶段，但是实例上的各种数据还出于可用状态。</p>
</li>
<li>
<p><strong>destroyed</strong>：组件已经全部销毁，Vue实例已经被销毁，Vue中的任何数据都不可用</p>
</li>
</ul>
<h4 id="keep-alive">keep-alive</h4>
<ul>
<li>
<p><strong>activited</strong>：keep-alive 专属，组件被激活时调用</p>
</li>
<li>
<p><strong>deactivated</strong>：keep-alive 专属，组件被销毁时调用</p>
</li>
</ul>
<h3 id="vue父组件和子组件的执行顺序">vue父组件和子组件的执行顺序</h3>
<h4 id="加载过程">加载过程</h4>
<ul>
<li>父beforeCreate--&gt;父created--&gt;父beforeMount--&gt;子beforeCreate--&gt;子created--&gt;子beforeMpunt--&gt;子mounted--&gt;父mounted</li>
</ul>
<h4 id="子组件更新过程">子组件更新过程</h4>
<ul>
<li>父beforeUpdate--&gt;子beforUpdate--&gt;子updated--&gt;父updated</li>
</ul>
<h4 id="父组件更新过程">父组件更新过程</h4>
<ul>
<li>父beforeUpdate--&gt;父updated</li>
</ul>
<h4 id="销毁过程">销毁过程</h4>
<ul>
<li>父beforeDestroy--&gt;子beforeDestroy--&gt;子destroyed--&gt;父destroyed</li>
</ul>
<h3 id="vuex">Vuex</h3>
<blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
</blockquote>
<ul>
<li>
<p>(1)Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
</li>
<li>
<p>(2)改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
</li>
</ul>
<h4 id="组成部分">组成部分</h4>
<ul>
<li><strong>State</strong>:定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li><strong>Getter</strong>:允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li><strong>Mutation</strong>:是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li><strong>Action</strong>:用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li><strong>Module</strong>:许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>
<h3 id="vue组件通信">vue组件通信</h3>
<blockquote>
<p>vue组件如何通信？有几种方式？</p>
</blockquote>
<ul>
<li>在vue中组件通讯可以分为父子组件通讯和非父子组件通信。<br>
父子组件通信: props/ $emit/ $parent / $children; provide / inject ; ref ;  $attrs / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">兄</mi><mi mathvariant="normal">弟</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">信</mi><mo>:</mo><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>B</mi><mi>u</mi><mi>s</mi><mo separator="true">;</mo><mi>v</mi><mi>u</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">跨</mi><mi mathvariant="normal">级</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">信</mi><mo>:</mo><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>B</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">；</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">；</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">listeners  
兄弟组件通信: eventBus ;vuex  
跨级通信: eventBus；Vuex；provide / inject 、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">兄</span><span class="mord cjk_fallback">弟</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">信</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">跨</span><span class="mord cjk_fallback">级</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">信</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">；</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">；</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">、</span></span></span></span>attrs / $listeners<br>
下面演示几种常用的使用方法：</li>
</ul>
<h4 id="props-emit">props / $emit</h4>
<ul>
<li>父组件通过props的方式向子组件传递数据，而通过$emit子组件可以向父组件通信。</li>
</ul>
<h5 id="父组件向子组件传值props">父组件向子组件传值(props)</h5>
<blockquote>
<p>prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。</p>
</blockquote>
<pre><code class="language-html">    &lt;!-- section父组件 --&gt;
    &lt;template&gt;
        &lt;div class=&quot;section&quot;&gt;
            &lt;com-article :articles=&quot;articleList&quot;&gt;&lt;/com-article&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import comArticle from './test/article.vue'
        export default {
        name: 'HelloWorld',
        components: { comArticle },
        data() {
            return {
            articleList: ['红楼梦', '西游记', '三国演义']
            }
        }
    }
     &lt;/script&gt;

    // 子组件 article.vue
    &lt;template&gt;
        &lt;div&gt;
            &lt;span v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/span&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
    export default {
        props: ['articles']
    }
    &lt;/script&gt;

</code></pre>
<h5 id="子组件向父组件传值emit">子组件向父组件传值($emit)</h5>
<blockquote>
<p>$emit绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数。</p>
</blockquote>
<pre><code class="language-html">    &lt;!-- 子组件 --&gt;
    &lt;template&gt;
        &lt;div&gt;
            &lt;div v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot; @click=&quot;emitIndex(index)&quot;&gt;{{item}}&lt;/div&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        export default {
            props: ['articles'],
            methods: {
                emitIndex(index) {
                  this.$emit('onEmitIndex', index)
                }
            }
        }
    &lt;/script&gt;

     &lt;!-- // 父组件中 --&gt;
    &lt;template&gt;
        &lt;div class=&quot;section&quot;&gt;
            &lt;com-article :articles=&quot;articleList&quot; @onEmitIndex=&quot;onEmitIndex&quot;&gt;&lt;/com-article&gt;
            &lt;p&gt;{{currentIndex}}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import comArticle from './test/article.vue'
        export default {
            name: 'HelloWorld',
            components: { comArticle },
            data() {
                return {
                currentIndex: -1,
                articleList: ['红楼梦', '西游记', '三国演义']
                }
            },
            methods: {
                onEmitIndex(idx) {
                this.currentIndex = idx
                }
            }
        }
    &lt;/script&gt;

</code></pre>
<h4 id="children-parent">$children / $parent</h4>
<blockquote>
<p>通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">parent和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">和</span></span></span></span>children就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和data。如在#app上拿<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">得</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">是</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>V</mi><mi>u</mi><mi>e</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">的</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">再</mi><mi mathvariant="normal">拿</mi></mrow><annotation encoding="application/x-tex">parent得到的是new Vue()的实例，在这实例上再拿</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">再</span><span class="mord cjk_fallback">拿</span></span></span></span>parent得到的是undefined，而在最底层的子组件拿<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">也</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">得</mi><mi mathvariant="normal">到</mi></mrow><annotation encoding="application/x-tex">children是个空数组。也要注意得到</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span></span></span></span>parent和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">children的值不一样，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">，</span></span></span></span>children 的值是数组，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">在</mi><mo>∗</mo><mo>∗</mo><mi>v</mi><mi>u</mi><mi>e</mi><mn>3.0</mn><mo>∗</mo><mo>∗</mo><mi mathvariant="normal">中</mi><mi mathvariant="normal">，</mi><mo>∗</mo><mo>∗</mo></mrow><annotation encoding="application/x-tex">parent是个对象。在**vue3.0**中，**</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">在</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord">3</span><span class="mord">.</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>children**已经被移除。</p>
</blockquote>
<pre><code class="language-html">    &lt;template&gt;
        &lt;div class=&quot;hello_world&quot;&gt;
            &lt;div&gt;{{msg}}&lt;/div&gt;

            &lt;!-- child --&gt;
            child
            &lt;com-a&gt;&lt;/com-a&gt;
            &lt;button @click=&quot;changeA&quot;&gt;点击改变子组件值&lt;/button&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import ComA from './child'
        export default {
            name: 'HelloWorld',
            components: { ComA },
            data() {
                return {
                msg: 'Welcome'
                }
            },

            methods: {
                changeA() {
                    // 获取到子组件A
                    console.log(this.$children)
                    this.$children[0].messageA = 'this is new value'
                }
            }
        }
    &lt;/script&gt;


    &lt;!-- 子组件中 --&gt;
    &lt;template&gt;
        &lt;div class=&quot;com_a&quot;&gt;
            &lt;span&gt;{{messageA}}&lt;/span&gt;
            &lt;p&gt;获取父组件的值为:  {{parentVal}}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        export default {
            data() {
                return {
                messageA: 'this is old'
                }
            },
            computed:{
                parentVal(){
                    return this.$parent.msg;
                }
            }
        }
    &lt;/script&gt;

</code></pre>
<h4 id="refrefs">ref/refs</h4>
<blockquote>
<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据</p>
</blockquote>
<pre><code class="language-html">    &lt;!-- //子组件 --&gt;
    &lt;template&gt;
        &lt;div &gt;child&lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
        export default {
            data() {
                return {
                    name: 'this is child'
                }
            },
            methods: {
                sayHello(){
                    return 'say hello'
                }
            },
        }
    &lt;/script&gt;

    &lt;!-- 父组件 --&gt;
    &lt;template&gt;
        &lt;div &gt;
            &lt;com-a ref=&quot;child&quot;&gt;&lt;/com-a&gt;
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        import ComA from './child'
        export default {
        components: { ComA },
            data() {
                return {
                msg: 'Welcome'
                }
            },
            mounted() {
                const child = this.$refs.child;
                console.log(child.name) //this is child
                console.log(child.sayHello()) //say hello
                
            },
        }
    &lt;/script&gt;
</code></pre>
<h4 id="eventbus">eventBus</h4>
<blockquote>
<p>eventBus 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难。</p>
</blockquote>
<h3 id="双向绑定的原理">双向绑定的原理</h3>
<blockquote>
<p><strong>vue2</strong>是采用数据劫持结合发布者-订阅者模式的方式，通过 <strong>Object.defineProperty()</strong> 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<strong>Object.defineProperty()<strong>只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持。<strong>vue3</strong>中则采用</strong>Proxy</strong>，它可以监听到数组内的数据变化。</p>
</blockquote>
<h3 id="为什么-vue-组件中-data-必须是一个函数">为什么 Vue 组件中 data 必须是一个函数？</h3>
<blockquote>
<p>如果 data 是一个对象，当复用组件时，因为 data 都会指向同一个引用类型地址，其中一个组件的 data 一旦发生修改，则其他重用的组件中的 data 也会被一并修改。<br>
如果 data 是一个返回对象的函数，因为每次重用组件时返回的都是一个新对象，引用地址不同，便不会出现如上问题。</p>
</blockquote>
<h3 id="vue-中-computed-和-watch-有什么区别">Vue 中 computed 和 watch 有什么区别</h3>
<blockquote>
<p>计算属性 computed：<br>
（1）支持缓存，只有依赖数据发生变化时，才会重新进行计算函数；<br>
（2）计算属性内不支持异步操作；<br>
（3）计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属性)方法；<br>
（4）计算属性是自动监听依赖值的变化，从而动态返回内容。</p>
</blockquote>
<blockquote>
<p>侦听属性 watch:<br>
(1) 不支持缓存，只要数据发生变化，就会执行侦听函数；<br>
(2) 侦听属性内支持异步操作；<br>
(3) 侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性；<br>
(3) 监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些其他事情。</p>
</blockquote>
<h2 id="其他知识">其他知识</h2>
<h3 id="在浏览器中输入url后都会发生什么">在浏览器中输入url后都会发生什么</h3>
<h4 id="大致流程">大致流程</h4>
<blockquote>
<p>1.URL 解析<br>
2.DNS 查询<br>
3.TCP 连接<br>
4.处理请求<br>
5.接受响应<br>
6.渲染页面</p>
</blockquote>
<h2 id="结尾">结尾</h2>
<blockquote>
<p>更多前端学习文章，请点击<a href="https://www.zhihu.com/column/lonjin">前端进阶班</a>，欢迎关注！记得素质三连！</p>
</blockquote>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://lonjinup.github.io/jsjc/" class="post-title gt-a-link">
                    面向对象中的继承
                </a>
            </div>
        

        

        
            
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'db2f457cc3883b93aadf',
    clientSecret: '8c89802acb4c16969d407de1d7bcee30a0d51886',
    repo: 'lonjinup.github.io',
    owner: 'LonJinUp',
    admin: ['LonJinUp'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">记录学习 记录生活</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/long-jin-48-31" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://lonjinup.github.io/" target="_blank">LonJin</a>
<script type="text/javascript">window.$crisp=[];window.CRISP_WEBSITE_ID="0fdde3b6-a87f-4594-9b7f-25d151ba858f";(function(){d=document;s=d.createElement("script");s.src="https://client.crisp.chat/l.js";s.async=1;d.getElementsByTagName("head")[0].appendChild(s);})();</script>
<style>
.gt-bg-theme-color-second{ background: none!important;}
</style>

    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://lonjinup.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
