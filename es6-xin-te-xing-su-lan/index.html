<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>ES6新特性速览 | 陇锦</title>

<link rel="shortcut icon" href="https://lonjinup.github.io/favicon.ico?v=1751543015276">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://lonjinup.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            陇锦
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://lonjinup.github.io/aboutme" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1751543015276" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    ES6新特性速览
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2022-07-25 ·
                    </time>
                    
                        <a href="https://lonjinup.github.io/su-x11Ukj/" class="post-tags">
                            # JavaScript
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="es6新特性速览">ES6新特性速览</h1>
<blockquote>
<p>虽然<code>ES6</code>现在基本都是前端必会内容了，网上也一堆文章了，但有些初学者可能看完还是记不住，所以便写一篇文章快速过一下<code>ES6</code>的一些新特性，加深印象。如果你还没有学<code>ES6</code>，还是推荐你阅读一下<a href="https://es6.ruanyifeng.com/">阮一峰的ES6入门指南</a>。<br>
☀️如果觉得文章不错，欢迎点赞❤️、关注🌟、收藏📄！</p>
</blockquote>
<p>🚀<code>ES6</code>的新特性，大致可以归为4大类：</p>
<ul>
<li>解决原有语法上的一些问题或者不足</li>
<li>对原有语法进行增强</li>
<li>全新的对象、全新的方法、全新的功能</li>
<li>全新的数据类型和数据结构（symbol、set、map、etc.）</li>
</ul>
<h2 id="块级作用域">块级作用域</h2>
<blockquote>
<p>作用域——某个成员能够起作用的范围,在ES2015之前，只有两种作用域：<code>全局作用域</code>和<code>函数作用域</code>。在ES2015中新增：<code>块级作用域</code>.</p>
</blockquote>
<pre><code class="language-js">//var 会变量提升，所以值会是undefined
console.log(a);//undefined
var a=1;

//let 不会进行变量提升
console.log(b)//Cannot access 'b' before initialization
let b=2;

//块级作用域
{
  let c=20;
}
console.log(c) //c is not defined

//const 申明时候必须赋值，且声明之后不可修改值，但可以修改对象中的某个值,
//const 和let一样，也存在块级作用域
const a={name:'lonjin'};
a.name='tom';
console.log(a)//{ name: 'tom' }
</code></pre>
<ul>
<li>经典面试题：</li>
</ul>
<pre><code class="language-js">for(var i=1;i&lt;6;i++){
    setTimeout(() =&gt; {
        console.log(i)
    }, 0);
}
// 6 6 6 6 6

for(let i=1;i&lt;6;i++){
   setTimeout(() =&gt; {
    console.log(i)
   }, 0);
}
// 1 2 3 4 5
</code></pre>
<h2 id="数组的解构">数组的解构</h2>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="language-js">const arr=[1,2,3,4,5];
const [a, b, c] = arr;
console.log(a,b,c) //1 2 3
</code></pre>
<ul>
<li>只获取数组中第三个成员，方法，前面两个用逗号隔开，只声明第三个</li>
</ul>
<pre><code class="language-js">const arr=[1,2,3];
const [,,c]=arr;
console.log(c) //3
</code></pre>
<ul>
<li>提取数组当前位置开始的所有成员(注意：三个点的用法只能在解构成员的最后使用)</li>
</ul>
<pre><code class="language-js">const arr=[1,2,3,4,5];
const [a,...arr2]=arr;
console.log(arr2) //[ 2, 3, 4, 5 ]
</code></pre>
<ul>
<li>可以给提取到的成员设置默认值，如果没有提取到值，就会赋为默认值</li>
</ul>
<pre><code class="language-js">const arr=[1,2,3,4,5];
const [a,b,c,d,e,f=6]=arr;
console.log(f) //6
</code></pre>
<h3 id="对象的解构">对象的解构</h3>
<ul>
<li>基本使用(和数组解构基本相同)</li>
</ul>
<pre><code class="language-js">const data={name:&quot;lonjin&quot;,age:18};
const {name}=data;
console.log(name) //lonjin
</code></pre>
<ul>
<li>如果解构过程中遇到命名重复，可使用重命名的方式解决；设置默认值方法如下：</li>
</ul>
<pre><code class="language-js">const data={name:&quot;lonjin&quot;,age:18};
const name='tom';
const {name:newName}=data;
console.log(newName) //lonjin
</code></pre>
<ul>
<li>同样也可以设置默认值</li>
</ul>
<pre><code class="language-js">const data={name:&quot;lonjin&quot;,age:18};
const name='tom';
const {name:newName,say='hello'}=data;
console.log(newName+','+say) //lonjin,hello
</code></pre>
<ul>
<li>解构常用方法，如<code>console.log</code></li>
</ul>
<pre><code class="language-js">const {log}=console;
log(1)//1
</code></pre>
<h2 id="模版字符串">模版字符串</h2>
<ul>
<li>
<p>反引号定义字符串，若字符串中需要有反引号，可以用\反斜杠转义</p>
</li>
<li>
<p>支持字符串中直接换行</p>
</li>
<li>
<p>支持插值表达式写法 `hello, ${name}</p>
</li>
</ul>
<pre><code class="language-js">const name='lonjin';
const text=`hello ${name} \nuser age ${17+1}`;
console.log(text) 
/*
hello lonjin 
user age 18
*/
</code></pre>
<h3 id="带标签的模板字符串">带标签的模板字符串</h3>
<ul>
<li>标签模板字符串的作用：是对我们的模板字符串进行加工处理，然后返回新内容</li>
</ul>
<pre><code class="language-js">const name='lonjin',
    sex=true,
    age=18;

function fn(strings,...args){
    //string为text中普通string数组
    console.log(strings)
    //[ 'my name is ', ',my age', ',my sex', '' ]
    //args为插值表达式中的值
    console.log(args)
    // [ 'lonjin', 18, true ]

    //可以处理完数据return出去
    let sex=args[2]?'man':woman;
    return strings[0]+args[0]+strings[1]+args[1]+strings[2]+sex
}

const text=fn`my name is ${name}my age${age}my sex ${sex}`;

console.log(text)
//my name is lonjinmy age18my sex man
</code></pre>
<h2 id="字符串的扩展方法">字符串的扩展方法</h2>
<ul>
<li><code>includes()</code>:判断一个字符串是否包含在另一个字符串中,返回<code>true</code>或者<code>false</code></li>
</ul>
<pre><code class="language-js">const str='erro type end.';
let f1=str.includes('erro');
console.log(f1)//true
</code></pre>
<ul>
<li><code>startsWith()</code>:判断当前字符串是否以另外一个给定的子字符串开头，返回<code>true</code>或者<code>false</code></li>
</ul>
<pre><code class="language-js">const str='erro type end.';
let f2=str.startsWith('erro');
console.log(f2) //true
</code></pre>
<ul>
<li><code>endsWith</code>:判断当前字符串是否以另外一个给定的子字符串结尾，返回<code>true</code>或者<code>false</code></li>
</ul>
<pre><code class="language-js">const str='erro type end.';
let f3=str.endsWith('.');
console.log(f3) //true
</code></pre>
<h2 id="参数默认值">参数默认值</h2>
<ul>
<li>函数参数默认值</li>
</ul>
<pre><code class="language-js">function fn(status=false){
    console.log(status)
}
fn(true)
fn()
/*
true
false
*/
</code></pre>
<h2 id="剩余参数">剩余参数</h2>
<ul>
<li>只能出现在最后，且只能使用一次</li>
</ul>
<pre><code class="language-js">function fn(...args){
    console.log(args)
};
fn(1,2,3,4,5)
//[ 1, 2, 3, 4, 5 ]
</code></pre>
<h2 id="展开数组">展开数组</h2>
<ul>
<li>想依次打印数组的值</li>
</ul>
<pre><code class="language-js">let arr=['a','b','c'];
console.log(...arr);
//a b c
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="language-js">//普通函数
function fn(num){
    return num+1
};
console.log(fn(2)) //3

//箭头函数
const fn2=n=&gt;n+1;
console.log(fn2(2))//3
</code></pre>
<h3 id="箭头函数的this">箭头函数的this</h3>
<ul>
<li>箭头函数不会改变<code>this</code>指向，也就是说在箭头函数的外面拿到的this是什么，在箭头函数内部拿到的this也就是什么。</li>
</ul>
<pre><code class="language-js">const name='tom'

const people={
    name:'lonjin',
    say(){
        console.log(`this name is ${this.name}`)
    },
    say2:()=&gt;{
        console.log(`this name is ${this.name}`)
    }
}

people.say();//this name is lonjin
people.say2()//this name is undefined
</code></pre>
<h2 id="对象的扩展">对象的扩展</h2>
<h3 id="对象字面量的增强">对象字面量的增强</h3>
<ul>
<li>
<p>对象中属性名和属性值相同就可以缩写</p>
</li>
<li>
<p>函数表达式也可以缩写</p>
</li>
<li>
<p>动态属性名，可以直接使用计算属性名，使用方括号的形式使用</p>
</li>
</ul>
<pre><code class="language-js">const username='lonjin';

const people={
    age:18,
    username,
    [Math.random()]:123,
}

console.log(people)
//{ age: 18, username: 'lonjin', '0.3692996732470484': 123 }
</code></pre>
<h3 id="objectassign">Object.assign</h3>
<ul>
<li>将多个源对象中的属性复制到一个目标对象中；第一个参数为目标对象，如果有相同的，后面的会覆盖之前的值。</li>
</ul>
<pre><code class="language-js">let obj={
    a:123,
    b:456,
}
let obj2={
    a:789,
    c:234
}
let obj3={
    d:123,
    c:678
}
// const n=Object.assign(obj,obj2)
//console.log(n)//{ a: 789, b: 456, c: 234 }

const m=Object.assign(obj,obj2,obj3);
console.log(m)
//{ a: 789, b: 456, c: 678, d: 123 }
</code></pre>
<h3 id="objectis">Object.is</h3>
<ul>
<li>判断两个对象是否相等，和严格相等运算符(<code>===</code>)类似,但有两个值他们判断起来不太一样:<code>+0</code>与<code>-0</code>、<code>NaN</code></li>
</ul>
<pre><code class="language-js">console.log(
    //0==false //true
    //+0 === -0 // true
    // NaN === NaN  //false
    //Object.is(NaN,NaN) //true
    Object.is(+0,-0) //false
)
</code></pre>
<h2 id="proxy">Proxy</h2>
<ul>
<li>代理对象:为对象设置访问代理器</li>
</ul>
<pre><code class="language-js">const people={
    name:&quot;lonjin&quot;,
    age:18,
}

let peopleProxy=new Proxy(people,{
    //监听读取
    get(target,property){
        // target为对象
        // property为要读取的键
        console.log(target,property)
        //{ name: 'lonjin', age: 18 } name
        //返回读取的内容
        return property in target?target[property]:'none'
    },
    //监听属性设置
    set(target,property,value){
        /*target---目标对象
          property---要设置的键名
          value---要设置的新值
        */
       if(property=='age'){
           if(!Number.isInteger(value)){
               throw new TypeError('Value must be a number')
           }
       }
       target[property]=value
    }
})

console.log(peopleProxy.name)//lonjin
console.log(peopleProxy.say)//none
// peopleProxy.age='28';//throw new TypeError('Value must be a number')
peopleProxy.age=20;
</code></pre>
<h3 id="defineproperty和proxy的区别">defineProperty和Proxy的区别</h3>
<ul>
<li><code>defineProperty</code>只能监视属性的读写，<code>Proxy</code>能够见识到更多对象操作。比如属性的删除：</li>
</ul>
<pre><code class="language-js">const people={
    name:&quot;lonjin&quot;,
    age:18,
};
let peopleProxy=new Proxy(people,{
   deleteProperty(target,property){
       //target 为代理对象
       //property 为要删除的键名
       delete target[property]
   }
});
delete peopleProxy.age;
console.log(peopleProxy)
//{ name: 'lonjin' }
</code></pre>
<ul>
<li><code>Proxy</code>更好的支持数组对象的监视,<code>vue3</code>中就采用了<code>Proxy</code>来实现数据监听</li>
</ul>
<pre><code class="language-js">//监听数组push操作
let arr=[];

let newArray=new Proxy(arr,{
    set(target,property,value){
        target[property]=value;
        return true
    }
});
newArray.push(1);
newArray.push(2);
console.log(newArray)
//[1,2]
</code></pre>
<ul>
<li>更多操作就不在这里写了，推荐大家一篇文章<a href="https://zhuanlan.zhihu.com/p/115823830">你不知道的 Proxy</a>可以看一下。</li>
</ul>
<h2 id="reflect">Reflect</h2>
<ul>
<li><code>Reflect</code>成员方法就是Proxy处理对象的默认实现，<code>Reflect</code>并非一个构造函数，所以不能通过<code>new()</code>来调用。</li>
</ul>
<pre><code class="language-js">let people={
    name:'lonjin',
    say:'hello',
}

let peopleProxy=new Proxy(people,{
    //如果我们没有定义get方法，那么Proxy会默认一个get方法如下，返回Reflect
    get(target,property){
        return Reflect.get(target,property)
    }
})
</code></pre>
<ul>
<li><code>Reflect</code>最大作用是提供了一套完整的对象调用方法</li>
</ul>
<pre><code class="language-js">let people={
    name:'lonjin',
    say:'hello',
}

console.log('name' in people)
console.log(Reflect.has(people,'name'))

console.log(delete people['say']);
console.log(Reflect.deleteProperty(people,'say'));

console.log(Object.keys(people));
console.log(Reflect.ownKeys(people));
</code></pre>
<ul>
<li><code>Reflect</code>一共有13个静态方法，更多查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN-Reflect</a></li>
</ul>
<h2 id="class">Class</h2>
<ul>
<li>基本使用</li>
</ul>
<pre><code class="language-js">class People{
    constructor(name){
        this.name=name
    }
    say(){
        console.log(`this name ${this.name}`)
    }
};
let user=new People('lonjin');
user.say()
//this name lonjin
</code></pre>
<h3 id="静态方法">静态方法</h3>
<ul>
<li>静态方法可以直接通过类型本身去调用，而实例方法需要通过这个类型构造的实例对象去调用，只需要在方法前面加<code>static</code></li>
</ul>
<pre><code class="language-js">    constructor(name){
        this.name=name
    }
    say(){
        console.log(`this name ${this.name}`)
    }

    static created(name){
        return new People(name)
    }
};
let user=People.created('lonjin');
user.say()
//this name lonjin
</code></pre>
<h3 id="class的继承">class的继承</h3>
<ul>
<li><code>class</code>继承只需要用关键词<code>extends</code>实现，<code>super</code>为父类构造函数</li>
</ul>
<pre><code class="language-js">class People{
    constructor(name){
        this.name=name
    }
    say(){
        console.log(`this name ${this.name}`)
    }
};

class Child extends People{
    constructor(name,age){
        super(name);
        this.age=age;
    }
    message(){
        console.log(`my name is${this.name},my age is ${this.age}`)
    }
};

let tom=new Child('tom',18);
tom.message();
//static
</code></pre>
<h2 id="set数据结构">Set数据结构</h2>
<ul>
<li>set的内部成员是不允许重复的，也就是每一个值在set中都是唯一的。我们平时可以利用<code>Set</code>来实现数组去重</li>
</ul>
<pre><code class="language-js">//基本使用
let setArray=new Set();
setArray.add(1);
setArray.add(2);
setArray.add(3);
setArray.add(4);
setArray.add(4);
console.log(setArray)
//Set(4) { 1, 2, 3, 4 }

//遍历
setArray.forEach(i=&gt;{console.log(i)});
//1 2 3 4

//获取数量
console.log(setArray.size) //4

//删除(返回true或者false)
console.log(setArray.delete(1))//true

//判断是否有某个值(返回true或者false)
console.log(setArray.has(3))//true

//清空
setArray.clear();
</code></pre>
<h3 id="数组去重">数组去重</h3>
<ul>
<li><code>Array.from</code>+<code>set</code></li>
</ul>
<pre><code class="language-js">//方法1
let arr=[1,2,3,4,5,5,6];
let newArr=Array.from(new Set(arr));
console.log(newArr)
//[ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<ul>
<li>展开运算符</li>
</ul>
<pre><code class="language-js">let arr=[1,2,3,4,5,5,6];
console.log([...new Set(arr)]);
//[ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<h2 id="map">Map</h2>
<ul>
<li>js的对象本质上是键值对的集合，但是传统上只能用字符串当作键。所以<code>ES6</code>提供了<code>Map</code>数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。与对象最大的区别就是可以使用任意类型作为键，而对象只能使用字符串作为键</li>
</ul>
<pre><code class="language-js">let m=new Map();

let n={name:'tom'};

// 设置值
m.set(n,18)

//读取值
console.log(m.get(n))//18

//判断是否有某个值
// m.has();

//删除
// m.delete()

//清空
// m.clear()

//遍历
m.forEach((val,key)=&gt;{
    console.log(val,key)
})
</code></pre>
<h2 id="symbol">Symbol</h2>
<ul>
<li>一种全新的原始数据类型， 表示一个独一无二的值。主要解决对象中属性名冲突的问题</li>
</ul>
<pre><code class="language-js">//创建一个独一无二的属性名，且外部无法访问到(模拟私有成员)
let name=Symbol();
let people={
    [name]:'lonjin',
    say(){
        console.log(this[name])
    }
};
people.say()//lonjin
</code></pre>
<ul>
<li>如果我们希望重新使用同一个<code>Symbol</code>值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建一个以该字符串为名称的 <code>Symbol</code> 值，并将其注册到全局</li>
</ul>
<pre><code class="language-js">//全局注册表
let n1=Symbol.for('name');
let n2=Symbol.for('name');
console.log(n1===n2)//true
</code></pre>
<ul>
<li>获取对象中的键时候，如果使用<code>for in</code>，就获取不到<code>Symbol</code>类型的键；必须使用<code>Object.getOwnPropertySymbols()</code>进行获取。</li>
</ul>
<pre><code class="language-js">let people={
    [Symbol()]:'tom',
    age:18
}

console.log(Object.keys(people))
console.log(JSON.stringify(people))
console.log(Object.getOwnPropertySymbols(people))
/*
[ 'age' ]
{&quot;age&quot;:18}
[ Symbol() ]
*/
</code></pre>
<h2 id="for-of方法">for of方法</h2>
<ul>
<li><code>ES6</code>借鉴其他语言，引入了f<code>or...of</code>循环，作为遍历所有数据结构的统一的方法。</li>
</ul>
<p>遍历数组</p>
<pre><code class="language-js">let arr=[1,2,3,4,5];

for(const item of arr){
    console.log(item)
}
//1 2 3 4 5
</code></pre>
<p>可以使用<code>break</code>进行退出</p>
<pre><code class="language-js">//可以使用break进行退出
let arr=[1,2,3,4,5];
for(const item of arr){
    console.log(item)
    if(item&gt;3){
        break
    }
}
//1 2 3 4 
</code></pre>
<p>遍历<code>Set</code></p>
<pre><code class="language-js">let n=new Set([1,2,3,4]);
for(const item of n){
    console.log(item)
}
//1 2 3 4
</code></pre>
<p>遍历<code>Map</code>可以配合数组结构语法，直接获取键值</p>
<pre><code class="language-js">let n=new Map();
n.set('name','tom');
n.set('age',18);

for(const [key,value] of n){
    console.log(key+'----'+value)
}
/*
name----tom
age----18
*/
</code></pre>
<h3 id="可迭代接口">可迭代接口</h3>
<ul>
<li><code>ES6</code>提供了<code>Iterable</code>接口，实现了<code>Iterable</code>接口就是<code>for...of</code>的前提</li>
</ul>
<pre><code class="language-js">let arr=new Set([1,2,3,4,5]);

const iterator=arr[Symbol.iterator]();

console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())

/*
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: 4, done: false }
{ value: 5, done: false }
{ value: undefined, done: true }

*/
</code></pre>
<h3 id="实现可迭代接口">实现可迭代接口</h3>
<ul>
<li>由于<code>for...of</code>方法不能便利普通对象，我们可以手动实现一下</li>
</ul>
<pre><code class="language-js">const obj = {
    store: ['foo', 'bar', 'baz'],
  
    [Symbol.iterator]: function () {
      let index = 0
      const self = this
  
      return {
        next: function () {
          const result = {
            value: self.store[index],
            done: index &gt;= self.store.length
          }
          index++
          return result
        }
      }
    }
  }
  
for(const item of obj){
    console.log(item)
}
//foo bar baz
</code></pre>
<h3 id="迭代器模式">迭代器模式</h3>
<ul>
<li>开发一个任务清单应用</li>
</ul>
<pre><code class="language-js">// 迭代器设计模式
const todos = {
  life: ['吃饭', '睡觉', '打豆豆'],
  learn: ['语文', '数学', '外语'],
  work: ['喝茶'],

  // 提供统一遍历访问接口
  each: function (callback) {
    const all = [].concat(this.life, this.learn, this.work)
    for (const item of all) {
      callback(item)
    }
  },

  // 提供迭代器（ES2015 统一遍历访问接口）
  [Symbol.iterator]: function () {
    const all = [...this.life, ...this.learn, ...this.work]
    let index = 0
    return {
      next: function () {
        return {
          value: all[index],
          done: index++ &gt;= all.length
        }
      }
    }
  }
}
</code></pre>
<h2 id="generator">Generator</h2>
<ul>
<li><code>Generator</code>函数是<code>ES6</code>提供的一种异步编程解决方案,来避免异步编程中回调嵌套过深。</li>
</ul>
<p>基本使用</p>
<pre><code class="language-js">function * fn(){
    console.log('1')
    yield 100
    console.log('2')
    yield 200
    console.log('3')
    yield 300
}

const f=fn();

console.log(f.next())
console.log(f.next())
console.log(f.next())
console.log(f.next())

/*
1
{ value: 100, done: false }
2
{ value: 200, done: false }
3
{ value: 300, done: false }
{ value: undefined, done: true }
*/
</code></pre>
<ul>
<li>使用 <code>Generator</code> 函数实现 <code>iterator</code> 方法</li>
</ul>
<pre><code class="language-js">const todos = {
  life: ['吃饭', '睡觉', '打豆豆'],
  learn: ['语文', '数学', '外语'],
  work: ['喝茶'],
  [Symbol.iterator]: function * () {
    const all = [...this.life, ...this.learn, ...this.work]
    for (const item of all) {
      yield item
    }
  }
}

for (const item of todos) {
  console.log(item)
}
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://lonjinup.github.io/shou-xie-promise-tai-nan-chai-feng-zu-he-fa-ni-ye-ke-yi-shou-xie-promise/" class="post-title gt-a-link">
                    手写Promise太难？拆封组合法你也可以手写Promise
                </a>
            </div>
        

        

        
            
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'db2f457cc3883b93aadf',
    clientSecret: '8c89802acb4c16969d407de1d7bcee30a0d51886',
    repo: 'lonjinup.github.io',
    owner: 'LonJinUp',
    admin: ['LonJinUp'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">记录学习 记录生活</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/long-jin-48-31" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://lonjinup.github.io/" target="_blank">LonJin</a>
<script type="text/javascript">window.$crisp=[];window.CRISP_WEBSITE_ID="0fdde3b6-a87f-4594-9b7f-25d151ba858f";(function(){d=document;s=d.createElement("script");s.src="https://client.crisp.chat/l.js";s.async=1;d.getElementsByTagName("head")[0].appendChild(s);})();</script>
<style>
.gt-bg-theme-color-second{ background: none!important;}
</style>

    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://lonjinup.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
