<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>【node学习-02】如何搭建自己的脚手架 | 陇锦</title>

<link rel="shortcut icon" href="https://lonjinup.github.io/favicon.ico?v=1751543015276">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://lonjinup.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            陇锦
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://lonjinup.github.io/aboutme" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1751543015276" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    【node学习-02】如何搭建自己的脚手架
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-08-22 ·
                    </time>
                    
                        <a href="https://lonjinup.github.io/nodejs/" class="post-tags">
                            # node
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="如何搭建自己的脚手架">如何搭建自己的脚手架</h1>
<h2 id="概要">概要</h2>
<h3 id="什么是脚手架">什么是脚手架？</h3>
<ul>
<li><strong>脚手架</strong>是一种工具，通常是一个全局命令行工具，用于帮助开发人员快速创建和初始化项目文件和目录结构。</li>
</ul>
<h3 id="脚手架的基本能力">脚手架的基本能力</h3>
<ul>
<li>
<p><strong>命令行执行能力：</strong> 脚手架具备能够在命令行中执行的能力，允许用户通过命令行命令来触发脚手架的各种功能。</p>
</li>
<li>
<p><strong>命令行交互能力：</strong> 脚手架可以与用户进行命令行交互，提示用户提供必要的信息或选项，以便根据用户的输入进行项目初始化。</p>
</li>
<li>
<p><strong>项目初始化代码下载能力：</strong> 脚手架能够从远程代码仓库下载项目的初始化代码，以便在本地创建项目。</p>
</li>
</ul>
<h3 id="如何实现一个自己的脚手架工具">如何实现一个自己的脚手架工具</h3>
<p>要实现一个自己的脚手架工具，可以按照以下步骤进行实现</p>
<ol>
<li>
<p><strong>创建自定义全局命令：</strong> 使用Node.js或其他适合的编程语言创建一个全局命令行工具，这个命令可以在任何地方通过命令行调用。通常需要使用包管理器（如npm）来安装全局命令。</p>
</li>
<li>
<p><strong>命令参数接受处理：</strong> 在您的脚手架工具中，编写代码以接受命令行参数，这些参数将指导脚手架执行不同的操作。您可以使用命令行解析库来帮助处理和解释这些参数。</p>
</li>
<li>
<p><strong>下载远程项目代码：</strong> 实现代码下载功能，您可以使用Git或其他版本控制工具来从远程仓库中获取项目的初始化代码。确保您的脚手架可以处理不同的代码源（例如GitHub、GitLab等）。</p>
</li>
<li>
<p><strong>项目初始化完成提示：</strong> 在项目初始化完成后，向用户提供适当的提示信息，指导他们下一步的操作。这可以包括运行项目、安装依赖项或其他相关任务。</p>
</li>
<li>
<p><strong>测试和文档：</strong> 编写测试用例来确保脚手架的稳定性和可靠性。另外，提供清晰的文档，解释如何安装、使用和定制您的脚手架工具。</p>
</li>
<li>
<p><strong>发布和分享：</strong> 将您的脚手架工具发布到适当的包管理器（如npm），以便其他开发人员可以轻松安装和使用它。分享您的脚手架的代码和文档，以促进社区的贡献和改进。</p>
</li>
</ol>
<p>通过遵循这些步骤，您可以创建一个功能强大的脚手架工具，使项目初始化和开发过程更加高效和方便。</p>
<h2 id="创建自定义全局命令">创建自定义全局命令</h2>
<ol>
<li>
<p><strong>创建文件结构：</strong> 我们首先需要设置一个适当的文件结构来开始创建自定义全局命令。在这个过程中，我们会新建一个名为<code>code</code>的文件夹，然后在其中创建一个名为<code>bin</code>的子文件夹。在<code>bin</code>文件夹中，我们将建立一个名为<code>cli.js</code>的文件。这个<code>cli.js</code>文件将包含我们自定义命令的执行逻辑。</p>
</li>
<li>
<p><strong>项目初始化：</strong> 接下来，我们要初始化一个npm项目，以便管理我们的全局命令。在命令行中，我们进入项目的根目录（在<code>code</code>文件夹下），并执行以下命令：</p>
</li>
</ol>
<pre><code class="language-shell">npm init -y
</code></pre>
<p>在这一步中，我们可以将项目命名为<code>my-cli</code>，并且对其他项目选项采用默认值，因为这些选项可以稍后在<code>package.json</code>中修改。</p>
<ol start="3">
<li><strong>配置全局命令：</strong> 在我们的项目的<code>package.json</code>文件中，有一个特殊的字段叫做<code>bin</code>，它用于配置全局命令。我们将在这里定义我们的全局命令与<code>cli.js</code>文件之间的关联，这样npm就知道如何将我们的命令映射到全局环境中。</li>
</ol>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;my-cli&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;&quot;,
    &quot;main&quot;: &quot;index.js&quot;,
    &quot;bin&quot;: {
        &quot;my-cli&quot;: &quot;bin/cli.js&quot;
    },
    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
    },
    &quot;author&quot;: &quot;&quot;,
    &quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
<ol start="4">
<li><strong>挂载全局命令：</strong> 最后，为了使我们的自定义全局命令在系统中可用，我们需要在命令行中执行以下命令，这将使我们的全局命令链接到全局npm包：</li>
</ol>
<pre><code class="language-shell">npm link
</code></pre>
<p>这一步骤完成后，我们就可以在任何地方使用<code>my-cli</code>命令来执行我们在<code>cli.js</code>文件中定义的逻辑了。</p>
<p>比如我们可以在<code>cli.js</code>中写点代码：</p>
<pre><code class="language-js">#! /usr/bin/env node

console.log('我的cli')
</code></pre>
<p>然后运行命令：</p>
<pre><code class="language-js">my-cli
</code></pre>
<p>此时我们就会在控制它上看到我们的打印内容：<code>我的cli</code>。</p>
<blockquote>
<p><code>#! /usr/bin/env node</code> 是一个在Unix-like操作系统中用于指定脚本的解释器的特殊注释。这个注释的作用是告诉操作系统使用哪个解释器来执行脚本文件。在这种情况下，它指定了使用Node.js作为解释器来执行该脚本。</p>
</blockquote>
<p>具体解释如下：</p>
<ul>
<li>
<p><code>#!</code>：这个字符序列称为&quot;shebang&quot;，它告诉操作系统以下内容是用于解释执行脚本的命令。</p>
</li>
<li>
<p><code>/usr/bin/env</code>：这是一个可执行文件，通常用于在系统的环境变量中查找指定的命令或程序。在这里，它被用于寻找可用的<code>node</code>命令。</p>
</li>
<li>
<p><code>node</code>：这是Node.js的可执行文件。当操作系统执行这个脚本时，它会找到<code>/usr/bin/env node</code>，然后使用Node.js来解释和执行接下来的脚本内容。</p>
</li>
</ul>
<p>因此，<code>#! /usr/bin/env node</code> 帮助我们确保无论用户的系统上Node.js的安装路径如何，都可以正确地执行我们的Node.js脚本。这对于全局命令行工具非常有用，因为它们需要在不同的系统上运行，而这些系统可能有不同的Node.js安装路径。这个shebang注释确保了脚本的可移植性和跨平台兼容性。</p>
<ol start="5">
<li><strong>获取命令行参数：</strong></li>
</ol>
<p>在我们的自定义全局命令中，通常需要获取和解析命令行参数，以便根据用户的输入来执行不同的操作。我们可以在<code>cli.js</code>文件中编写如下代码来获取命令行参数：</p>
<pre><code class="language-javascript">console.log(process.argv);
</code></pre>
<p>当我们运行像<code>my-cli --help</code>这样的命令时，控制台将会打印出以下内容：</p>
<pre><code class="language-javascript">[ '/usr/local/bin/node', '/usr/local/bin/my-cli', '--help' ]
</code></pre>
<p>在这个输出中，<code>process.argv</code>数组包含了命令行中的所有参数。具体来说：</p>
<ul>
<li><code>process.argv[0]</code> 是 Node.js 的可执行文件路径（在这里是<code>/usr/local/bin/node</code>）。</li>
<li><code>process.argv[1]</code> 是我们的全局命令的路径（在这里是<code>/usr/local/bin/my-cli</code>）。</li>
<li>后续项包含传递给命令的参数，例如<code>--help</code>。</li>
</ul>
<p>我们可以根据这些参数来编写逻辑，以决定如何处理用户的输入。这是实现命令行交互能力的一部分，允许我们根据用户的需求来执行不同的功能操作。比如：</p>
<pre><code class="language-js">if(process.argv[2] === '--help'){
    console.log('获取到了参数')
}
</code></pre>
<p>但在实际情况中，我们可以使用一些第三方的包去管理我们的指令；比如：<code>commander</code>（命令参数处理工具）。</p>
<h2 id="commander命令参数处理工具">Commander命令参数处理工具</h2>
<p><a href="https://www.npmjs.com/package/commander">Commander</a> 是一个强大的Node.js模块，用于处理命令行参数。以下是使用Commander的基本步骤：</p>
<h3 id="安装commander">安装Commander</h3>
<p>首先，我们需要在npm上搜索并安装Commander模块，这可以通过以下命令完成：</p>
<pre><code class="language-shell">npm install commander
</code></pre>
<h3 id="引入和使用commander">引入和使用Commander</h3>
<p>在我们的项目中，我们可以引入Commander模块并开始使用它来处理命令行参数。通常，我们会在脚本的开头加上如下注释来指定Node.js作为解释器：</p>
<pre><code class="language-javascript">#! /usr/bin/env node
</code></pre>
<p>接下来，在我们的<code>cli.js</code>文件中，引入Commander并调用<code>program.parse(process.argv)</code>来处理命令行参数：</p>
<pre><code class="language-javascript">const { program } = require('commander');

program.parse(process.argv);
</code></pre>
<h4 id="添加命令和选项">添加命令和选项</h4>
<p>现在，我们可以添加命令和选项来定制我们的命令行工具的行为。例如，我们可以使用<code>program.option()</code>来定义选项：</p>
<pre><code class="language-javascript">program.option('-f --framework &lt;framework&gt;', '设置框架')
</code></pre>
<p>这个例子中，我们定义了一个名为<code>-f</code>或<code>--framework</code>的选项，还提供了一个描述。这将允许用户在命令行中设置一个框架参数。</p>
<p><code>program.option('-f --framework &lt;framework&gt;', '设置框架')</code> 是使用Commander库定义命令行选项的语句。让我们解释这行代码的作用：</p>
<ul>
<li>
<p><code>program.option()</code>：这是Commander库提供的一个方法，用于定义命令行选项。</p>
</li>
<li>
<p><code>-f</code> 和 <code>--framework</code>：这两个部分是选项的名称，它们以两种形式存在，一种是短格式（单字符，前面带一个短划线 <code>-</code>），一种是长格式（多字符，前面带两个短划线 <code>--</code>）。用户可以使用其中任何一种形式来指定选项。</p>
</li>
<li>
<p><code>&lt;framework&gt;</code>：这是用尖括号括起来的参数占位符，表示该选项需要一个参数值。在这种情况下，用户需要在选项后面提供一个框架名称作为参数。</p>
</li>
<li>
<p><code>'设置框架'</code>：这是选项的描述文本，用于向用户解释选项的用途或目的。在帮助信息中，这个描述文本将帮助用户了解选项的含义。</p>
</li>
</ul>
<p>综合起来，这行代码的作用是定义一个名为<code>-f</code>（或<code>--framework</code>）的命令行选项，该选项需要用户提供一个框架名称作为参数。用户可以通过命令行来设置这个框架选项，而描述文本 <code>'设置框架'</code> 会在帮助信息中显示，以帮助用户理解这个选项的目的。</p>
<p>示例用法：</p>
<pre><code class="language-shell">my-cli --framework react
</code></pre>
<p>在这个示例中，<code>--framework</code>选项后面的<code>react</code>是用户提供的参数值，用来指定所选的框架。</p>
<h4 id="显示帮助信息">显示帮助信息</h4>
<p>使用Commander，我们还可以轻松地为我们的命令行工具生成帮助信息。只需在脚本中调用<code>program.parse(process.argv)</code>后，运行时，如果用户输入<code>--help</code>选项，将会显示帮助信息。例如：</p>
<pre><code class="language-shell">my-cli --help
</code></pre>
<p>这将在终端中显示以下信息：</p>
<pre><code class="language-shell">Usage: my-cli [options]

Options:
  -f --framework &lt;framework&gt;  设置框架
  -h, --help                 display help for command
</code></pre>
<h4 id="处理命令行输入">处理命令行输入</h4>
<p>最后，我们可以通过检查命令行输入来执行不同的操作。在我们的例子中，如果用户没有提供<code>-f</code>或<code>--framework</code>参数，Commander会提示错误，要求用户输入框架参数：</p>
<pre><code class="language-shell">my-cli -f
</code></pre>
<p>这将导致终端显示以下错误消息：</p>
<pre><code class="language-shell">error: option '-f --framework &lt;framework&gt;' argument missing
</code></pre>
<p>用户可以通过在<code>-f</code>后面输入框架参数来解决此错误，如：</p>
<pre><code class="language-shell">my-cli -f hello
</code></pre>
<p>这样，我们就可以使用Commander轻松处理命令行参数，增加命令和选项，以及生成帮助信息，从而更好地控制和定制我们的命令行工具的行为。</p>
<h3 id="如何处理自定义命令参数">如何处理自定义命令参数</h3>
<p>在命令行工具开发中，我们经常需要处理自定义的命令参数，以满足用户的需求。在这篇文章中，我们将探讨如何使用Node.js和Commander库来实现这一目标。我们的目标是创建一个命令行工具，允许用户通过输入<code>my-cli create xxx</code>来创建一个项目。同时，我们将通过<code>--help</code>命令自动生成帮助信息。</p>
<p>首先，让我们来看看在<code>bin/cli.js</code>中的代码：</p>
<pre><code class="language-javascript">#! /usr/bin/env node

const { program } = require('commander');

// 定义一个选项
program.option('-f --framework &lt;framework&gt;', '设置框架');

// 定义一个自定义命令
program
  .command('create &lt;project&gt; [other...]') //定义命令
  .alias('crt') //设置别名
  .description('创建项目') //备注
  .action((project, args) =&gt; { //回调函数
    console.log(project);
    console.log(args);
  });

// 解析命令行参数
program.parse(process.argv);
</code></pre>
<ul>
<li>
<p>我们首先引入了Commander库，并定义了一个选项，使用了<code>-f</code>（短格式）和<code>--framework</code>（长格式），允许用户设置一个框架名称作为参数。</p>
</li>
<li>
<p>接着，我们使用<code>program.command()</code>定义了一个名为<code>create</code>（或别名<code>crt</code>）的自定义命令。这个命令接受一个<code>project</code>参数和可选的<code>other</code>参数。</p>
</li>
<li>
<p>我们定义了一个<code>.action()</code>回调函数，用于处理命令的实际操作。在这里，我们简单地打印了<code>project</code>参数和<code>args</code>参数，以便演示如何访问这些自定义命令参数。</p>
</li>
<li>
<p>最后，我们使用<code>program.parse(process.argv)</code>来解析命令行参数。</p>
</li>
</ul>
<p>现在，让我们运行以下命令来测试：</p>
<pre><code class="language-shell">my-cli create myproject otherOptions
</code></pre>
<p>结果将是：</p>
<pre><code class="language-shell">myproject
[ 'otherOptions' ]
</code></pre>
<p>我们成功地捕获和处理了命令行参数。</p>
<p>另外，我们可以运行<code>--help</code>命令来查看自动生成的帮助信息：</p>
<pre><code class="language-shell">my-cli --help
</code></pre>
<p>输出内容：</p>
<pre><code class="language-shell">Options:
  -f --framwork &lt;framwork&gt;          设置框架
  -h, --help                        display help for command

Commands:
  create|crt &lt;product&gt; [orther...]  创建项目
  help [command]                    display help for command
</code></pre>
<p>你会发现，Commander自动将我们的自定义命令和选项集成到了帮助信息中，以帮助用户了解如何正确使用我们的命令行工具。</p>
<p>通过这个例子，我们学到了如何使用Node.js和Commander库来处理自定义命令参数，以及如何生成帮助信息，使我们的命令行工具更加友好和易用。</p>
<h3 id="逻辑代码模块化拆分">逻辑代码模块化拆分</h3>
<p>在开发命令行工具时，将代码模块化拆分是一个良好的实践，有助于保持代码的可维护性和可扩展性。下面，我们将根据不同的功能进行拆分，并创建模块化的代码结构。</p>
<p>首先，我们新建一个<code>lib/core</code>文件夹，并在其中创建以下模块。</p>
<h4 id="1-helpjs-模块">1. <code>help.js</code> 模块</h4>
<p>在<code>lib/core</code>文件夹下创建一个<code>help.js</code>文件，其内容如下：</p>
<pre><code class="language-javascript">const setupHelp = (program) =&gt; {
    program.option('-f --framework &lt;framework&gt;', '设置框架');
};

module.exports = setupHelp;
</code></pre>
<p>此模块用于配置命令行工具的帮助选项，并将其导出供其他模块使用。</p>
<h4 id="2-mycommanderjs-模块">2. <code>myCommander.js</code> 模块</h4>
<p>接下来，在<code>lib/core</code>文件夹中创建一个<code>myCommander.js</code>文件：</p>
<pre><code class="language-javascript">const setupMyCommander = (program) =&gt; {
    program.command('create &lt;project&gt; [other...]')
        .alias('crt')
        .description('创建项目')
        .action((project, args) =&gt; {
            console.log(project);
            console.log(args);
        });
};

module.exports = setupMyCommander;
</code></pre>
<p>这个模块用于配置自定义命令，并将其导出供其他模块使用。</p>
<h4 id="3-actionjs-模块">3. <code>action.js</code> 模块</h4>
<p>最后，在<code>lib/core</code>文件夹下创建一个<code>action.js</code>文件，其中包含命令的实际操作逻辑：</p>
<pre><code class="language-javascript">const performAction = (project, args) =&gt; {
    console.log(project);
    console.log(args);
};

module.exports = performAction;
</code></pre>
<p>这个模块包含了实际操作的代码，并将其导出供其他模块使用。</p>
<p>接下来，让我们在 <code>/bin/cli.js</code> 中引入这些模块，并将它们组合在一起：</p>
<pre><code class="language-javascript">#! /usr/bin/env node
const { program } = require('commander');

// 导入模块
const setupHelp = require('../lib/core/help');
const setupMyCommander = require('../lib/core/myCommander');
const performAction = require('../lib/core/action');

// 配置帮助选项
setupHelp(program);

// 配置自定义命令
setupMyCommander(program);

// 设置命令的实际操作
program.action(performAction);

// 解析命令行参数
program.parse(process.argv);
</code></pre>
<p>通过这种方式，我们将代码逻辑模块化拆分，使其更易于理解和维护。同时，也提供了更好的可扩展性，以便将来添加更多功能或命令时能够更轻松地扩展我们的命令行工具。</p>
<h3 id="命令行交互问答工具-inquirer">命令行交互问答工具: Inquirer</h3>
<p>通常，在命令行中需要与用户进行交互式的操作，比如询问用户一些问题，获取输入等。这时候，我们可以使用 <a href="https://www.npmjs.com/package/inquirer">Inquirer</a> 库来方便地实现这些功能。</p>
<h4 id="安装-inquirer">安装 Inquirer</h4>
<p>首先，我们需要安装 Inquirer 库，可以通过以下命令进行安装：</p>
<pre><code class="language-shell">npm install --save inquirer@^8.0.0
</code></pre>
<h4 id="使用示例">使用示例</h4>
<p>安装完成后，我们可以在根目录下创建一个 <code>/test/inquirer.js</code> 文件来测试一下：</p>
<pre><code class="language-javascript">const inquirer = require('inquirer');

inquirer.prompt([
    {
        type: 'input',
        name: 'username',
        message: '你的名字',
    }
]).then(res =&gt; {
    console.log(res);
});
</code></pre>
<p>在当前文件夹内运行以下命令：</p>
<pre><code class="language-shell">node inquirer.js
</code></pre>
<p>这将提示你输入名字，然后打印出你输入的内容：</p>
<pre><code class="language-shell">{ username: '11' }
</code></pre>
<h4 id="创建一个交互式命令">创建一个交互式命令</h4>
<p>接下来，我们可以尝试改造之前的 <code>create</code> 命令。</p>
<p>打开 <code>/lib/core/action.js</code> 文件，引入 <code>inquirer</code>，同时在根目录下创建 <code>/config.js</code> 用于保存一些配置项：</p>
<pre><code class="language-javascript">/** action.js */
const inquirer = require('inquirer');
const config = require('../../config');

const myAction = (project, args) =&gt; {
    inquirer.prompt([
        {
            type: 'list',
            name: 'framework',
            message: '请选择你使用的框架',
            choices: config.framework,
        }
    ]).then(res =&gt; {
        console.log(res);
    });
}

module.exports = myAction;
</code></pre>
<p><code>config.js</code> 文件内容如下：</p>
<pre><code class="language-javascript">module.exports = {
    framework: ['egg', 'koa', 'express']
}
</code></pre>
<p>然后在 <code>/bin/cli.js</code> 文件中引入并使用这个模块：</p>
<pre><code class="language-javascript">const { program } = require('commander');

const setupHelp = require('../lib/core/help');
const setupMyCommander = require('../lib/core/myCommander');
const performAction = require('../lib/core/action');

setupHelp(program);
setupMyCommander(program);

program.action(performAction);

program.parse(process.argv);
</code></pre>
<p>现在，在项目根目录下运行以下命令：</p>
<pre><code class="language-shell">my-cli create nodetest
</code></pre>
<p>将会在控制台中出现一个选项供你选择，选择完成后回车，你将得到你选择的值：</p>
<pre><code class="language-shell">? 请选择你使用的框架 koa
{ framework: 'koa' }
</code></pre>
<p>通过这样的方式，我们使用 Inquirer 实现了一个交互式命令，使我们的命令行工具更加灵活和友好。</p>
<blockquote>
<p>当使用<code>inquirer.prompt()</code>时，我们可以传递一个配置对象，以定制交互式的提示。以下是一些常用的配置项及其说明：</p>
</blockquote>
<ol>
<li>
<p><code>type</code>（类型）: 定义了用户交互的类型。常用的类型包括：</p>
<ul>
<li><code>input</code>: 接收用户的文本输入。</li>
<li><code>list</code>: 提供一个列表供用户选择。</li>
<li><code>checkbox</code>: 提供一个多选框列表供用户选择。</li>
<li><code>confirm</code>: 提供一个是/否 的确认选择。</li>
</ul>
</li>
<li>
<p><code>name</code>（名称）: 定义了交互结果在返回的对象中的键名。</p>
</li>
<li>
<p><code>message</code>（消息）: 显示给用户的问题或提示信息。</p>
</li>
<li>
<p><code>default</code>（默认值）: 设定一个默认值，如果用户直接按下回车，则使用该值。</p>
</li>
<li>
<p><code>choices</code>（选项）: 用于<code>list</code>和<code>checkbox</code>类型的交互，提供可供选择的选项。</p>
</li>
<li>
<p><code>validate</code>（验证）: 可以是一个函数，用于验证用户的输入，返回 <code>true</code> 表示合法，返回错误消息字符串表示非法。</p>
</li>
<li>
<p><code>filter</code>（过滤）: 可以是一个函数，用于对用户的输入进行处理，返回处理后的值。</p>
</li>
<li>
<p><code>when</code>（条件）: 可以是一个函数，根据前一个问题的答案来确定是否需要显示当前问题。</p>
</li>
<li>
<p><code>pageSize</code>（分页大小）: 用于<code>list</code>类型的交互，设置显示的选项数量。</p>
</li>
<li>
<p><code>prefix</code>（前缀）: 在问题显示前，可添加一个前缀。</p>
</li>
<li>
<p><code>suffix</code>（后缀）: 在问题显示后，可添加一个后缀。</p>
</li>
<li>
<p><code>transformer</code>（转换器）: 用于对用户输入和交互结果的进一步处理。</p>
</li>
<li>
<p><code>loop</code>（循环）: 当<code>type</code>为<code>list</code>时，选择到最后一个选项会回到第一个选项。</p>
</li>
<li>
<p><code>validate</code>（验证）: 可以是一个函数，用于对用户的输入进行验证。</p>
</li>
<li>
<p><code>default</code>（默认值）: 设置一个默认值，如果用户直接按下回车，则使用该值。</p>
</li>
</ol>
<p>这些参数可以根据需求组合使用，以实现丰富的交互体验。</p>
<p>示例:</p>
<pre><code class="language-javascript">inquirer.prompt([
    {
        type: 'input',
        name: 'username',
        message: '请输入你的名字',
        default: 'John Doe', // 默认值
        validate: function (value) {
            if (value.length) {
                return true; // 输入合法
            }
            return '请输入你的名字'; // 输入非法时的错误消息
        }
    },
    {
        type: 'list',
        name: 'color',
        message: '选择一种颜色',
        choices: ['Red', 'Green', 'Blue'], // 提供的选项
        pageSize: 5 // 分页大小
    },
    // ...
]).then(answers =&gt; {
    console.log(answers);
});
</code></pre>
<h3 id="如何下载远程项目代码">如何下载远程项目代码</h3>
<p><a href="https://www.npmjs.com/package/download-git-repo">download-git-repo</a>是一个用于从 Git 仓库下载代码的 Node.js 模块。它可以将远程仓库中的代码下载到本地的文件夹中。</p>
<h4 id="安装插件">安装插件：</h4>
<pre><code class="language-shell">npm install download-git-repo
</code></pre>
<h4 id="使用方法">使用方法</h4>
<p>首先，在我们之前创建的 <code>/config.js</code> 文件中添加了远程项目的仓库地址：</p>
<pre><code class="language-js">module.exports = {
    framwork: ['egg', 'koa', 'express'],
    framworkUrl: {
        'egg': 'https://github.com/LonJinUp/lonjin-helper',
        'koa': 'https://github.com/LonJinUp/wxTabBar',
        'express': 'https://github.com/LonJinUp/vue-prettier-plugin'
    }
}
</code></pre>
<p>接着，我们创建了 <code>/lib/core/download.js</code> 文件，引入了 <code>download-git-repo</code> 并定义了一个函数：</p>
<pre><code class="language-js">const download = require('download-git-repo')
const downFramwork = (url, project) =&gt; {
    download(`direct:${url}`, project, { clone: true }, (error) =&gt; {
        console.log(error)
    })
}

module.exports = downFramwork
</code></pre>
<blockquote>
<p>关于<code>download-git-repo</code>中<code>download</code>参数详细解释如下：</p>
</blockquote>
<pre><code class="language-javascript">download(repository, destination, options, callback)
</code></pre>
<ul>
<li>
<p><code>repository</code>: 一个字符串，表示 Git 仓库的地址。可以是 HTTPS 或者 SSH 形式的 Git 仓库地址，也可以是 GitHub、GitLab 或者 Bitbucket 等托管服务的地址。</p>
</li>
<li>
<p><code>destination</code>: 一个字符串，表示目标文件夹的路径，代码将会下载到该文件夹中。</p>
</li>
<li>
<p><code>options</code>: 一个包含配置选项的对象，可以用来定制下载的行为。常用选项包括：</p>
<ul>
<li>
<p><code>clone</code>: 一个布尔值，表示是否使用 Git 的克隆功能，默认为 <code>false</code>。如果设置为 <code>true</code>，将会使用 Git 克隆整个仓库，否则将会直接下载 ZIP 归档文件（速度更快，但不支持私有仓库）。</p>
</li>
<li>
<p><code>checkout</code>: 一个字符串，表示在下载后将会检出的分支或标签名。</p>
</li>
<li>
<p><code>depth</code>: 一个整数，表示 Git 克隆时的深度（即历史记录的数量），默认为 <code>undefined</code>，表示克隆完整的历史记录。</p>
</li>
</ul>
</li>
<li>
<p><code>callback</code>: 一个回调函数，当下载完成时会调用该函数，可以获取到错误信息。</p>
</li>
</ul>
<p>最后，我们回到了 <code>/lib/core/action.js</code> 中，导入了我们编写好的函数，并做了一些调整。我们也将之前的 <code>inquirer</code> 改成了 <code>await</code> 的写法以提高代码的可读性。</p>
<pre><code class="language-js">const inquirer = require('inquirer')
const config = require('../../config')
const download = require('./download')

const myAction = async (project, args) =&gt; {
    const answer = await inquirer.prompt([
        {
            type: 'list',
            name: 'framework',
            message: '请选择你使用的框架',
            choices: config.framework
        }
    ])
    // 下载模板
    download(config.frameworkUrl[answer.framework], project)
}

module.exports = myAction
</code></pre>
<p>最后，我们执行如下命令：</p>
<pre><code class="language-shell">my-cli create text-download-1 
</code></pre>
<p>然后根据你的选择，会下载相应的远程代码，并且文件夹的名称将与 <code>create</code> 命令后面的参数一致。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://lonjinup.github.io/vue-prettier-plugin/" class="post-title gt-a-link">
                     vue2项目如何在运行时通过prettier格式化代码
                </a>
            </div>
        

        

        
            
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'db2f457cc3883b93aadf',
    clientSecret: '8c89802acb4c16969d407de1d7bcee30a0d51886',
    repo: 'lonjinup.github.io',
    owner: 'LonJinUp',
    admin: ['LonJinUp'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">记录学习 记录生活</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/long-jin-48-31" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://lonjinup.github.io/" target="_blank">LonJin</a>
<script type="text/javascript">window.$crisp=[];window.CRISP_WEBSITE_ID="0fdde3b6-a87f-4594-9b7f-25d151ba858f";(function(){d=document;s=d.createElement("script");s.src="https://client.crisp.chat/l.js";s.async=1;d.getElementsByTagName("head")[0].appendChild(s);})();</script>
<style>
.gt-bg-theme-color-second{ background: none!important;}
</style>

    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://lonjinup.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
